# to recover individual items, csh this file
#=======================================================================
echo makelib
cat >makelib <<"ENDOF makelib"
#!/bin/csh -f
#=======================================================================
# makelib ************************************
echo " VEDA_COMPILE and VEDA_BIN variables are:"
echo "        " $VEDA_COMPILE
echo "        " $VEDA_BIN
if(! -e $VEDA_BIN) mkdir $VEDA_BIN
#=======================================================================
chmod u+x bundle
#=======================================================================
echo " "
echo " >>>>>>>>>> URO <<<<<<<<<<"
echo " "
echo " ********** makelib **********"
csh -f uro.for | sed -e "s/\.f//" >! LisT

echo '#\!/bin/csh -f' >! maitre.scr
echo 'set VEDABIN="$VEDA/$VEDA_BIN"' >> maitre.scr
echo 'uro udi2i tab2i' >! MAITRE
   foreach nom (`cat MAITRE`)
./bundle $nom.f >> maitre.scr
echo '$VEDA_COMPILE' $nom.f '$VEDABIN/esclave.a' -o e/$nom.exe >> maitre.scr
echo "rm -f $nom.f" >> maitre.scr
   end

if(-e $VEDA_BIN/esclave.a) rm -f $VEDA_BIN/esclave.a
   foreach nom (`cat LisT`)
echo $nom
$VEDA_COMPILE $nom.f -c
ar q $VEDA_BIN/esclave.a $nom.o
rm -f $nom.f $nom.o
   end
#ranlib $VEDA_BIN/esclave.a >&/dev/null
rm -f LisT
echo " ********** makelink **********"
grep '      program ' uro.for | sed -e 's/program//' >! LisT
cp $VEDA_BIN/esclave.a esclave.a
   foreach nom (`cat LisT`)
echo $nom
if(-e $VEDA_BIN/$nom.exe) rm -f $VEDA_BIN/$nom.exe
ar x esclave.a $nom.o
ar d esclave.a $nom.o
#ranlib esclave.a >&/dev/null
$VEDA_COMPILE $nom.o esclave.a -o $VEDA_BIN/$nom.exe
rm -f $nom.o
   end
rm -f LisT esclave.a uro.for
#=======================================================================
echo " "
echo " >>>>>>>>>> FIT <<<<<<<<<<"
echo " "
echo " ********** makelib **********"
csh -f fit.for | sed -e "s/\.f//" >! LisT

echo 'fitin' >! MAITRE
   foreach nom (`cat MAITRE`)
./bundle $nom.f >> maitre.scr
echo '$VEDA_COMPILE' $nom.f '$VEDABIN/esclava.a' -o e/$nom.exe >> maitre.scr
echo "rm -f $nom.f" >> maitre.scr
   end

if(-e $VEDA_BIN/esclava.a) rm -f $VEDA_BIN/esclava.a
   foreach nom (`cat LisT`)
echo $nom
$VEDA_COMPILE $nom.f -c
ar q $VEDA_BIN/esclava.a $nom.o
rm -f $nom.f $nom.o
   end
#ranlib $VEDA_BIN/esclava.a >&/dev/null
rm -f LisT
echo " ********** makelink **********"
grep '      program ' fit.for | sed -e 's/program//' >! LisT
cp $VEDA_BIN/esclava.a esclava.a
   foreach nom (`cat LisT`)
echo $nom
if(-e $VEDA_BIN/$nom.exe) rm -f $VEDA_BIN/$nom.exe
ar x esclava.a $nom.o
ar d esclava.a $nom.o
#ranlib esclava.a >&/dev/null
$VEDA_COMPILE $nom.o esclava.a -o $VEDA_BIN/$nom.exe
rm -f $nom.o
   end
rm -f LisT esclava.a fit.for
#=======================================================================
echo " "
echo " >>>>>>>>>> STF <<<<<<<<<<"
echo " "
echo " ********** makelib **********"
csh -f stfing.for | sed -e "s/\.f//" >! LisT

echo 'stfing' >! MAITRE
   foreach nom (`cat MAITRE`)
./bundle $nom.f >> maitre.scr
echo '$VEDA_COMPILE' $nom.f '$VEDABIN/esclavo.a' -o e/$nom.exe >> maitre.scr
echo "rm -f $nom.f" >> maitre.scr
   end

if(-e $VEDA_BIN/esclavo.a) rm -f $VEDA_BIN/esclavo.a
   foreach nom (`cat LisT`)
echo $nom
$VEDA_COMPILE $nom.f -c
ar q $VEDA_BIN/esclavo.a $nom.o
rm -f $nom.f $nom.o
   end
#ranlib $VEDA_BIN/esclavo.a >&/dev/null
rm -f LisT
echo " ********** makelink **********"
grep '      program ' stfing.for | sed -e 's/program//' >! LisT
cp $VEDA_BIN/esclavo.a esclavo.a
   foreach nom (`cat LisT`)
echo $nom
if(-e $VEDA_BIN/$nom.exe) rm -f $VEDA_BIN/$nom.exe
ar x esclavo.a $nom.o
ar d esclavo.a $nom.o
#ranlib esclavo.a >&/dev/null
$VEDA_COMPILE $nom.o esclavo.a -o $VEDA_BIN/$nom.exe
rm -f $nom.o
   end
rm -f LisT esclavo.a stfing.for MAITRE
#=======================================================================
echo " "
echo " >>>>>>>>>> UTIL <<<<<<<<<<"
echo " "
echo " ********** makelib **********"
csh -f util.for | sed -e "s/\.f//" >! LisT
if(-e $VEDA_BIN/slave.a) rm -f $VEDA_BIN/slave.a
   foreach nom (`cat LisT`)
echo $nom
$VEDA_COMPILE $nom.f -c
ar q $VEDA_BIN/slave.a $nom.o
rm -f $nom.f $nom.o
   end
#ranlib $VEDA_BIN/slave.a >&/dev/null
rm -f LisT
echo " ********** makelink **********"
grep '      program ' util.for | sed -e 's/program//' >! LisT
cp $VEDA_BIN/slave.a slave.a
   foreach nom (`cat LisT`)
echo $nom
if(-e $VEDA_BIN/$nom.exe) rm -f $VEDA_BIN/$nom.exe
ar x slave.a $nom.o
ar d slave.a $nom.o
#ranlib slave.a >&/dev/null
$VEDA_COMPILE $nom.o slave.a -o $VEDA_BIN/$nom.exe
rm -f $nom.o
   end
rm -f LisT slave.a util.for
#=======================================================================
echo " "
echo " >>>>>>>>>> COMS <<<<<<<<<<"
echo " "
csh uro.scr ; rm -f uro.scr
csh fit.scr ; rm -f fit.scr
if(! -e $VEDA/uro) mkdir $VEDA/uro
chmod u+x seturo
mv -f factor.d maitre.scr setup seturo $VEDA/uro/
#=======================================================================
rm -f makelib bundle
"ENDOF makelib"
#=======================================================================
echo seturo
cat >seturo <<"ENDOF seturo"
#!/bin/csh -f
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if($#argv == 0) then
echo ''
echo '#########################################################'
echo ''
echo 'Usage:'
echo 'seturo -- emap = "FILENAME"'
echo '       -- model = "FILENAME" # "ID" : "# MOLECULES" , "FILENAME" # "ID" : "# MOLECULES"'
echo '       -- resol = "RESMAX" , "RESMIN"'
echo '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
echo '-- emap = "filename of vtk-map"'
echo '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
echo '-- model = "filename of model" # "identifier" : "# of associated independent molecules"'
echo '           groups of "FILENAME" # "ID" : "# MOLECULES" separated by commas'
echo '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
echo '-- resol = "resolution range to fit (in Angstroms)"'
echo '~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'
echo ''
echo '#########################################################'
echo ''
echo 'example:'
echo 'seturo --emap= emap.vtk --models= vp6.pdb # 1 : 2 --resol= 400.0 20.0'
echo ''
echo 'echo of interpreted input if "test" at the end of line:'
echo '$VEDA/uro/seturo --emap= emap.vtk --models= vp6.pdb # 1 : 2 --resol= 400. 20. test'
echo ''
echo '#########################################################'
echo ''
exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
set VEDABIN="$VEDA/$VEDA_BIN"
########################################################################
set TEST=`echo $argv | awk -F" " '{print $NF}'`
   if(${TEST} == 'test') then
set nb=`expr $#argv - 1`
echo $argv[1-$nb] > InpuT
   else
echo $argv > InpuT
   endif
$VEDABIN/select.exe < InpuT >! LisT
set STOP=`awk '{if($1 ~ /stop/){print 1}}' LisT`
   if($STOP == 1) then
echo ''
echo ' >>>>> ERROR <<<<< wrong or incomplete input arguments'
echo ''
cat LisT
rm -f LisT
exit
   endif
set EMAP=`grep 'EMAP=' LisT | sed -e 's/EMAP=//'`
set MODELS=`grep 'MODELS=' LisT | sed -e 's/MODELS=//'`
set MOLECULES=`grep 'MOLECULES=' LisT | sed -e 's/MOLECULES=//'`
set MODIDS=`grep 'IDENTIFYS=' LisT | sed -e 's/IDENTIFYS=//'`
set RESOL=`grep 'RESOLUTION=' LisT | sed -e 's/RESOLUTION=//'`
rm -f InpuT LisT
########################################################################
   if(${TEST} == 'test') then
echo ''
echo ' >>>>> INPUT ECHO <<<<<'
echo ' emap : '$EMAP
echo ' # models : '$MOLECULES[1]
echo ' models filenames : '$MODELS
echo -n >! modis
echo -n >! moles
set n='1'
      while($n <= $#MODIDS)
echo '#'$MODIDS[$n] >> modis
set m=`expr $n  + 1`
echo $MOLECULES[$m] >> moles
set n=`expr $n  + 1`
      end
set MODIS=`paste -s modis`
set MOLES=`paste -s moles`
echo ' models IDs : '$MODIS
echo ' # molecules to place : '$MOLES
echo ' resolution range : '$RESOL
rm -f modis moles
   endif
########################################################################
set STOP='0'
   if(! -e $EMAP) then
set STOP='1'
echo ''
echo ' >>>>> ERROR <<<<< file '$EMAP 'does not exist'
echo ''
   endif
set n='1'
   while($n <= $MOLECULES[1])
      if(! -e $MODELS[$n]) then
set STOP='1'
echo ''
echo ' >>>>> ERROR <<<<< file '$MODELS[$n] 'does not exist'
echo ''
      endif
set n=`expr $n  + 1`
   end
if($STOP == '1') exit
########################################################################
csh $VEDA/uro/setup >&/dev/null
cp $VEDABIN/udi2i $VEDABIN/tab2i $VEDABIN/fitin e/
########################################################################
set namemap=`basename $EMAP`
set namemod=`basename $MODELS[1]`
set m=2
   while($m <= $#MODELS)
set namemod=`echo $namemod' + '``basename $MODELS[$m]`
set m=`expr $m + 1`
   end
cat >! LisT <<"ENDOF"
#!/bin/csh -f
cat >! d/data.d <<ENDOF
 ** URO ** ${namemap} ** ${namemod} ** ${RESOL} **
CELL
x,y,z * end
ENDOF
cat >> d/data.d <<ENDOF
1                   ; orthogonalising code
100.   0.           ; % reflections, b-add
${RESOL}            ; resolution range
ENDOF
"ENDOF"
source ./LisT ; rm -f LisT
########################################################################
if(${TEST} == 'test') exit
echo -n >! STOP
e/emft ${EMAP}
########################################################################
echo -n >! STOPM
set n='1'
   while($n <= $MOLECULES[1])
set TYPE=`echo $MODELS[$n] | awk -F"." '{print $NF}'`
set mod=$MODIDS[$n]
      if(${TYPE} == 'vtk') then
$VEDABIN/v2dm.exe <<ENDOF
$MODELS[$n]
d/map${mod}.d
ENDOF
set modeln=`$VEDABIN/wholepath $MODELS[$n]`
ln -sf $modeln d/map${mod}.vtk
      else
set SKIP=`grep '^FORMAT ' $MODELS[$n] | head -1 | awk '{if($1 ~ /FORMAT/){print 1}}' -`
         if($SKIP != '1') then
echo 'FORMAT  (12x,a4,14x,3f8.3,6x,f6.2)' >! moles
cat $MODELS[$n] >> moles ; mv -f moles $MODELS[$n] ; chmod 400 $MODELS[$n]
         endif
set modeln=`$VEDABIN/wholepath $MODELS[$n]`
ln -sf $modeln d/xyz${mod}.d
      endif
e/scat ${mod}
grep '^stop' o/tabl${mod}.s >> STOPM
if(-e HISTT) mv HISTT HISTT-${mod}
set n=`expr $n  + 1`
   end
########################################################################
echo ''
echo ' >>>>> END OF MAP FOURIER TRANSFORMATION <<<<<'
cat STOP ; rm -f STOP
echo ''
echo ''
echo ' >>>>> END OF MOLECULAR SCATTERING FACTORS CALCULATION <<<<<'
cat STOPM ; rm -f STOPM
echo ''
########################################################################
cat >! wilson.gp <<"ENDOF"
set title "Wilson plot"
set xtics rotate by 90
set ylabel "ln(<I>)"
set xlabel "Angstroms"
plot 'HISTU' using 4:xtic(sprintf("%5.1f -%5.1f",$1,$3)) with linespoints pt 5 lc 1 title 'Target Map'
"ENDOF"
set n='1'
   while($n <= $MOLECULES[1])
set mod=$MODIDS[$n]
set m=`expr $n  + 1`
echo 'replot '\'HISTT-${mod}\'' using 4:xtic(sprintf("%5.1f -%5.1f",$1,$3)) with linespoints pt 5 lc '${m}' title '\'M$n\' >> wilson.gp
set n=`expr $n  + 1`
   end
gnuplot -persist wilson.gp
"ENDOF seturo"
#=======================================================================
echo setup
cat >setup <<"ENDOF setup"
# to recover individual items, csh this file
#=======================================================================
mkdir ./d
mkdir ./e
mkdir ./f
mkdir ./i
mkdir ./o
#=======================================================================
echo e/magnum
cat >e/magnum <<"ENDOF e/magnum"
#!/bin/csh -f
# magnum *************************************
   if($#argv < 2) then
echo "Usage: {e/magnum} {step} {Nstep}"
echo "   1-step*Nstep <= scale <= 1+step*Nstep" ; exit
   endif
   if(! -e G0 || ! -e G1) then
echo "DO URO-FITTING FIRST" ; exit
   endif
set STEP=$1
set NSTP=$2
set VEDABIN="$VEDA/$VEDA_BIN"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
set EMAP=`ls -l d/emap.d | sed -e 's/.*\/home/\/home/'`
set SPACE=`head -20 $EMAP |grep 'SPACING' |sed -e "s/SPACING//"`
set ORIGEN=`head -20 $EMAP |grep 'ORIGIN' |sed -e "s/ORIGIN//"`
cp -f $EMAP veda_map.vtk
cp -f i/oicfd.i2 oicfd.i2
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$VEDABIN/addsym G0 G1 M0
set scale='1.0'
set SPACING=`echo ${SPACE}`
rm -f d/emap.d
./e/emft veda_map.vtk
sed -e "/CYCLES/s/.*/ 1  50 0.001 0 CYCLES/" oicfd.i2 >! i/oicfd.i2
./e/docking M0 M1
echo $scale' '`tail -1 M1 |sed -e 's/#//' |awk '{print $8}'`' ; '$SPACING >! MAGNA
rm -f STOP M0 M1
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$VEDABIN/addsym G0 G1 M0
set n=1
   while ($n <= $NSTP)
set scale=`echo $n' '$STEP |awk '{print 1 - $1*$2}'`
sed -e "s/SCALE/${scale}/" <<"EOF" >! LisT
BEGIN {S=SCALE} {printf "%15.5f%15.5f%15.5f\n",S*$1,S*$2,S*$3}
"EOF"
set SPACING=`echo ${SPACE} |awk -f LisT -`
sed -i -e "/SPACING/s/.*/SPACING ${SPACING}/" veda_map.vtk
set ORIGIN=`echo ${ORIGEN} |awk -f LisT -`
sed -i -e "/ORIGIN/s/.*/ORIGIN ${ORIGIN}/" veda_map.vtk
rm -f d/emap.d
./e/emft veda_map.vtk
sed -e "/CYCLES/s/.*/ 1  50 0.001 0 CYCLES/" oicfd.i2 >! i/oicfd.i2
./e/docking M0 M1
$VEDABIN/addsym G0 M1 M0
echo $scale' '`tail -1 M1 |sed -e 's/#//' |awk '{print $8}'`' ; '$SPACING >> MAGNA
rm -f LisT STOP M1
set n=`expr $n + 1`
   end
rm -f M0
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$VEDABIN/addsym G0 G1 M0
set n=1
   while ($n <= $NSTP)
set scale=`echo $n' '$STEP |awk '{print 1 + $1*$2}'`
sed -e "s/SCALE/${scale}/" <<"EOF" >! LisT
BEGIN {S=SCALE} {printf "%15.5f%15.5f%15.5f\n",S*$1,S*$2,S*$3}
"EOF"
set SPACING=`echo ${SPACE} |awk -f LisT -`
sed -i -e "/SPACING/s/.*/SPACING ${SPACING}/" veda_map.vtk
set ORIGIN=`echo ${ORIGEN} |awk -f LisT -`
sed -i -e "/ORIGIN/s/.*/ORIGIN ${ORIGIN}/" veda_map.vtk
rm -f d/emap.d
./e/emft veda_map.vtk
sed -e "/CYCLES/s/.*/ 1  50 0.001 0 CYCLES/" oicfd.i2 >! i/oicfd.i2
./e/docking M0 M1
$VEDABIN/addsym G0 M1 M0
echo $scale' '`tail -1 M1 |sed -e 's/#//' |awk '{print $8}'`' ; '$SPACING >> MAGNA
rm -f LisT STOP M1
set n=`expr $n + 1`
   end
rm -f M0
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sort -n MAGNA >! MAGNUM
cat >! magnum.gp <<"ENDOF"
set title "CC vs magnification"
set xlabel "magnification scale"
plot 'MAGNUM' using ($1):($2) with linespoints notitle
"ENDOF"
gnuplot -persist magnum.gp
rm -f veda_map.vtk MAGNA
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./e/emft $EMAP
mv -f oicfd.i2 i/oicfd.i2
rm -f STOP
"ENDOF e/magnum"
#=======================================================================
echo e/ncsrms
cat >e/ncsrms <<"ENDOF e/ncsrms"
#!/bin/csh -f
# ncsrms *************************************
   if($#argv != 1) then
echo "Usage: {e/ncsrms} {fiting-input}" ; exit
   endif
   if(! -e ${1}) then
echo "No fiting input with this name = ${1}" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$VEDABIN/rt2pv ${1} o/rms0.s
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
date +"%T" | sed -e "s/\://g" >! seed
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/d/data.d $UROF/fort.8
ln -s $cwd/o/rms0.s $UROF/fort.1
ln -s $cwd/seed     $UROF/fort.2
ln -s $cwd/o/rms1.s $UROF/fort.9
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$VEDABIN/ncsrms.exe
rm -rf seed $UROF
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
echo ""
echo " Now running fiting for the different trials"
echo ""
e/oic rms1 fit
e/fiting fit rms2 >! log_rms
#egrep -e "cumulated" log_rms
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
set nbody=`head -2 o/rms1.s | sed -e '/fiting/d' | awk '{print -$2}'`
set rms='1.0'
$VEDABIN/propre rms2 $nbody $rms
egrep '#$' o/rms2.s|sed -e 's/#//'|sort -n -k 10,10 >! HISTR
cat HISTR
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cat >! rmshist.gp <<"ENDOF"
set title "RMS convergence threshold"
set xlabel "trial #"
plot 'HISTR' using 10 with linespoints pt 5 lc 1 title 'rms to solution'
replot 'HISTR' using 8 with linespoints pt 5 lc 2 title '100 x CC'
"ENDOF"
gnuplot -persist rmshist.gp
"ENDOF e/ncsrms"
#=======================================================================
echo e/norma
cat >e/norma <<"ENDOF e/norma"
#!/bin/csh -f
# norma *************************************
   if($#argv < 3) then
echo "Usage: {e/norma} {molecule} {init-stepi <= 0} {last-step >= 0}" ; exit
   endif
   if($2 > 0 || $3 < 0) then
echo "NEED 0 STEP" ; exit
   endif
   if(! -e N0) then
echo "NEED N0" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
set MOLE=$1
set INIT=$2
set LAST=$3
set CONF='33'
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cp -f i/oicfd.i2 oicfd.i2
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
set n=$INIT
   while ($n <= $LAST)
set modeln=veda_tmp/${MOLE}/out${n}
set SKIP=`grep '^FORMAT' $modeln |head -1 |awk '{if($1 ~ /FORMAT/){print 1}}' -`
      if($SKIP != '1') then
echo 'FORMAT (12x,a4,14x,3f8.3,6x,f6.2)' >! moles
cat $modeln >> moles ; mv -f moles $modeln
      endif
set n=`expr $n + 1`
   end
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
set n='0'
set modeln=`$VEDABIN/wholepath veda_tmp/${MOLE}/out${n}`
ln -sf $modeln d/xyz${CONF}.d
e/scat $CONF
sed -e "/CYCLES/s/.*/ -1  50 0.001 0 CYCLES/" oicfd.i2 >! i/oicfd.i2
./e/docking N0 N1
echo ${n}' '`tail -1 N1 |sed -e 's/#//' |awk '{print $8}'` >! NORMA
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if($INIT < 0) then
$VEDABIN/addsym N0 N1 M0
set n='-1'
      while ($n >= $INIT)
set modeln=`$VEDABIN/wholepath veda_tmp/${MOLE}/out${n}`
ln -sf $modeln d/xyz${CONF}.d
e/scat $CONF
sed -e "/CYCLES/s/.*/ -1  50 0.001 0 CYCLES/" oicfd.i2 >! i/oicfd.i2
./e/docking M0 M1
$VEDABIN/addsym N0 M1 M0
echo ${n}' '`tail -1 M1 |sed -e 's/#//' |awk '{print $8}'` >> NORMA
set n=`expr $n - 1`
      end
rm -f M0 M1
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if($LAST > 0) then
$VEDABIN/addsym N0 N1 M0
set n=1
      while ($n <= $LAST)
set modeln=`$VEDABIN/wholepath veda_tmp/${MOLE}/out${n}`
ln -sf $modeln d/xyz${CONF}.d
e/scat $CONF
sed -e "/CYCLES/s/.*/ -1  50 0.001 0 CYCLES/" oicfd.i2 >! i/oicfd.i2
./e/docking M0 M1
$VEDABIN/addsym N0 M1 M0
echo ${n}' '`tail -1 M1 |sed -e 's/#//' |awk '{print $8}'` >> NORMA
set n=`expr $n + 1`
      end
rm -f M0 M1
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sort -n NORMA >! NORMOD
cat >! norma.gp <<"ENDOF"
set title "CC vs #conformer"
set xlabel "# conformer"
plot 'NORMOD' using ($1):($2) with linespoints notitle
"ENDOF"
gnuplot -persist norma.gp
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
mv -f oicfd.i2 i/oicfd.i2
rm -f d/xyz${CONF}.d f/tabl${CONF} o/tabl${CONF}.s HISTT NORMA
"ENDOF e/norma"
#=======================================================================
echo e/splits
cat >e/splits <<"ENDOF e/splits"
#!/bin/csh -f
# splits *************************************
   if($#argv != 2) then
echo "Usage: {e/splits} o/{fiting-in}.s o/{fiting-out}.s" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
source $VEDABIN/entorno
ln -s $cwd/o/${1}.s $UROF/fort.1
ln -s $cwd/d/data.d $UROF/fort.8
ln -s $cwd/o/${2}.s $UROF/fort.9
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$VEDABIN/splits.exe <<EOF
#1 > #4 #5 #6
EOF
rm -rf $UROF
"ENDOF e/splits"
#=======================================================================
echo d/data.d
   if(! -e ./d/data.d) then
cat >d/data.d <<"ENDOF d/data.d"
 ** URO **
1. 1. 1. 90. 90. 90. CELL
x,y,z * stop
1                   ; orthogonalising code (PDB setting)
100    0.           ; % reflections, b-add
400.   15.          ; resolution range
"ENDOF d/data.d"
   endif
#=======================================================================
echo d/o2u.scr
cat >d/o2u.scr <<"ENDOF d/o2u.scr"
#!/bin/csh -f
# o2u ****************************************
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e gs.sym) then
echo "file with O symmetry operations must be named gs.sym"
echo "NEED gs.sym FILE" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cat >! prg.f <<"ENDOF prg.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program o2u
      implicit none
      integer i,j,length,n
      double precision alpha,beta,dtor,gamma,pi,rtod,symop,twopi,xt
      character card*80
      external length
      dimension symop(3,3),xt(3)
      common/angkte/ pi,twopi,dtor,rtod
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      open(unit=1,file='gs.sym',form='formatted',status='old')
      open(unit=2,file='SYM',form='formatted',status='unknown')
      n=0
       do i=1,80
      card(i:i)=' '
       enddo
      card(65:65)='#'
10    read(1,*,end=20)
       do i=1,3
      read(1,*) (symop(j,i),j=1,3)
       enddo
      read(1,*) xt
      call rmx2e(symop,alpha,beta,gamma)
      write(card(1:60),'(6f10.3)') alpha,beta,gamma,xt
      card(66:68)='   '
      n=n+1
         if(n.lt.10) then
      write(card(66:66),'(i1)') n
         else if(n.lt.100) then
      write(card(66:67),'(i2)') n
         else
      write(card(66:68),'(i3)') n
         endif
      write(2,'(a)') card(1:length(card))
      go to 10
20    stop
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function length(card)
      implicit none
      integer i,length
      character card*80
       do i=80,1,-1
      if(card(i:i).ne.' ') go to 10
       enddo
10    length=i
      return
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmx2e(rotx,alpha,beta,gamma)
      implicit none
      double precision alpha,ang,beta,cang,dtor,fuzz,gamma,pi,rotx,rtod,
     & sang,twopi
      dimension rotx(3,3)
      common/angkte/ pi,twopi,dtor,rtod
      fuzz=0.001
      cang=sqrt(min(max(2.d0-(rotx(1,3)**2+rotx(2,3)**2+rotx(3,1)**2+
     . rotx(3,2)**2+rotx(3,3)**2),0.d0),1.d0))
      ang=acos(sign(cang,rotx(3,3)))
      sang=sin(ang)
         if(sang.gt.fuzz) then
      alpha=atan2(rotx(2,3),rotx(1,3))
      gamma=atan2(rotx(3,2),-rotx(3,1))
         else
      alpha=atan2(-rotx(1,2),rotx(1,1)*rotx(3,3))
      gamma=0.
         endif
      alpha=mod(twopi+alpha,twopi)*rtod
      beta=ang*rtod
      gamma=mod(twopi+gamma,twopi)*rtod
      return
      end
"ENDOF prg.f"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$VEDA_COMPILE prg.f -o prg.exe
./prg.exe
rm -f prg.f prg.exe
"ENDOF d/o2u.scr"
#=======================================================================
echo d/u2o.scr
cat >d/u2o.scr <<"ENDOF d/u2o.scr"
#!/bin/csh -f
# u2o ****************************************
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e SYM) then
echo "file with URO symmetry operations must be named SYM"
echo "NEED SYM FILE" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cat >! prg.f <<"ENDOF prg.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program u2o
      implicit none
      integer S,i,ind,j,length
      double precision alpha,beta,dtor,gamma,pi,rtod,symop,twopi,xt
      character card*80,cart*80
      external length
      dimension symop(3,3),xt(3)
      common/angkte/ pi,twopi,dtor,rtod
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      open(unit=1,file='SYM',form='formatted',status='unknown')
      open(unit=2,file='gs.sym',form='formatted',status='unknown')
       do i=1,80
      cart(i:i)=' '
       enddo
      cart(1:40)='.LSQ_RT_SYM       R     12  (3F12.6)    '
10    read(1,'(a)',end=20) card
      read(card,*) alpha,beta,gamma,(xt(j),j=1,3)
      alpha=alpha*dtor
      beta=beta*dtor
      gamma=gamma*dtor
      call rmxe(alpha,beta,gamma,symop)
      ind=index(card,'#')
      read(card(ind+1:80),*) S
         if(S.lt.10) then
      write(cart(12:14),'(i1,a2)') S
         else if(S.lt.100) then
      write(cart(12:14),'(i2,a1)') S
         else
      write(cart(12:15),'(i3)') S
         endif
      write(2,'(a)') cart(1:length(cart))
cjn O usa la transpuesta
       do j=1,3
      write(2,'(3f12.6)') (symop(i,j),i=1,3)
       enddo
      write(2,'(3f12.6)') xt
      go to 10
20    stop
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function length(card)
      implicit none
      integer i,length
      character card*80
       do i=80,1,-1
      if(card(i:i).ne.' ') go to 10
       enddo
10    length=i
      return
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmxe(alpha,beta,gamma,rotx)
      implicit none
      double precision alpha,beta,cosa,cosb,cosg,gamma,rotx,sina,sinb,
     & sing
      dimension rotx(3,3)
      cosa=cos(alpha)
      sina=sin(alpha)
      cosb=cos(beta)
      sinb=sin(beta)
      cosg=cos(gamma)
      sing=sin(gamma)
      rotx(1,1)= cosa*cosb*cosg-sina*sing
      rotx(1,2)=-cosa*cosb*sing-sina*cosg
      rotx(1,3)= cosa*sinb
      rotx(2,1)= sina*cosb*cosg+cosa*sing
      rotx(2,2)=-sina*cosb*sing+cosa*cosg
      rotx(2,3)= sina*sinb
      rotx(3,1)=     -sinb*cosg
      rotx(3,2)=      sinb*sing
      rotx(3,3)=      cosb
      return
      end
"ENDOF prg.f"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$VEDA_COMPILE prg.f -o prg.exe
./prg.exe
rm -f prg.f prg.exe
"ENDOF d/u2o.scr"
#=======================================================================
echo e/emft
cat >e/emft <<"ENDOF e/emft"
#!/bin/csh -f
# emft ***************************************
   if($#argv != 1) then
echo "Usage: {e/emft} {vtk-map}" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
set MAP=${1}
   if(! -e ${MAP}) then
echo "No map with this name = ${MAP}" ; exit
   endif
set emap=`$VEDABIN/wholepath $MAP`
ln -sf $emap d/emap.d
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$VEDABIN/v2d.exe <<EOF | egrep -e " set mr |CELL" >! LisT
${MAP}
BoX.v2d
EOF
set STOP=`awk '{if($7 !~ /CELL/){print 0}}' LisT`
   if($STOP == 0) then
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo ">>>>>>>>>>>>>>>>>>>>>> problem with VTK map <<<<<<<<<<<<<<<<<<<<<<<<"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "stop : problem with VTK map" >> STOP
cat LisT ; rm -f LisT BoX.v2d ; exit
   endif
set cell=`cat LisT`
sed -e "s/.*CELL.*/CELL/" d/data.d >! LisT
set STOP=`grep CELL LisT`
   if($STOP != "CELL") then
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo ">>>>>>>>>>>>>>>>>>>>> no CELL card in data.d <<<<<<<<<<<<<<<<<<<<<<<"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "stop : no CELL card in data.d" >> STOP
rm -f LisT BoX.v2d ; exit
   endif
sed -e "/CELL/s/CELL/${cell}/" LisT >! d/data.d
set res=`grep "resolution range" d/data.d`
rm -f LisT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/BoX.v2d $UROF/fort.1
ln -s $cwd/d/hkl.d $UROF/fort.2
$UROS/stfing.exe <<EOF
stfing :
 ** URO **
${cell}
x,y,z * end
${res}
0.                       ; additive b-fact.
hkl                      ; ='hkl' or ='udi'
EOF
rm -rf $UROF BoX.v2d
   if(! -e d/hkl.d) then
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo ">>>>>>>>>>>>>>>>>>>>>> problem with STFING <<<<<<<<<<<<<<<<<<<<<<<<<"
echo ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>"
echo "stop : problem with STFING" >> STOP
exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/d/data.d   $UROF/fort.8
ln -s $cwd/i/oicfd.i2 $UROF/fort.10
ln -s $cwd/i/sort.i1  $UROF/fort.11
ln -s $cwd/i/tabl.i1  $UROF/fort.12
$UROX/uro.exe < $cwd/i/dato.i3
rm -rf $UROF
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/d/hkl.d  $UROF/fort.1
ln -s $cwd/o/sort.s $UROF/fort.9
ln -s $cwd/f/xudi   $UROF/fort.10
$UROX/uro.exe < $cwd/i/sort.i1
grep '^stop' o/sort.s >> STOP
rm -rf $UROF d/hkl.d
set res=`grep 'selected rang' o/sort.s |awk '{printf "%9.1f %9.1f",$6,$8-0.05}'`
set his=`grep 'HISTO' i/tabl.i1 | awk '{print $3}'`
sed -i -e "/HISTO/s/.*/${res} ${his} HISTO/" i/tabl.i1
"ENDOF e/emft"
#=======================================================================
echo e/fiting
cat >e/fiting <<"ENDOF e/fiting"
#!/bin/csh -f
# fiting *************************************
   if($#argv != 2) then
echo "Usage: {e/fiting} i/{fiting-in}.i1 o/{fiting-out}.s" ; exit
   endif
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/o/$2.s $UROF/fort.9
ln -s $cwd/f/xudi $UROF/fort.10
set n="1"
   while ($n <= 100)
      if(-e $cwd/f/tabl$n) then
set m=`expr $n + 10`
ln -s $cwd/f/tabl$n $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$UROX/uro.exe < $cwd/i/$1.i1
rm -rf $UROF
"ENDOF e/fiting"
#=======================================================================
echo e/oic
cat >e/oic <<"ENDOF e/oic"
#!/bin/csh -f
# oic ****************************************
   if($#argv < 2) then
echo "Usage: {e/oic} o/{fiting-out}.s i/{fiting-in}.i1" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e o/${1}.s) then
echo "No fiting output with this name = o/${1}.s" ; exit
   endif
   if(! -e symlist) then
echo "NEED symlist FILE" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/o/${1}.s  $UROF/fort.1
ln -s $cwd/d/data.d  $UROF/fort.8
ln -s $cwd/i/${2}.i1 $UROF/fort.9
set n="1"
      while ($n <= 100)
   if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
   endif
set n=`expr $n + 1`
      end
$UROX/uro.exe < $cwd/i/oicfd.i2 >/dev/null
rm -rf $UROF
echo end >> i/${2}.i1
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
cat >! LisT <<"EOF"
{
   if($1 !~ /inertia/)
      print
   else
      exit
}
"EOF"
awk -f LisT i/${2}.i1 >! $UROF/fit.i1
rm -rf LisT
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# generates symmetry operations to apply to the independent molecules in
# the working cell. transforms symmetry operations into fractional and
# subtracts the origin.
set SYM=SYM
set MAP=d/emap.d
echo `head -20 ${MAP} | egrep -e "DIMENSIONS|SPACING|ORIGIN"` >! LisT
cat >! LisT1 <<"EOF"
{ printf "A=%8.3f;B=%8.3f;C=%8.3f;TX=%10.7f;TY=%10.7f;TZ=%10.7f\n",\
 $2*$6,$3*$7,$4*$8,$10/($2*$6),$11/($3*$7),$12/($4*$8) }
"EOF"
awk -f LisT1 LisT |sed -e "s/[ ]*//g" >! LisT2
set line=`cat LisT2`
rm -f LisT LisT1 LisT2
echo -n >! LisT1
set num="0"
   foreach sym (`cat symlist`)
egrep -e "#${sym}"$ $SYM >> LisT1
set num=`expr ${num} + 1`
   end
sed -e "/LINE/s/LINE/${line}/" <<"EOF" |sed -e "/NUMB/s/NUMB/${num}/" >! LisT2
BEGIN { LINE ; printf "ncs %5d\n",NUMB }
{ printf " %8.2f%8.2f%8.2f%10.5f%10.5f%10.5f      %s\n", \
       $1,$2,$3,$4/A-TX,$5/B-TY,$6/C-TZ,$7 }
"EOF"
awk -f LisT2 LisT1 >> $UROF/fit.i1
rm -f LisT1 LisT2
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cat >! LisT <<"EOF"
{
   if($1 == "inertia")
   {
      print
      getline
      while ($1 !~ /end/)
      {
         print
         getline
      }
      exit
   }
}
"EOF"
awk -f LisT i/${2}.i1 >> $UROF/fit.i1
sed -e "/printing/s/2    1 1    /4    1 1 0 1/" $UROF/fit.i1 | \
sed -e "/ 1 1 1 /s/ 0 0 0 / 1 1 1 /" >! i/${2}.i1
rm -rf LisT $UROF
"ENDOF e/oic"
#=======================================================================
echo e/docking
cat >e/docking <<"ENDOF e/docking"
#!/bin/csh -f
# docking ************************************
   if($#argv < 2) then
echo "Usage: {e/docking} {fiting-inp} {fiting-out}" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e SYM || ! -e d/data.d || ! -e d/emap.d || ! -e f/xudi) then
echo "NEED SYM d/data.d d/emap.d f/xudi" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e ${1}) then
echo "No fiting output with this name = ${1}" ; exit
   endif
   if(! -e symlist) then
echo "NEED symlist FILE" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
$VEDABIN/rt2pv ${1} o/${1}.s
$cwd/e/oic ${1} fit; $cwd/e/fiting fit ${2}
set STOP=`awk '{if($1 ~ /stop/){print 1}}' o/${2}.s`
if($STOP != 1) $VEDABIN/pv2rt o/${2}.s ${2}
"ENDOF e/docking"
#=======================================================================
echo e/scat
cat >e/scat <<"ENDOF e/scat"
#!/bin/csh -f
# scat ***************************************
   if($#argv != 1) then
echo "Usage: {e/scat} {model-nb}" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e $cwd/d/xyz${1}.d && ! -e $cwd/d/map${1}.d) then
echo "No model with this number = ${1}" ; exit
   endif
   if(! -e $cwd/i/tabl.i1) then
echo "Must first execute e/emft" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/d/xyz${1}.d   $UROF/fort.1
ln -s $cwd/d/map${1}.d   $UROF/fort.2
ln -s $VEDA/uro/factor.d $UROF/fort.3
ln -s $cwd/o/tabl${1}.s  $UROF/fort.9
ln -s $cwd/f/tabl${1}    $UROF/fort.10
   if(-e $cwd/d/xyz${1}.d) then
sed -e '/^map/s/map/xyz/' $cwd/i/tabl.i1 >! $UROF/tabl.i1
   else if(-e $cwd/d/map${1}.d) then
sed -e '/^xyz/s/xyz/map/' $cwd/i/tabl.i1 >! $UROF/tabl.i1
   endif
$UROX/uro.exe < $UROF/tabl.i1
rm -rf $UROF
"ENDOF e/scat"
#=======================================================================
echo i/dato.i3
   if(! -e ./i/dato.i3) then
cat >i/dato.i3 <<"ENDOF i/dato.i3"
job  +*+*+*+*+*+*+*+*+*
xyz-f-b 30.       model type
1000              nb. trans. to fit
0.                CoM cutoff
21                histogram
"ENDOF i/dato.i3"
   endif
#=======================================================================
   if(! -e ./e/maitre.scr) then
cp $VEDA/uro/maitre.scr e/maitre.scr
   endif
chmod +x e/* d/*.scr
"ENDOF setup"
#=======================================================================
echo uro.for
cat >uro.for <<"ENDOF uro.for"
# to recover individual items, csh this file
#=======================================================================
echo abra.f
cat >abra.f <<"ENDOF abra.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine abra(lu,ft,ss,nwds)
      implicit none
      integer i,ibid1,iecr,ilec,ios,iout,kprt,lgth,lsiz,lu,lungo,mul,n,
     & nlungo,nwds,nwdsm
      real idat,odat
      character cbid1*1,ft*1,fu*500,ss*1,st*7,tcar*80
      logical first,primo
      external lungo
      dimension idat(15),odat(15)
      common/dfftd/ ibid1(4),nwdsm
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      data first/.true./,nlungo/500/
      save fu,lgth,mul,primo
         if(first) then
      primo=.true.
       do n=1,nlungo
      fu(n:n)=' '
       enddo
      call getenv('UROF',fu)
      lgth=lungo(fu,nlungo)+1
      fu(lgth:lgth)='/'
      first=.false.
         endif
         if(ss.eq.'n') then
      st='new    '
         else if(ss.eq.'o') then
      st='old    '
         else if(ss.eq.'u') then
      st='unknown'
         else if(ss.eq.'s') then
      st='scratch'
         endif
         if(lu.lt.10) then
      write(tcar,'(a,i1,2x)') 'fort.',lu
         else if(lu.lt.100) then
      write(tcar,'(a,i2,1x)') 'fort.',lu
         else
      write(tcar,'(a,i3)') 'fort.',lu
         endif
      fu(lgth+1:lgth+8)=tcar(1:8)
         if(ft.eq.'f') then
      open(unit=lu,file=fu,form='formatted',status=st)
         else if(ft.eq.'u') then
      open(unit=lu,file=fu,form='unformatted',status=st)
         else if(ft.eq.'d') then
            if(primo) then
      nwdsm=1000000
       do i=1,15
      idat(i)=1000./i
      odat(i)=0.
       enddo
      do 20 mul=1,8
      lsiz=mul*15
      open(unit=lu,access='direct',recl=lsiz,status=st,iostat=ios)
      write(lu,rec=1,err=10) idat
      read(lu,rec=1,err=10) odat
       do i=1,15
      if(idat(i).ne.odat(i)) go to 10
       enddo
      go to 30
10    close(unit=lu,status='delete')
20    continue
      go to 901
30    close(unit=lu,status='delete')
      primo=.false.
            endif
      if(nwds.gt.0)
     . open(unit=lu,access='direct',recl=mul*nwds,status=st,iostat=ios)
         endif
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
3010  format('stop >> abra << cannot determine d-a record length')
      end
"ENDOF abra.f"
#=======================================================================
echo addsym.f
cat >addsym.f <<"ENDOF addsym.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program addsym
      implicit none
      integer bod,i,i1,i2,iecr,ilec,incs,ind,lungo,ncs,nlungo,o1
      real al,be,ga,tx,ty,tz
      character card*4000,lun*80,zn*1
      external lungo
      dimension incs(500)
      data nlungo/4000/
      ilec=5
      iecr=6
      i1=1
      i2=2
      o1=3
      zn='#'
      read(ilec,'(a)') card
      call compakt(card,nlungo)
       do i=1,80
      lun(i:i)=' '
       enddo
      ind=index(card,' ')
      lun=card(1:ind-1)
      open(unit=i1,file=lun,form='formatted',status='unknown')
       do i=1,ind
      card(i:i)=' '
       enddo
      call compakt(card,nlungo)
       do i=1,80
      lun(i:i)=' '
       enddo
      ind=index(card,' ')
      lun=card(1:ind-1)
      open(unit=i2,file=lun,form='formatted',status='unknown')
       do i=1,ind
      card(i:i)=' '
       enddo
      call compakt(card,nlungo)
       do i=1,80
      lun(i:i)=' '
       enddo
      ind=index(card,' ')
      lun=card(1:ind-1)
      open(unit=o1,file=lun,form='formatted',status='unknown')
10    read(i1,'(a)',end=20) card
      ind=index(card,'#')
      card(ind:ind)=' '
      read(card,*) bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      read(i2,'(a)',end=20) card
      ind=index(card,'#')
      card(ind:ind)=' '
      read(card,*) bod,al,be,ga,tx,ty,tz
      write(o1,*) zn,bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      go to 10
20    stop
      end
"ENDOF addsym.f"
#=======================================================================
echo amiga.f
cat >amiga.f <<"ENDOF amiga.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine amiga(mi,mr,mc,ma,ii,rr,cc,aa)
      implicit none
      integer iecr,ii,ilec,iout,kprt,ma,mc,mct,mi,mr,mrt,nd,nr
      real dtor,pi,rr,rtod,twopi
      complex cc
      character aa*4,card*80,forme*40,formr*40,zn*1
      dimension aa(ma),cc(mc),ii(mi),rr(mr)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      read(ilec,'(a)') card
         if(card(1:4).eq.'job ') then
      write(iecr,2010)
      call datndo
         else if(card(1:8).eq.'sorting ') then
      nd=1000
      nr=min(mi-nd,mr/2)
      call sortndo(nd,nr,ii(1),rr(1))
         else if(card(1:8).eq.'tabling ') then
c mi=max(nat+nats+nz,2*nd)
c mr=max(nx*ny+4*(nat+nats),2*mt)
c mc=nd
c ma=nat
c    nd      =100000
c    nat     =nb. atoms
c    nats    =nb. atoms per section
c    nx,ny,nz=cell divisions
c    nr      =nb. coefficients
c    mt      =dimension of interpolation array (h+2)*(2*k+1)*(2*l+1)
      mct=100000
      mrt=2*(mc-mct)
      call tablndo(mi,mrt,mct,ma,ii(1),cc(1+mct),cc(1),aa(1))
         else if(card(1:7).eq.'fiting ') then
c mi=nr*(1+neq)+nd
c mr=9*nr
c mc=nr+mt
c    nd      =1000(sorting)
c    nr      =max(nb. reflections,nd)
c    neq     =nb. equivalent positions
c    mt      =dimension of interpolation array (h+2)*(2*k+1)*(2*l+1)
      call fitndo(mi,mr,mc,ii(1),rr(1),cc(1))
         else if(card(1:4).eq.'oic ') then
      call oicndo(card)
         else
      go to 901
         endif
      return
901   write(iecr,3010)
      stop
2010  format(/' ****** URO package ******'/
     . ' *** c. alvarez-rua - j. borge -  j. navaza ***'/
     . ' *** fiting version: York 1999 (j. navaza) ***')
3010  format('stop >> amiga << wrong header in input cards')
      end
"ENDOF amiga.f"
#=======================================================================
echo assymu.f
cat >assymu.f <<"ENDOF assymu.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine assymu(h,k,l,phase,exts)
      implicit none
      integer h,hh,hm,ht,ibid1,iecr,iind,ilec,ind,iout,ir,it,k,kk,km,
     & kprt,kt,l,ll,lm,lt,mss,n,neq,nts
      real dtor,phase,phi,pi,pphi,pr,rtod,tss,tts,twopi
      character cbid1*1
      logical exts
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/paco3/ hm,km,lm,ibid1(4)
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      exts=.false.
       do it=1,nts
      pr=-mod(h*tts(1,it)+k*tts(2,it)+l*tts(3,it),1.)
      ir=mod(12+nint(12*pr),12)
      if(ir.ne.0) go to 20
       enddo
      call pac3(hm,km,lm,ind)
      call unpac3(ht,kt,lt,ind)
      if(ht.ne.hm.or.kt.ne.km.or.lt.ne.lm) go to 901
      phi=phase
      do 10 n=1,neq
      hh=h*mss(1,1,n)+k*mss(2,1,n)+l*mss(3,1,n)
      kk=h*mss(1,2,n)+k*mss(2,2,n)+l*mss(3,2,n)
      ll=h*mss(1,3,n)+k*mss(2,3,n)+l*mss(3,3,n)
      pr=-mod(h*tss(1,n)+k*tss(2,n)+l*tss(3,n),1.)
         if(hh.eq.h.and.kk.eq.k.and.ll.eq.l) then
      ir=mod(12+nint(12*pr),12)
      if(ir.ne.0) go to 20
         endif
      pphi=phi+twopi*pr
c pacote
         if(hh.lt.0.or.(hh.eq.0.and.(ll.gt.0.or.(ll.eq.0.and.kk.gt.0))))
     . then
      hh=-hh
      kk=-kk
      ll=-ll
      pphi=-pphi
         endif
      call pac3(hh,kk,ll,iind)
      call unpac3(ht,kt,lt,iind)
      if(ht.ne.hh.or.kt.ne.kk.or.lt.ne.ll) go to 901
      if(iind.ge.ind) go to 10
      ind=iind
      phase=pphi
10    continue
      call unpac3(h,k,l,ind)
      call unpac3(ht,kt,lt,ind)
      if(ht.ne.h.or.kt.ne.k.or.lt.ne.l) go to 901
      phase=mod(phase,twopi)
      return
20    if(kprt.ne.0) write(iecr,3001) h,k,l
      exts=.true.
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
3001  format(/' >> warning << systematic extinction found =',3i5)
3010  format('stop >> assymu << pack mismatch')
      end
"ENDOF assymu.f"
#=======================================================================
echo befac.f
cat >befac.f <<"ENDOF befac.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine befac(bfac,error)
      implicit none
      integer h,k,l,mx,my,mz,nx,ny,nz,sx,sy,sz
      real arg,bfac,error,gi,ox,oy,oz
      common/optima/ h,k,l,nx,ny,nz,gi(3,3)
      error=0.
       do sx=-1,1
      mx=sx*nx
        do sy=-1,1
      my=sy*ny
         do sz=-1,1
      mz=sz*nz
         if(sx.ne.0.or.sy.ne.0.or.sz.ne.0) then
      ox=gi(1,1)*mx+gi(1,2)*my+gi(1,3)*mz
      oy=gi(2,1)*mx+gi(2,2)*my+gi(2,3)*mz
      oz=gi(3,1)*mx+gi(3,2)*my+gi(3,3)*mz
      arg=bfac*(ox*(mx-2*h)+oy*(my-2*k)+oz*(mz-2*l))/4.
      error=error+exp(-arg)
         endif
         enddo
        enddo
       enddo
      return
      end
"ENDOF befac.f"
#=======================================================================
echo carndo.f
cat >carndo.f <<"ENDOF carndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine carndo(uat,uci,t1,t2,ump,mi,mr,ma,ii,rr,aa,fijo)
      implicit none
      integer ibid1,iecr,ii,ilec,iout,j1,j2,j3,k1,k2,k3,k4,k5,k6,k7,k8,
     & k9,kprt,ma,mat,mats,mi,mr,n1,n2,nx,ny,nz,t1,t2,uat,uci,ump
      real rr
      character aa*4,cbid1*1
      logical fijo
      dimension aa(ma),ii(mi),rr(mr)
      common/grid/ ibid1(3),nx,ny,nz
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      write(iecr,2010)
      call lgauss(uat)
      mat=ma
      call corin(uci,t1,mat,aa,rr(1),rr(1+3*mat),fijo)
      call dimcs(mi,mr,mat,mats)
      if(t2.eq.0) return
      n1=nx*ny+1
      n2=n1+4*mat
      j1=1
      j2=1+mat
      j3=1+mat+mats
      k1=1
      k2=n1
      k3=n1+mat
      k4=n1+2*mat
      k5=n1+3*mat
      k6=n2
      k7=n2+mats
      k8=n2+2*mats
      k9=n2+3*mats
      call cartax(t1,t2,ump,
     . mat,mats,nz,nx*ny,ii(j1),ii(j2),ii(j3),
     . rr(k1),rr(k2),rr(k3),rr(k4),rr(k5),rr(k6),rr(k7),rr(k8),rr(k9))
      return
2010  format(/' ****** s/r carndo ******')
      end
"ENDOF carndo.f"
#=======================================================================
echo cartax.f
cat >cartax.f <<"ENDOF cartax.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine cartax(i1,t1,o1,mat,mats,mz,nxy,tsave,ttsav,iatos,rho,
     & xsave,ysave,zsave,bsave,xxsav,yysav,zzsav,bbsav)
      implicit none
      integer i,i1,iatos,ibid1,iecr,ii,il,ilec,iout,iu,ix,ixl,ixu,iy,
     & iyl,iyu,iz,izl,izu,j,jj,jl,jtyp,ju,k,kk,kprt,l,mat,mats,mgaus,
     & mss,mz,n,nas,nat,nats,neq,ngaus,nort,nts,ntype,nx,nxy,ny,nz,o1,
     & t1,tsave,ttsav,zs
      real a,alpha,asg,ast,b,b1,bbsav,be,beta,biso,bsave,bsg,bst,c,ca,
     & cast,cb,cbst,cg,cgst,cst,dm,dtor,dx,dy,dz,elim,etab,fe,g11,g12,
     & g13,g22,g23,g33,gamma,gauss,pi,r,r1,r2,r3,r4,r5,recipx,recipy,rf,
     & rho,rmax,ro,rsq,rsqmax,rtod,rz,s,sa,sast,sb,sbst,sg,sgst,t,tss,
     & tts,twopi,vol,x,xc,xhi,xl,xlo,xmax,xmin,xp,xpp,xsave,xshift,xu,
     & xxsav,y,yc,yhi,yl,ylo,ymax,ymin,yp,ypp,ysave,yshift,yu,yysav,z,
     & zhi,zlo,zmax,zmin,zp,zpp,zsave,ztest,zzsav
      character atnam*4,card*80,cbid1*1,forml*80,keyid*4
      dimension bbsav(mats),be(5),bsave(mat),etab(514),fe(5),iatos(mz),
     & rho(nxy),tsave(mat),ttsav(mats),xsave(mat),xxsav(mats),
     & ysave(mat),yysav(mats),zsave(mat),zzsav(mats)
      common/angkte/ pi,twopi,dtor,rtod
      common/atype/ gauss(30,300),ngaus,ntype
      common/cell/ a,b,c,alpha,beta,gamma,ca,cb,cg,sa,sb,sg,ast,bst,cst,
     & cast,cbst,cgst,sast,sbst,sgst,vol
      common/ctype/ keyid(300)
      common/grid/ ibid1(3),nx,ny,nz
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ortm/ ro(3,3),rf(3,3),nort
      common/simt/ tss(3,48),tts(9),mss(3,3,48),neq,nts
      elim=10.
      mgaus=(ngaus+1)/2
      do 10 i=1,514
      etab(i)=exp(-elim*(i-1)/512.)
10    continue
      ixl=0
      ixu=nx-1
      iyl=0
      iyu=ny-1
      izl=0
      izu=nz-1
      xlo=real(ixl)/nx
      xhi=real(ixu)/nx
      ylo=real(iyl)/ny
      yhi=real(iyu)/ny
      zlo=real(izl)/nz
      zhi=real(izu)/nz
      g11=a*a
      g22=b*b
      g33=c*c
      g12=2.*a*b*cg
      g13=2.*a*c*cb
      g23=2.*b*c*ca
      l=0
      k=0
      rewind(unit=i1)
       do i=1,80
      forml(i:i)=' '
       enddo
20    read(i1,'(a)') card
      if(card(1:6).ne.'FORMAT') go to 20
      forml(1:74)=card(7:80)
      rmax=0.
30    read(i1,fmt=forml,end=100) atnam,xp,yp,zp,biso
      do 40 i=1,ntype
      if(atnam.eq.keyid(i)) go to 50
40    continue
      go to 901
50    jtyp=i
      r=sqrt(elim*(biso+gauss(2,jtyp)))/twopi
      if(r.gt.rmax) rmax=r
      l=l+1
      xmin=xlo-r*ast
      xmax=xhi+r*ast
      ymin=ylo-r*bst
      ymax=yhi+r*bst
      zmin=zlo-r*cst
      zmax=zhi+r*cst
      x=rf(1,1)*xp+rf(1,2)*yp+rf(1,3)*zp
      y=rf(2,1)*xp+rf(2,2)*yp+rf(2,3)*zp
      z=rf(3,1)*xp+rf(3,2)*yp+rf(3,3)*zp
      do 90 n=1,neq
      xp=mss(1,1,n)*x+mss(1,2,n)*y+mss(1,3,n)*z+tss(1,n)
      yp=mss(2,1,n)*x+mss(2,2,n)*y+mss(2,3,n)*z+tss(2,n)
      zp=mss(3,1,n)*x+mss(3,2,n)*y+mss(3,3,n)*z+tss(3,n)
      xp=mod(xp,1.)
      yp=mod(yp,1.)
      zp=mod(zp,1.)
      if(xp.lt.0.) xp=xp+1.
      if(yp.lt.0.) yp=yp+1.
      if(zp.lt.0.) zp=zp+1.
      zpp=zp-1.
      do 80 iz=1,3
         if(zpp.lt.zmin.or.zpp.gt.zmax) then
      zpp=zpp+1.
      go to 80
         endif
      ypp=yp-1.
      do 70 iy=1,3
         if(ypp.lt.ymin.or.ypp.gt.ymax) then
      ypp=ypp+1.
      go to 70
         endif
      xpp=xp-1.
      do 60 ix=1,3
         if(xpp.lt.xmin.or.xpp.gt.xmax) then
      xpp=xpp+1.
      go to 60
         endif
      k=k+1
      if(k.gt.mat) go to 902
      xsave(k)=xpp
      ysave(k)=ypp
      zsave(k)=zpp
      bsave(k)=biso
      tsave(k)=jtyp
      xpp=xpp+1.
60    continue
      ypp=ypp+1.
70    continue
      zpp=zpp+1.
80    continue
90    continue
      go to 30
100   nat=k
      if(kprt.ne.0) write(iecr,2040) l,nat,rmax
      call sort5(nat,zsave,xsave,ysave,bsave,tsave)
      rewind(unit=t1)
      ztest=rmax*cst
      nats=0
      do 150 iz=1,nz
      l=0
      nas=0
      z=(izl+iz-1.)/nz
110   l=l+1
      if(l.gt.nat) go to 140
      dz=abs(z-zsave(l))
      if(dz.ge.ztest) go to 110
120   if(dz.ge.ztest) go to 140
      jtyp=tsave(l)
      biso=bsave(l)
      r=sqrt(elim*(biso+gauss(2,jtyp)))/twopi
      if(dz/cst.gt.r) go to 130
      nas=nas+1
      if(nas.gt.mats) go to 903
      xxsav(nas)=xsave(l)
      yysav(nas)=ysave(l)
      zzsav(nas)=zsave(l)
      bbsav(nas)=bsave(l)
      ttsav(nas)=tsave(l)
130   l=l+1
      if(l.gt.nat) go to 140
      dz=abs(z-zsave(l))
      go to 120
140   iatos(iz)=nas
      if(nas.ne.0) write(t1) (xxsav(i),i=1,nas),(yysav(i),i=1,nas),
     . (zzsav(i),i=1,nas),(bbsav(i),i=1,nas),(ttsav(i),i=1,nas)
      if(nas.gt.nats) nats=nas
150   continue
      if(kprt.ne.0) write(iecr,2050) nats
      recipx=1./nx
      recipy=1./ny
      asg=a*sg
      bsg=b*sg
      xshift=ast*cbst/cst
      yshift=bst*cast/cst
      rewind(unit=t1)
      do 240 iz=1,nz
      z=(izl+iz-1.)/nz
      do 160 i=1,nxy
      rho(i)=0.
160   continue
      nas=iatos(iz)
      if(nas.eq.0) go to 230
      read(t1) (xxsav(i),i=1,nas),(yysav(i),i=1,nas),(zzsav(i),i=1,nas),
     . (bbsav(i),i=1,nas),(ttsav(i),i=1,nas)
      do 220 i=1,nas
      x=xxsav(i)
      y=yysav(i)
      dz=zzsav(i)
      dz=z-dz
      jtyp=ttsav(i)
      r=bbsav(i)
      do 170 ii=1,mgaus
      b1=2.*twopi/(gauss(2*ii,jtyp)+r)
      fe(ii)=gauss(2*ii-1,jtyp)*b1*sqrt(b1)
      be(ii)=512.*b1*pi/elim
170   continue
      rsqmax=512./be(1)
      rz=sqrt(abs(rsqmax-(dz/cst)**2))
      xc=x+xshift*dz
      dx=rz/asg
      xl=nx*(xc-dx)
      il=xl
      if(xl.gt.0.) il=il+1
      xu=nx*(xc+dx)
      iu=xu
      if(xu.lt.0.) iu=iu-1
      il=max(il,ixl)
      iu=min(iu,ixu)
      if(il.gt.iu) go to 220
      yc=y+yshift*dz
      dy=rz/bsg
      yl=ny*(yc-dy)
      jl=yl
      if(yl.gt.0.) jl=jl+1
      yu=ny*(yc+dy)
      ju=yu
      if(yu.lt.0.) ju=ju-1
      jl=max(jl,iyl)
      ju=min(ju,iyu)
      if(jl.gt.ju) go to 220
      ix=iu-il+1
      iy=ju-jl+1
      jj=(jl-iyl)*nx+il-ixl+1
      r1=g33*dz**2
      r2=g13*dz
      r3=g23*dz
      dx=real(il)/nx-x
      dm=real(jl)/ny-y
      do 210 j=1,ix
      r4=(g11*dx+r2)*dx+r1
      r5=g12*dx+r3
      kk=jj
      dy=dm
      do 200 k=1,iy
      rsq=(g22*dy+r5)*dy+r4
      if(rsq.ge.rsqmax) go to 190
      t=0.
      do 180 ii=1,mgaus
      s=be(ii)*rsq
      l=s
      if(l.le.512) t=t+fe(ii)*(etab(l+1)+(s-l)*(etab(l+2)-etab(l+1)))
180   continue
      rho(kk)=rho(kk)+t
190   dy=dy+recipy
      kk=kk+nx
200   continue
      dx=dx+recipx
      jj=jj+1
210   continue
220   continue
230   zs=izl+iz-1
      call pzc(o1,nx,ny,nz,zs,rho(1))
240   continue
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
902   write(iecr,3020)
      write(iout,3020)
      stop
903   write(iecr,3030)
      write(iout,3030)
      stop
2040  format(/i10,' atoms in input list.',i10,' atoms in model volume'/
     . ' max. atomic radius =',f10.3)
2050  format(' max. atoms per section =',i10)
3010  format('stop >> cartax << form factor not available')
3020  format('stop >> cartax << max. nb. of atoms exceeded')
3030  format('stop >> cartax << max. nb. of atoms per section exceeded')
      end
"ENDOF cartax.f"
#=======================================================================
echo celda.f
cat >celda.f <<"ENDOF celda.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine celda
      implicit none
      integer iecr,ilec,iout,kprt
      real a,a11,a21,a22,a31,a32,a33,alpha,ast,b,beta,bst,c,ca,cast,cb,
     & cbst,cg,cgst,cst,dtor,gamma,pi,r,rtod,sa,sast,sb,sbst,sg,sgst,
     & twopi,vol
      character cbid1*1
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,ca,cb,cg,sa,sb,sg,ast,bst,cst,
     & cast,cbst,cgst,sast,sbst,sgst,vol
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/star/ a11,a21,a22,a31,a32,a33
      r=alpha*dtor
      ca=cos(r)
      sa=sin(r)
      r=beta*dtor
      cb=cos(r)
      sb=sin(r)
      r=gamma*dtor
      cg=cos(r)
      sg=sin(r)
      vol=a*b*c*sqrt(1.+2.*ca*cb*cg-ca*ca-cb*cb-cg*cg)
      cast=(cb*cg-ca)/(sb*sg)
      cbst=(cg*ca-cb)/(sg*sa)
      cgst=(ca*cb-cg)/(sa*sb)
      sast=sqrt(1.-cast*cast)
      sbst=sqrt(1.-cbst*cbst)
      sgst=sqrt(1.-cgst*cgst)
      ast=1/(a*sb*sgst)
      bst=1/(b*sg*sast)
      cst=1/(c*sa*sbst)
      a11=ast*sbst*sg
      a21=-ast*sbst*cg
      a22=bst*sast
      a31=ast*cbst
      a32=bst*cast
      a33=cst
      if(kprt.ne.0) write(iecr,2010) a,b,c,alpha,beta,gamma,vol
      return
2010  format(/' cell parameters =',6f10.3/' volume =',e15.5)
      end
"ENDOF celda.f"
#=======================================================================
echo choler.f
cat >choler.f <<"ENDOF choler.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine choler(n,rmat,rv,ksis,kinv,pivot)
      implicit none
      integer i,iecr,ilec,im1,iout,ip1,j,jm1,k,kinv,kprt,ksis,l,n
      real pivot,rmat,rv,x,xmin,y,zr
      character cbid1*1
      dimension rmat(n,n),rv(n)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
cjn uninitialized values
      data y/0./
      xmin=rmat(1,1)
      do 50 i=1,n
      im1=i-1
      do 40 j=i,n
      zr=-rmat(i,j)
      if(im1.eq.0) go to 20
      do 10 k=1,im1
      zr=zr+rmat(k,i)*rmat(k,j)
10    continue
20    x=-zr
      if(j.gt.i) go to 30
      if(x+pivot.le.0.) go to 901
      y=sqrt(x+pivot)
      rmat(i,i)=y
      if(x.lt.xmin) xmin=x
      go to 40
30    rmat(i,j)=x/y
40    continue
50    continue
      if(ksis.eq.0) go to 120
      do 80 j=1,n
      jm1=j-1
      zr=-rv(j)
      if(jm1.eq.0) go to 70
      do 60 i=1,jm1
      zr=zr+rmat(i,j)*rv(i)
60    continue
70    rv(j)=-zr/rmat(j,j)
80    continue
      do 110 l=1,n
      i=n-l+1
      ip1=i+1
      zr=-rv(i)
      if(n.eq.i) go to 100
      do 90 j=ip1,n
      zr=zr+rmat(i,j)*rv(j)
90    continue
100   rv(i)=-zr/rmat(i,i)
110   continue
120   if(kinv.eq.0) go to 200
      do 160 i=1,n
      do 150 j=i,n
      if(j.gt.i) go to 130
      rmat(i,i)=1/rmat(i,i)
      go to 150
130   zr=0.
      jm1=j-1
      do 140 k=i,jm1
      zr=zr+rmat(i,k)*rmat(k,j)
140   continue
      rmat(i,j)=-zr/rmat(j,j)
150   continue
160   continue
      do 190 i=1,n
      do 180 j=i,n
      zr=0.
      do 170 k=j,n
      zr=zr+rmat(i,k)*rmat(j,k)
170   continue
      rmat(i,j)=zr
      rmat(j,i)=rmat(i,j)
180   continue
190   continue
200   return
901   write(iecr,3010) x
      write(iout,3010) x
      stop
3010  format('stop >> choler << non-positive matrix. x =',e15.5)
      end
"ENDOF choler.f"
#=======================================================================
echo cierre.f
cat >cierre.f <<"ENDOF cierre.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine cierre(lu,ft)
      implicit none
      integer lu
      character ft*1
         if(ft.eq.'d') then
      close(unit=lu,status='delete')
         else
      close(unit=lu)
         endif
      return
      end
"ENDOF cierre.f"
#=======================================================================
echo cmplft.f
cat >cmplft.f <<"ENDOF cmplft.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine cmplft(n,dim,x,y)
      implicit none
      integer dim,factor,n,pmax,psym,sym,twogrp,unsym
      real x,y
      dimension dim(*),factor(15),sym(15),unsym(15),x(*),y(*)
      pmax=5
      twogrp=8
      if(n.le.1) return
      call srfp(n,pmax,twogrp,factor,psym,sym,unsym)
      call mdftkd(x,y,n,dim,factor)
      call diprp(x,y,n,dim,psym,sym,unsym)
      return
      end
"ENDOF cmplft.f"
#=======================================================================
echo compact.f
cat >compact.f <<"ENDOF compact.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine compact(card)
      implicit none
      integer i,j,length
      character card*80
      logical blanco,white
      external length
      blanco=card(1:1).eq.' '
      j=0
      do 10 i=1,length(card)
      white=card(i:i).eq.' '
      if(white.and.blanco) go to 10
         if(white) then
      blanco=.true.
         else
      blanco=.false.
         endif
      j=j+1
      card(j:j)=card(i:i)
10    continue
       do i=j+1,length(card)
      card(i:i)=' '
       enddo
      return
      end
"ENDOF compact.f"
#=======================================================================
echo compakt.f
cat >compakt.f <<"ENDOF compakt.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine compakt(card,nfield)
      implicit none
      integer i,j,lungo,nfield
      character card*1
      logical blanco,white
      external lungo
      dimension card(nfield)
      blanco=card(1).eq.' '
      j=0
       do i=1,lungo(card,nfield)
      white=card(i).eq.' '
         if((.not.white).or.(.not.blanco)) then
            if(white) then
      blanco=.true.
            else
      blanco=.false.
            endif
      j=j+1
      card(j)=card(i)
         endif
       enddo
       do i=j+1,lungo(card,nfield)
      card(i)=' '
       enddo
      return
      end
"ENDOF compakt.f"
#=======================================================================
echo contrg.f
cat >contrg.f <<"ENDOF contrg.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine contrg(na,ia)
      implicit none
      integer i,ia,iba,ibid1,inta,j,maxs,mcd,mdiv,mi,mini,mp1,n,na,nba,
     & ndiv,neq,nts,p1
      real cen,tss,tts
      parameter(mp1=154,maxs=400)
      dimension cen(4),iba(5),inta(48),p1(mp1)
      common/simt/ tss(3,48),tts(3,3),ibid1(432),neq,nts
      data p1/
     &  14,  22,  26,  28,  34,  38,  42,  44,  46,  52,
     &  56,  58,  62,  66,  68,  70,  74,  76,  78,  82,
     &  84,  86,  88,  92,  94,  98, 102, 104, 106, 110,
     & 112, 114, 116, 118, 122, 124, 126, 130, 132, 134,
     & 136, 138, 140, 142, 146, 148, 152, 154, 156, 158,
     & 164, 166, 168, 170, 172, 174, 176, 178, 182, 184,
     & 186, 188, 190, 194, 196, 198, 202, 204, 206, 208,
     & 210, 212, 214, 218, 220, 222, 224, 226, 228, 230,
     & 232, 234, 236, 238, 242, 244, 246, 248, 252, 254,
     & 258, 260, 262, 264, 266, 268, 272, 274, 276, 278,
     & 280, 282, 284, 286, 290, 292, 294, 296, 298, 302,
     & 304, 306, 308, 310, 312, 314, 316, 318, 322, 326,
     & 328, 330, 332, 334, 336, 338, 340, 342, 344, 346,
     & 348, 350, 352, 354, 356, 358, 362, 364, 366, 368,
     & 370, 372, 374, 376, 378, 380, 382, 386, 388, 390,
     & 392, 394, 396, 398/,
     & iba/6,4,3,2,1/,nba/5/
      cen(1)=0.
       do j=1,nts
      cen(j+1)=tts(ia,j)
       enddo
      mi=0
       do j=1,nts+1
      do 20 n=1,neq
      mini=nint(12.*mod(tss(ia,n)+cen(j)+9.,1.))
         if(mini.ne.0) then
            if(mi.eq.0) then
      mi=mi+1
      inta(mi)=mini
            endif
      do 10 i=1,mi
      if(inta(i).eq.mini) go to 20
10    continue
      mi=mi+1
      inta(mi)=mini
         endif
20    continue
       enddo
      mcd=1
      if(mi.eq.0) go to 50
      do 40 j=1,nba
      mcd=iba(j)
      do 30 i=1,mi
      if((inta(i)/mcd)*mcd.ne.inta(i)) go to 40
30    continue
      mcd=12/mcd
      go to 50
40    continue
50    if((mcd/2)*2.ne.mcd) mcd=mcd*2
      ndiv=max(mcd,2)
      mdiv=0
60       if(na.gt.maxs) then
      na=na/ndiv
      mdiv=mdiv+1
      go to 60
         endif
      na=((na+mcd-1)/mcd)*mcd
      do 70 i=1,mp1
         if(na.eq.p1(i)) then
      na=na+mcd
      go to 60
         endif
70    continue
      if(mdiv.ne.0) na=na*ndiv**mdiv
      return
      end
"ENDOF contrg.f"
#=======================================================================
echo control.f
cat >control.f <<"ENDOF control.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine control(n)
      implicit none
      integer i,maxs,mcd,mp1,n,ndiv,p1
      parameter(mp1=266,maxs=1000)
      dimension p1(mp1)
      data p1/
     &  46,  58,  62,  74,  82,  86,  92,  94, 106, 116, 118, 122,
     & 124, 134, 138, 142, 146, 148, 158, 164, 166, 172, 174, 178,
     & 184, 186, 188, 194, 202, 206, 212, 214, 218, 222, 226, 230,
     & 232, 236, 244, 246, 248, 254, 258, 262, 268, 274, 276, 278,
     & 282, 284, 290, 292, 296, 298, 302, 310, 314, 316, 318, 322,
     & 326, 328, 332, 334, 344, 346, 348, 354, 356, 358, 362, 366,
     & 368, 370, 372, 376, 382, 386, 388, 394, 398, 402, 404, 406,
     & 410, 412, 414, 422, 424, 426, 428, 430, 434, 436, 438, 444,
     & 446, 452, 454, 458, 460, 464, 466, 470, 472, 474, 478, 482,
     & 488, 492, 496, 498, 502, 506, 508, 514, 516, 518, 522, 524,
     & 526, 530, 534, 536, 538, 542, 548, 552, 554, 556, 558, 562,
     & 564, 566, 568, 574, 580, 582, 584, 586, 590, 592, 596, 598,
     & 602, 604, 606, 610, 614, 618, 620, 622, 626, 628, 632, 634,
     & 636, 638, 642, 644, 652, 654, 656, 658, 662, 664, 666, 668,
     & 670, 674, 678, 682, 688, 690, 692, 694, 696, 698, 706, 708,
     & 710, 712, 716, 718, 724, 730, 732, 734, 736, 738, 740, 742,
     & 744, 746, 752, 754, 758, 762, 764, 766, 772, 774, 776, 778,
     & 782, 786, 788, 790, 794, 796, 804, 806, 808, 812, 814, 820,
     & 822, 824, 826, 828, 830, 834, 844, 846, 848, 852, 854, 856,
     & 860, 868, 870, 872, 874, 876, 888, 890, 892, 894, 902, 904,
     & 906, 908, 916, 920, 928, 930, 932, 938, 940, 942, 944, 946,
     & 948, 954, 956, 962, 964, 966, 970, 976, 978, 984, 986, 992,
     & 994, 996/
      mcd=2
      n=(n/mcd)*mcd
      ndiv=0
10       if(n.gt.maxs) then
      n=n/mcd
      ndiv=ndiv+1
      go to 10
         endif
      n=(n/mcd)*mcd
20    continue
       do i=1,mp1
         if(n.eq.p1(i)) then
      n=n-mcd
      go to 20
         endif
       enddo
      if(ndiv.ne.0) n=n*mcd**ndiv
      return
      end
"ENDOF control.f"
#=======================================================================
echo cordin.f
cat >cordin.f <<"ENDOF cordin.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine cordin(i1,ma,axyz,cxyz,na)
      implicit none
      integer i,i1,iecr,ilec,iout,kprt,ma,na
      real biso,cxyz,xi
      character atnam*4,axyz*4,cbid1*1
      logical first,last
      dimension axyz(ma),cxyz(3,ma),xi(3)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      first=.true.
      last=.false.
      na=0
10    call lecatc(i1,atnam,xi,biso,first,last)
      if(last) go to 20
      na=na+1
      if(na.gt.ma) go to 901
      axyz(na)=atnam
       do i=1,3
      cxyz(i,na)=xi(i)
       enddo
      go to 10
20    return
901   write(iecr,3010)
      stop
3010  format('stop >> cordin << increase ma')
      end
"ENDOF cordin.f"
#=======================================================================
echo cords.f
cat >cords.f <<"ENDOF cords.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program cords
      implicit none
      integer i,i1,i2,iecr,ilec,iout,j,kprt,length,na
      real al,be,com,dtor,ga,pi,rmx,rtod,trx,twopi,xi,xo
      character card*80,cbid1*1,forme*80,forml*80,inv*1,lun*80,mas*1
      external length
      dimension com(3),rmx(3,3),trx(3),xi(3),xo(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      data i1,i2/98,99/
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      kprt=1
       do i=1,80
      forml(i:i)=' '
      forme(i:i)=' '
       enddo
      forml(1:11)='(30x,3f8.3)'
      forme(1:7)='(3f8.3)'
       do i=1,3
      com(i)=0.
       enddo
10    write(iecr,'(a)') ' enter the input-coord filename'
      read(ilec,'(a)',end=60) lun
      if(length(lun).eq.0) go to 80
      open(unit=i1,file=lun,form='formatted',status='old')
      na=0
       do i=1,3
      com(i)=0.
       enddo
20    read(i1,'(a)',end=30) card
      if(card(1:4).ne.'ATOM') go to 20
      na=na+1
      read(card,fmt=forml) xi
       do i=1,3
      com(i)=com(i)+xi(i)
       enddo
      go to 20
30     do i=1,3
      com(i)=com(i)/na
       enddo
      write(iecr,'(a)') ' enter the output-coord filename'
      read(ilec,'(a)') lun
      open(unit=i2,file=lun,form='formatted',status='new')
      write(iecr,'(a)') ' rotation in the center-of-mass [N/y]'
      read(ilec,'(a)') mas
      if(length(mas).eq.0) mas='n'
      write(iecr,'(a)') ' enter rotation and translation'
      read(ilec,*) al,be,ga,trx
      write(iecr,'(a)') ' inversion [N/y]'
      read(ilec,'(a)') inv
      if(length(inv).eq.0) inv='n'
      call rmxe(al,be,ga,rmx)
         if(inv.eq.'y') then
       do i=1,3
        do j=1,3
      rmx(i,j)=-rmx(i,j)
        enddo
       enddo
         endif
      write(iecr,'(/a,3(/3f15.5))') ' matrix M',((rmx(i,j),j=1,3),i=1,3)
      write(iecr,'(/a/3f15.3)') ' translation T',(trx(i),i=1,3)
         if(mas.eq.'y') then
       do i=1,3
      trx(i)=trx(i)+com(i)
       enddo
         endif
      rewind(unit=i1)
40    read(i1,'(a)') card
         if(card(1:4).ne.'ATOM') then
      write(i2,'(a)') card
      go to 40
         endif
      go to 60
50    read(i1,'(a)',end=70) card
60    if(card(1:4).ne.'ATOM') go to 50
      read(card,fmt=forml) xi
         if(mas.eq.'y') then
       do i=1,3
      xi(i)=xi(i)-com(i)
       enddo
         endif
       do i=1,3
      xo(i)=0.
        do j=1,3
      xo(i)=xo(i)+rmx(i,j)*xi(j)
        enddo
      xo(i)=xo(i)+trx(i)
       enddo
      write(card(31:54),fmt=forme) xo
      write(i2,'(a)') card
      go to 50
70    close(unit=i1)
      close(unit=i2)
      go to 10
80    stop
      end
"ENDOF cords.f"
#=======================================================================
echo corin.f
cat >corin.f <<"ENDOF corin.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine corin(i1,o1,mat,cxyz,axyz,bxyz,fijo)
      implicit none
      integer i,i1,ibid1,ibid2,iecr,ierr,ilec,iout,ixlw,ixup,j,kfac,
     & kiso,kprt,kprtp,mat,mss,n,nat,nc,neq,ngaus,ngrid,nort,nts,ntype,
     & nxyz,o1
      real a,al,alpha,axyz,b,be,beta,bfac,biso,blunt,bmax,bmin,box,boxm,
     & btiso,bxyz,c,cel,cm,det,dmax,dmin,dsmax,dsmin,dtor,elim,ga,gamma,
     & gauss,pi,qm,r,rbid1,rbid2,rbid3,rbid4,rf,rmax,rmin,ro,rot,rota,
     & rr,rtod,sharat,t,t1,t2,t3,tra,tss,tts,twopi,val,ver,xhi,xi,xlow,
     & xo,xsup
      character carat*4,cbid1*1,cxyz*4,keyid*4
      logical fijo,first,last
      dimension axyz(mat,3),bxyz(mat),cel(3),cxyz(mat),ngrid(3),qm(3,3),
     & rot(3,3),rota(3,3),rr(18),tra(3),ver(3),xi(3),xo(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/atype/ gauss(30,300),ngaus,ntype
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ctype/ keyid(300)
      common/dfftx/ xlow(3),xsup(3),ixlw(3),ixup(3)
      common/fozo/ rbid2(2),bfac,ibid1
      common/histo/ nc
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ortm/ ro(3,3),rf(3,3),nort
      common/outab/ boxm(3),rmin,cm(3),al,be,ga,val(6),rbid3,nat,ibid2
      common/reso/ dmax,dmin,rbid4(2),dsmin,dsmax
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      elim=10.
      first=.true.
      last=.false.
      do 20 i=1,3
      tss(i,1)=0.
      cm(i)=0.
      xlow(i)=1.e20
      xsup(i)=-1.e20
      do 10 j=1,3
      mss(i,j,1)=0
      qm(i,j)=0.
10    continue
20    continue
      read(ilec,*) kiso,btiso
      bmin=1.e20
      bmax=-1.e20
      nat=0
30    if(nat.gt.mat) go to 901
      call lecatc(i1,carat,xi,biso,first,last)
      if(last) go to 80
      do 40 i=1,ntype
      if(carat.eq.keyid(i)) go to 50
40    continue
      go to 902
50    nat=nat+1
      if(kiso.ne.0) biso=btiso
      if(biso.lt.bmin) bmin=biso
      if(biso+gauss(2,i).gt.bmax) bmax=biso+gauss(2,i)
      cxyz(nat)=carat
      axyz(nat,1)=xi(1)
      axyz(nat,2)=xi(2)
      axyz(nat,3)=xi(3)
      bxyz(nat)=biso
      do 70 i=1,3
      cm(i)=cm(i)+xi(i)
      do 60 j=1,3
      qm(i,j)=qm(i,j)+xi(i)*xi(j)
60    continue
70    continue
      go to 30
80    if(nat.eq.0) go to 903
      do 90 i=1,3
      cm(i)=cm(i)/nat
90    continue
      do 110 i=1,3
      do 100 j=1,3
      qm(i,j)=qm(i,j)/nat-cm(i)*cm(j)
100   continue
110   continue
      call rs(3,3,qm,val,rota,rr(1),rr(10),1,ierr)
      t=val(1)
      val(1)=val(3)
      val(3)=t
      call det3(rota,det)
      t=-sign(1.,det)
      do 130 i=1,3
      ver(i)=0.
      do 120 j=1,3
      ver(i)=ver(i)+(axyz(1,j)-cm(j))*rota(j,i)
120   continue
130   continue
      t1=sign(1.,ver(1))
      t2=sign(1.,ver(2))
      t3=sign(1.,ver(3))
      t1=t*t2*t3
      do 140 i=1,3
      rot(i,1)=rota(i,3)*t3
      rot(i,2)=rota(i,2)*t2
      rot(i,3)=rota(i,1)*t1
140   continue
      if(kprt.ne.0) write(iecr,2010) nat,cm,(val(i),i=1,3)
      kprtp=kprt
      kprt=0
      call rmx2e(rot,al,be,ga)
      call rmxe(180-ga,be,180-al,rota)
      kprt=kprtp
      call rmx2e(rota,al,be,ga)
      call rmx2p(rota,xhi,ver)
      val(4)=0.
      val(5)=0.
      val(6)=0.
         if(fijo) then
      al=0.
      be=0.
      ga=0.
      kprt=0
      call rmxe(al,be,ga,rota)
      kprt=kprtp
      val(1)=qm(1,1)
      val(2)=qm(2,2)
      val(3)=qm(3,3)
      val(4)=qm(1,2)
      val(5)=qm(1,3)
      val(6)=qm(2,3)
         endif
      do 170 n=1,nat
      xi(1)=axyz(n,1)-cm(1)
      xi(2)=axyz(n,2)-cm(2)
      xi(3)=axyz(n,3)-cm(3)
      do 160 i=1,3
      xo(i)=0.
      do 150 j=1,3
      xo(i)=xo(i)+rota(i,j)*xi(j)
150   continue
      if(xo(i).lt.xlow(i)) xlow(i)=xo(i)
      if(xo(i).gt.xsup(i)) xsup(i)=xo(i)
160   continue
170   continue
      rmax=sqrt(elim*bmax)/twopi
      do 180 i=1,3
      mss(i,i,1)=1
      xi(i)=0.5
      xlow(i)=xlow(i)-rmax
      xsup(i)=xsup(i)+rmax
      boxm(i)=xsup(i)-xlow(i)
180   continue
      neq=1
      nts=0
      nort=1
       do i=1,3
      tss(i,1)=0.
      tts(i,1)=0.
       enddo
      read(ilec,*) dmax,dmin,nc
      read(ilec,*) box,sharat,kfac,bfac
      if(sharat.lt.1.) sharat=1.
      dsmin=dmin/sharat
      kprt=0
190    do i=1,3
      cel(i)=boxm(i)*box
      ngrid(i)=2.*(boxm(i)/dsmin+1.)
      nxyz=2.*(cel(i)/dsmin+1.)
      call contrg(nxyz,i)
      cel(i)=nxyz*boxm(i)/ngrid(i)
       enddo
      a=cel(1)
      b=cel(2)
      c=cel(3)
      alpha=90.
      beta=90.
      gamma=90.
      call celda
      call setpak
      call ortho
      call optimo(dsmin,sharat,blunt)
      blunt=blunt-bmin
         if(kfac.eq.0) then
      bfac=blunt
         else
      write(iecr,3001) blunt
         endif
         if(bfac.gt.0.) then
      rmax=sqrt(elim*bfac)/twopi
         else
      rmax=0.
         endif
       do i=1,3
         if(cel(i).le.boxm(i)+2.*rmax) then
      box=box+0.1
      go to 190
         endif
       enddo
      kprt=kprtp
       do i=1,3
      xlow(i)=xlow(i)-rmax
      xsup(i)=xsup(i)+rmax
       enddo
      call celda
      call setpak
      call ortho
      do 210 i=1,3
      tra(i)=0.
      do 200 j=1,3
      tra(i)=tra(i)+ro(i,j)*xi(j)
200   continue
210   continue
      write(iecr,2020)
      kprtp=kprt
      kprt=1
      call rmxe(al,be,ga,rota)
      kprt=kprtp
      rmin=0.
      rewind(unit=o1)
      write(o1,'(a)') 'FORMAT (a4,6x,4f10.3)'
      do 250 n=1,nat
      carat=cxyz(n)
      xi(1)=axyz(n,1)-cm(1)
      xi(2)=axyz(n,2)-cm(2)
      xi(3)=axyz(n,3)-cm(3)
      biso=bxyz(n)+bfac
      do 230 i=1,3
      xo(i)=0.
      do 220 j=1,3
      xo(i)=xo(i)+rota(i,j)*xi(j)
220   continue
      xo(i)=xo(i)+tra(i)
230   continue
      write(o1,'(a,6x,4f10.3)') carat,xo,biso
      r=0.
      do 240 i=1,3
      r=r+xi(i)**2
240   continue
      if(r.gt.rmin) rmin=r
250   continue
      mat=nat
      rmin=sqrt(rmin)
         if(kprt.ne.0) then
      write(iecr,2030) (boxm(i),i=1,3)
      write(iecr,2040) rmin
      if(kiso.ne.0) write(iecr,2050) btiso
      write(iecr,2060) bfac
         endif
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
902   write(iecr,3020) carat
      write(iout,3020) carat
      stop
903   write(iecr,3030)
      write(iout,3030)
      stop
2010  format(/' center of mass of the',i10,' input atoms =',3f10.3/
     . ' inertia axes of input coords. =',3e15.5)
2020  format(/' the c. of m. is first set to zero'/
     . ' the coordinates are rotated by =')
2030  format(' minimal rectangular box of output coordinates =',3f10.3)
2040  format(' max. distance from c. of m. =',f10.3)
2050  format(' temperature factors set to',f10.3)
2060  format(' temperature factors increased by',f10.3)
3001  format(/' >> warning << optimal values for shannon-rate and',
     . ' b-add are 2. and',f7.1)
3010  format('stop >> corin << max. nb. of atoms exceeded')
3020  format('stop >> corin << form factor not available =',a4)
3030  format('stop >> corin << no atom selected')
      end
"ENDOF corin.f"
#=======================================================================
echo datamf.f
cat >datamf.f <<"ENDOF datamf.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine datamf(i2,nd,mi,mr,mc,ii)
      implicit none
      integer h,hmax,i2,ibid1,iecr,ii,ilec,iout,k,kmax,kprt,l,lmax,mc,
     & mi,mr,nd,nx,ny,nz
      real a11,a21,a22,a31,a32,a33,bfac,demax,demin,drmin,dsq,rbid1,
     & rbid2,rbid3,sqh
      character cbid1*1
      dimension ii(*)
      common/fozo/ rbid1(2),bfac,ibid1
      common/grid/ hmax,kmax,lmax,nx,ny,nz
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/reso/ rbid2,drmin,demax,demin,rbid3(2)
      common/star/ a11,a21,a22,a31,a32,a33
      dsq=0.
      do 30 h=-1,1
      do 20 k=-1,1
      do 10 l=-1,1
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.dsq) dsq=sqh
10    continue
20    continue
30    continue
      drmin=1/(1/drmin+sqrt(dsq))
      bfac=-bfac
      call reffo(i2,nd,ii(1))
      call indexm(demin,hmax,kmax,lmax)
      call dimfs(nd,mi,mr,mc)
      if(kprt.ne.0) write(iecr,2010) nx,ny,nz,demin,hmax,kmax,lmax
      return
2010  format(/' z-section map'/
     . ' divisions of unit cell edges =',3i10/
     . ' data resolution =',f10.3/
     . ' maximal indices according to data resolution =',3i5)
      end
"ENDOF datamf.f"
#=======================================================================
echo datndo.f
cat >datndo.f <<"ENDOF datndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine datndo
      implicit none
      integer bref,i,id,iecr,ilec,inb,ine,inl,ins,iout,jd,kiso,kprt,
     & luhkl,lumap,luout,lutab,luudi,luxyz,nc,ncyc,nd,nh,nite,nort,numbf
      real biso,blunt,box,bsharp,cel,cutoff,dmax,dmin,dtor,pctrf,pi,
     & rmsr,rtod,seuild,sharat,t,twopi
      character card*80,cardd*80,cbid1*1,opcta*10,tcar*80
      parameter(nh=1000)
      dimension cardd(nh),cel(6),numbf(2)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
c logicalunit
      id=8
       do i=1,10
      opcta(i:i)=' '
       enddo
      call abra(id,'f','u',0)
      rewind(unit=id)
      jd=1
      read(id,'(a)') cardd(jd)
      jd=jd+1
      read(id,'(a)') cardd(jd)
      tcar=cardd(jd)
c lecturainterna
      read(tcar,*) cel
10    jd=jd+1
      read(id,'(a)') cardd(jd)
      ine=index(cardd(jd),'e')
      ins=index(cardd(jd),'s')
      if(ine.lt.1.and.ins.lt.1) go to 10
      nd=jd
      jd=jd+1
      read(id,'(a)') cardd(jd)
      tcar=cardd(jd)
c lecturainterna
      read(tcar,*) nort
      jd=jd+1
      read(id,'(a)') cardd(jd)
      tcar=cardd(jd)
c lecturainterna
      read(tcar,*) pctrf,bsharp
      jd=jd+1
      read(id,'(a)') cardd(jd)
      tcar=cardd(jd)
c lecturainterna
      read(tcar,*) dmax,dmin
         if(dmax.lt.dmin) then
      t=dmax
      dmax=dmin
      dmin=t
         endif
      read(ilec,'(a)') card
      inl=index(card,' ')
      opcta(1:inl)=card(1:inl)
      inb=index(card(1:inl),'b')
         if(inb.lt.1) then
      kiso=0
      biso=0.
         else
      kiso=1
      tcar(1:81-inl)=card(inl:80)
c lecturainterna
      read(tcar,*) biso
      opcta(inb-1:inl-2)=opcta(inb+1:inl)
      opcta(inl-1:inl-1)=' '
         endif
      read(ilec,*) numbf(1)
      read(ilec,*) seuild
      read(ilec,*) nc
c logicalunit
      luhkl=1
      luxyz=1
      lumap=2
      luout=9
      luudi=10
      lutab=10
      call cierre(id,'f')
      nite=50
      ncyc=0
      cutoff=0.
      rmsr=0.001
      bref=0
      iout=iout+1
      call abra(iout,'f','u',0)
      rewind(iout)
      write(iout,'(a)') 'oic fiting  +*+*+*+*+*+*+*+*+*'
      write(iout,'(a)') cardd(1)
      write(iout,'(f5.1,i10)') cutoff,numbf(1)
      write(iout,'(2f10.2,a)') dmax,dmin,' RESOLUTION'
      write(iout,'(2i5,f10.3,i5,a)') ncyc,nite,rmsr,bref,' CYCLES'
      write(iout,'(a,f10.1)') 'fuzz:',0.0
      write(iout,'(a,f10.1)') 'over:',seuild
      call cierre(iout,'f')
      iout=iout+1
      call abra(iout,'f','u',0)
      rewind(iout)
      write(iout,'(a)') 'sorting +*+*+*+*+*+*+*+*+*+*+*'
      write(iout,'(3i3,11x,a)') luhkl,luudi,luout,' :logical units'
       do i=1,nd
      write(iout,'(a)') cardd(i)
       enddo
      write(iout,'(i3)') nort
      write(iout,'(2f10.2,i5)') dmax,dmin,nc
      write(iout,'(f10.2)') 1.0
      call cierre(iout,'f')
      sharat=2.
      if(opcta(1:3).eq.'map') sharat=2.0
      box=4.
      blunt=0.
      iout=iout+1
      call abra(iout,'f','u',0)
      rewind(iout)
      write(iout,'(a)') 'tabling +*+*+*+*+*+*+*+*+*+*+*'
      write(iout,'(a)') '3    1 0 1           :printing'
      write(iout,'(4i3,8x,a)') luxyz,lumap,lutab,luout,' :logical units'
      write(iout,'(a)') ' molecular scattering factors'
      write(iout,'(a)') opcta
      write(iout,'(i5,f10.1)') kiso,biso
      write(iout,'(2f10.2,i5,a)') dmax,dmin,nc,' HISTO'
      write(iout,'(2f10.2,i5,f10.1)') box,sharat,0,blunt
      call cierre(iout,'f')
      return
      end
"ENDOF datndo.f"
#=======================================================================
echo det3.f
cat >det3.f <<"ENDOF det3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine det3(r,d)
      implicit none
      real a,b,d,r
      dimension r(3,3)
      a=r(1,1)*r(2,2)*r(3,3)+r(1,2)*r(2,3)*r(3,1)+r(3,2)*r(2,1)*r(1,3)
      b=r(1,3)*r(2,2)*r(3,1)+r(2,1)*r(1,2)*r(3,3)+r(2,3)*r(3,2)*r(1,1)
      d=a-b
      return
      end
"ENDOF det3.f"
#=======================================================================
echo dimcs.f
cat >dimcs.f <<"ENDOF dimcs.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine dimcs(mi,mr,mat,mats)
      implicit none
      integer i,ibid1,iecr,ilec,iout,ixlw,ixup,j,kprt,mac,mat,mats,mi,
     & mic,mr,mrc,ngrid,nort,nx,ny,nz
      real a,b,c,dsmax,dsmin,rbid1,rbid2,rf,ro,xlow,xlw,xsup,xup
      character cbid1*1
      dimension ngrid(3),xlw(3),xup(3)
      common/cell/ a,b,c,rbid1(19)
      common/dfftx/ xlow(3),xsup(3),ixlw(3),ixup(3)
      common/grid/ ibid1(3),nx,ny,nz
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ortm/ ro(3,3),rf(3,3),nort
      common/reso/ rbid2(4),dsmin,dsmax
      nx=2.*(a/dsmin+1.)
      ny=2.*(b/dsmin+1.)
      nz=2.*(c/dsmin+1.)
      call contrg(nx,1)
      call contrg(ny,2)
      call contrg(nz,3)
      ngrid(1)=nx
      ngrid(2)=ny
      ngrid(3)=nz
      do 20 i=1,3
      xlw(i)=0.
      xup(i)=0.
      do 10 j=1,3
      xlw(i)=xlw(i)+rf(i,j)*xlow(j)
      xup(i)=xup(i)+rf(i,j)*xsup(j)
10    continue
20    continue
      do 30 i=1,3
      ixlw(i)=nint(ngrid(i)*(xlw(i)+0.5))
      ixup(i)=nint(ngrid(i)*(xup(i)+0.5))
      if(ixlw(i).lt.0) ixlw(i)=0
      if(ixup(i).ge.ngrid(i)) ixup(i)=ngrid(i)-1
      ngrid(i)=ixup(i)-ixlw(i)+1
30    continue
      if(kprt.ne.0) write(iecr,2010) xlow,xsup,ngrid,dsmin,nx,ny,nz
      mats=min(mi-(mat+nz),(mr-nx*ny)/4-mat)
      if(mats.le.0) mats=mat
      mats=min(mats,mat)
      mic=mat+mats+nz
      mrc=nx*ny+4*(mat+mats)
      mac=mat
      if(kprt.ne.0) write(iecr,2020) mic,mrc,mac
      if(mic.gt.mi.or.mrc.gt.mr) go to 901
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
2010  format(/' model electron density box'/
     . ' lower limits =',3f10.3/' upper limits =',3f10.3/
     . ' sampling of model box edges =',3i10/
     . ' grid resolution =',f10.3/
     . ' divisions of unit cell edges =',3i10)
2020  format(/' dimensions for cartax'/
     . ' (integer)          mi =',i10/
     . ' (real)             mr =',i10/
     . ' (character*4)      ma =',i10)
3010  format('stop >> dimcs << insufficient memory for cartax')
      end
"ENDOF dimcs.f"
#=======================================================================
echo dimfs.f
cat >dimfs.f <<"ENDOF dimfs.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine dimfs(nd,mi,mr,mc)
      implicit none
      integer hlw,hmax,hup,iecr,ilec,iout,klw,kmax,kprt,kup,llw,lmax,
     & lup,mc,mcc,mi,mic,mr,mrc,mxy,my,nd,nh,nk,nra,nwds,nwdsm,nx,nxyz,
     & ny,nz,ph,pz,td,xlw,xup,ylw,yup,zlw,zup
      real rbid1
      character cbid1*1
      common/dfft/ hlw,hup,klw,kup,llw,lup,nra,nxyz
      common/dfftd/ ph,pz,td,nwds,nwdsm
      common/dfftx/ rbid1(6),xlw,ylw,zlw,xup,yup,zup
      common/grid/ hmax,kmax,lmax,nx,ny,nz
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      if(nx.lt.2*(hmax+1).or.ny.lt.2*(kmax+1).or.nz.lt.2*(lmax+1))
     . go to 901
      nxyz=nx*ny*nz
      nh=hup-hlw+1
      nk=kup-klw+1
      my=yup-ylw+1
      nra=nd
      call diraxh(mr)
      mic=2*nd
      mxy=max(nx*my,2*nh*ny)
      mrc=max(mxy*pz,2*ph*nk*nz)
      mcc=nd
      if(kprt.ne.0) write(iecr,2010) mic,mrc,mcc
      if(mic.gt.mi.or.mrc.gt.mr.or.mcc.gt.mc) go to 902
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
902   write(iecr,3020)
      write(iout,3020)
      stop
2010  format(/' dimensions for stfndo'/
     . ' (integer)          mi =',i10/
     . ' (real)             mr =',i10/
     . ' (complex)          mc =',i10)
3010  format('stop >> dimfs << spacing and resolution mismatch')
3020  format('stop >> dimfs << insufficient memory for stfndo')
      end
"ENDOF dimfs.f"
#=======================================================================
echo diprp.f
cat >diprp.f <<"ENDOF diprp.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine diprp(x,y,np,dim,psym,sym,unsym)
      implicit none
      integer a,al,b,bl,bs,c,cl,cs,d,d1,d2,d3,d4,d5,del,dim,dk,dl,ds,e,
     & el,es,f,fl,fs,g,gl,gs,h,hl,hs,i,i0,i1,i2,il,is,itest,j,jj,jl,js,
     & k,kk,kl,ks,l,lk,ll,ls,m,ml,mods,modulo,ms,mul,n,nest,nl,np,ns,p,
     & psym,punsym,q,s,sym,u,unsym
      real t,x,y
      logical onemod
      dimension dim(*),modulo(14),s(14),sym(*),u(14),unsym(*),x(*),y(*)
      equivalence (al,u(1)),(bl,u(2)),(cl,u(3)),(dl,u(4)),(el,u(5)),
     & (fl,u(6)),(gl,u(7)),(hl,u(8)),(il,u(9)),(jl,u(10)),(kl,u(11)),
     & (ll,u(12)),(ml,u(13)),(nl,u(14)),(bs,s(2)),(cs,s(3)),(ds,s(4)),
     & (es,s(5)),(fs,s(6)),(gs,s(7)),(hs,s(8)),(is,s(9)),(js,s(10)),
     & (ks,s(11)),(ls,s(12)),(ms,s(13)),(ns,s(14))
cjn uninitialized values
      data mods/0/
      nest=14
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      if(sym(1).eq.0) go to 200
      do 10 j=1,nest
      u(j)=1
      s(j)=1
10    continue
      n=np
      do 20 j=1,nest
      if(sym(j).eq.0) go to 30
      jj=nest+1-j
      u(jj)=n
      s(jj)=n/sym(j)
      n=n/sym(j)
20    continue
30    jj=0
      do 190 a=1,al
      do 180 b=a,bl,bs
      do 170 c=b,cl,cs
      do 160 d=c,dl,ds
      do 150 e=d,el,es
      do 140 f=e,fl,fs
      do 130 g=f,gl,gs
      do 120 h=g,hl,hs
      do 110 i=h,il,is
      do 100 j=i,jl,js
      do 90 k=j,kl,ks
      do 80 l=k,ll,ls
      do 70 m=l,ml,ms
      do 60 n=m,nl,ns
      jj=jj+1
      if(jj.ge.n) go to 60
      del=(n-jj)*d2
      i0=(jj-1)*d2+1
      do 50 i1=i0,d1,d3
      i2=i1+d4
      do 40 p=i1,i2,d5
      q=p+del
      t=x(p)
      x(p)=x(q)
      x(q)=t
      t=y(p)
      y(p)=y(q)
      y(q)=t
40    continue
50    continue
60    continue
70    continue
80    continue
90    continue
100   continue
110   continue
120   continue
130   continue
140   continue
150   continue
160   continue
170   continue
180   continue
190   continue
200   if(unsym(1).eq.0) go to 350
      punsym=np/psym**2
      mul=punsym/unsym(1)
      itest=(unsym(1)*unsym(2)-1)*mul*psym
      lk=mul
      dk=mul
      do 210 k=2,nest
      if(unsym(k).eq.0) go to 220
      lk=lk*unsym(k-1)
      dk=dk/unsym(k)
      u(k)=(lk-dk)*psym
      mods=k
210   continue
220   onemod=mods.lt.3
      if(onemod) go to 240
      do 230 j=3,mods
      jj=mods+3-j
      modulo(jj)=u(j)
230   continue
240   modulo(2)=u(2)
      jl=(punsym-3)*psym
      ms=punsym*psym
      do 340 j=psym,jl,psym
      k=j
250   k=k*mul
      if(onemod) go to 270
      do 260 i=3,mods
      k=k-(k/modulo(i))*modulo(i)
260   continue
270   if(k.ge.itest) go to 280
      k=k-(k/modulo(2))*modulo(2)
      go to 290
280   k=k-(k/modulo(2))*modulo(2)+modulo(2)
290   if(k.lt.j) go to 250
      if(k.eq.j) go to 340
      del=(k-j)*d2
      do 330 l=1,psym
      do 320 m=l,np,ms
      i0=(m+j-1)*d2+1
      do 310 i1=i0,d1,d3
      i2=i1+d4
      do 300 jj=i1,i2,d5
      kk=jj+del
      t=x(jj)
      x(jj)=x(kk)
      x(kk)=t
      t=y(jj)
      y(jj)=y(kk)
      y(kk)=t
300   continue
310   continue
320   continue
330   continue
340   continue
350   return
      end
"ENDOF diprp.f"
#=======================================================================
echo diraxh.f
cat >diraxh.f <<"ENDOF diraxh.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine diraxh(mr)
      implicit none
      integer hlw,hup,ibid1,ibid2,iecr,ilec,iout,klw,kprt,kup,maxr,minr,
     & mr,mxy,mxyz,my,mz,nh,nk,nrec,nwds,nwdsm,nx,nxyz,ny,nz,ph,pz,td,
     & xlw,xup,ylw,yup,zlw,zup
      real rbid1
      character cbid1*1
      common/dfft/ hlw,hup,klw,kup,ibid1(3),nxyz
      common/dfftd/ ph,pz,td,nwds,nwdsm
      common/dfftx/ rbid1(6),xlw,ylw,zlw,xup,yup,zup
      common/grid/ ibid2(3),nx,ny,nz
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      nh=hup-hlw+1
      nk=kup-klw+1
      my=yup-ylw+1
      mz=zup-zlw+1
c logicalunit
      td=90
      nwds=0
      call abra(td,'d','s',nwds)
      mxy=max(nx*my,2*nh*ny)
      mxyz=max(mxy*mz,2*nh*nk*nz)
         if(mr.ge.mxyz) then
      ph=nh
      pz=mz
      return
         endif
      minr=max(mxy,2*nk*nz)
      if(mr.lt.minr) go to 901
      maxr=sqrt(real(nwdsm))*sqrt(real(mxy*nz))
         if(mr.gt.maxr) then
      pz=min(maxr/mxy,mz)
      ph=min(maxr/(2*nk*nz),nh)
         else
      pz=min(mr/mxy,mz)
      ph=min(mr/(2*nk*nz),nh)
         endif
      nwds=2*ph*nk*pz
      nrec=((nh-1)/ph+1)*((mz-1)/pz+1)
      if(kprt.ne.0) write(iecr,2010) ph,pz,nwds,nrec
      return
901   write(iecr,3010) minr
      write(iout,3010) minr
      stop
2010  format(/' direct access. pages(ph,pz) =',2i5,
     . ', words =',i10,', recds =',i5)
3010  format('stop >> diraxh << insufficient memory. smallest mr =',i10)
      end
"ENDOF diraxh.f"
#=======================================================================
echo e2v.f
cat >e2v.f <<"ENDOF e2v.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program e2v
      implicit none
      integer i1,length,lungo,mr,mx,my,mz,n,nlungo,nx,ny,nz,o1,px,py,pz,
     & xl,xlow,xu,xup,yl,ylow,yu,yup,zl,zlow,zu,zup
      real a,alpha,b,beta,c,cm,dx,dy,dz,gamma,magno,rr,scale,spacing,ss
      character card*80,lun*500
      external length,lungo
      parameter(mr=1000000)
      dimension cm(3),rr(mr),ss(mr)
      data i1,o1/1,2/,nlungo/500/
      write(6,'(/a)') ' *************** E2V ***************'
      write(6,'(a)') ' enter the input ezd-map filename'
      read(5,'(a)') lun
      write(6,'(a,a)') ' input ezd-map: ',lun(1:lungo(lun,nlungo))
      open(unit=i1,file=lun,form='formatted',status='old')
      rewind(unit=i1)
10    read(i1,'(a)') card
      if(card(1:4).ne.'CELL') go to 10
      read(card(5:80),*) a,b,c,alpha,beta,gamma
      read(i1,'(a)') card
      read(card(7:80),*) xlow,ylow,zlow
      read(i1,'(a)') card
      read(card(7:80),*) mx,my,mz
      read(i1,'(a)') card
      read(card(5:80),*) nx,ny,nz
      read(i1,'(a)') card
      read(card(6:80),*) scale
      read(i1,*)
      dx=a/nx
      dy=b/ny
      dz=c/nz
      xup=xlow+mx-1
      yup=ylow+my-1
      zup=zlow+mz-1
      write(6,'(a,6f10.3)') ' input cell =',a,b,c,alpha,beta,gamma
      write(6,'(a,3f10.5/a,3i5)') ' input spacings =',dx,dy,dz,
     . ' extent =',mx,my,mz
      write(6,'(a,6i5)') ' input indices [x],[y],[z] =',
     . xlow,xup,ylow,yup,zlow,zup
      px=mx
      py=my
      pz=mz
      call control(px)
      call control(py)
      call control(pz)
      if(px.ne.mx.or.py.ne.my.or.pz.ne.mz) write(6,'(/a,3i5)')
     . ' extent changed to fit FFT requirements'
      write(6,'(a)') ' enter the magnification'
      read(5,*) magno
      dx=dx*magno
      dy=dy*magno
      dz=dz*magno
      xl=xlow+(mx-px)/2
      xu=xup-(mx-px+1)/2
      yl=ylow+(my-py)/2
      yu=yup-(my-py+1)/2
      zl=zlow+(mz-pz)/2
      zu=zup-(mz-pz+1)/2
      nx=xu-xl+1
      ny=yu-yl+1
      nz=zu-zl+1
      a=nx*dx
      b=ny*dy
      c=nz*dz
      alpha=90.
      beta=90.
      gamma=90.
       do n=1,80
      card(n:n)=' '
       enddo
      write(card,'(6f12.3)') a,b,c,alpha,beta,gamma
      read(card,*) a,b,c,alpha,beta,gamma
      write(6,'(a,6f10.3)') ' output cell =',a,b,c,alpha,beta,gamma
      write(6,'(a,3f10.5/a,3i5)') ' output spacings =',dx,dy,dz,
     . ' extent =',nx,ny,nz
      write(6,'(a,6i5)') ' output indices [x],[y],[z] =',
     . xl,xu,yl,yu,zl,zu
         if(mx*my.gt.mr) then
      write(6,'(/a,i10)') ' STOP >> e2v << set mr =',mx*my
      stop
         endif
      write(6,'(a)') ' enter the output vtk-map filename'
      read(5,'(a)') lun
      write(6,'(a,a)') ' output vtk-map: ',lun(1:lungo(lun,nlungo))
      open(unit=o1,file=lun,form='formatted',status='unknown')
      rewind(unit=o1)
      write(card,'(a)') '# vtk DataFile Version 2.0'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'Converted from ezd to vtk , suits Ten Eyck FFT'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'ASCII'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'DATASET STRUCTURED_POINTS'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a,3i10)') 'DIMENSIONS',nx,ny,nz
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a,3f15.5)') 'SPACING',dx,dy,dz
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a,3f15.3)') 'ORIGIN',xl*dx,yl*dy,zl*dz
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a,i15)') 'POINT_DATA',nx*ny*nz
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'SCALARS scalars float'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'LOOKUP_TABLE default'
      write(o1,'(a)') card(1:length(card))
      call shrinke(i1,o1,xlow,xup,ylow,yup,zlow,zup,xl,xu,yl,yu,zl,zu,
     . rr(1),ss(1),scale,cm)
      write(6,'(6f10.3,a)') a,b,c,alpha,beta,gamma,'  CELL'
      spacing=max(dx,dy,dz)
      write(6,'(a,f10.3)') ' MAXIMAL ALLOWED RESOLUTION >',spacing*2.
      cm(1)=(xl-cm(1))*dx
      cm(2)=(yl-cm(2))*dy
      cm(3)=(zl-cm(3))*dz
      write(6,'(a,3f15.5)') ' ORIGIN FOR CM = 0 (Angstroms) :',cm
      stop
      end
"ENDOF e2v.f"
#=======================================================================
echo epslon.f
cat >epslon.f <<"ENDOF epslon.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function epslon(x)
      implicit none
      real a,b,c,eps,epslon,x
      a=4.0e0/3.0e0
10    b=a-1.0e0
      c=b+b+b
      eps=abs(c-1.0e0)
      if(eps.eq.0.0e0) go to 10
      epslon=eps*abs(x)
      return
      end
"ENDOF epslon.f"
#=======================================================================
echo essec.f
cat >essec.f <<"ENDOF essec.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine essec(o1,mxy,rr,last)
      implicit none
      integer i,il,iu,ixy,j,len,lm,lungo,mxy,nlungo,o1
      real line,rr
      character card*500
      logical first,last
      external lungo
      parameter(len=7)
      dimension line(len),rr(mxy)
      data first/.true./,nlungo/500/
      save il,iu,line,lm
         if(first) then
      first=.false.
      lm=len
      ixy=1
         else
            if(lm.ne.len) then
        do i=1,len-lm
      line(i+lm)=rr(i)
        enddo
      write(card,'(7f20.7)') (line(i),i=1,len)
      call compakt(card,nlungo)
      write(o1,'(a)') card(1:lungo(card,nlungo))
            endif
      ixy=1+len-lm
         endif
      il=1-lm
       do j=ixy,mxy,len
      il=il+len
      iu=min(il+len-1,mxy)
      lm=iu-il+1
        do i=1,lm
      line(i)=rr(i+il-1)
        enddo
         if(lm.eq.len.or.last) then
      write(card,'(7f20.7)') (line(i),i=1,lm)
      call compakt(card,nlungo)
      write(o1,'(a)') card(1:lungo(card,nlungo))
         endif
       enddo
      return
      end
"ENDOF essec.f"
#=======================================================================
echo expans.f
cat >expans.f <<"ENDOF expans.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine expans(nra,meq,hklo,hkl,fob,fc)
      implicit none
      integer h,hkl,hklo,hs,ibid1,iecr,iind,ilec,ind,inds,iout,ir,is,k,
     & kprt,ks,l,ls,m,meq,mss,mult,neq,nr,nra,ntot,nts
      real a11,a21,a22,a31,a32,a33,bfact,corf,cori,corp,fc,fo,fob,rfli,
     & rfsq,scale,sfli,sfqu,sfsq,sqh,tss,tts
      character cbid1*1
      dimension fc(nra*meq),fob(2*nra*meq),hkl(nra*meq),hklo(2*nra*meq),
     & inds(48)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/numo/ ntot,ibid1(6)
      common/pote/ sfli,sfsq,sfqu,rfli,rfsq,corf,cori,corp,scale,bfact
      common/simt/ tss(3,48),tts(9),mss(3,3,48),neq,nts
      common/star/ a11,a21,a22,a31,a32,a33
      nr=0
      do 40 ir=1,nra
      call unpac4(h,k,l,mult,hklo(ir))
      fo=fob(ir)
      mult=0
      do 30 is=1,neq
      hs=h*mss(1,1,is)+k*mss(2,1,is)+l*mss(3,1,is)
      ks=h*mss(1,2,is)+k*mss(2,2,is)+l*mss(3,2,is)
      ls=h*mss(1,3,is)+k*mss(2,3,is)+l*mss(3,3,is)
c pacote
         if(hs.lt.0.or.(hs.eq.0.and.(ls.gt.0.or.(ls.eq.0.and.ks.gt.0))))
     . then
      hs=-hs
      ks=-ks
      ls=-ls
         endif
      call pac3(hs,ks,ls,iind)
      if(is.eq.1) go to 20
      do 10 m=1,mult
      if(inds(m).eq.iind) go to 30
10    continue
20    mult=mult+1
      inds(mult)=iind
      nr=nr+1
      hkl(nr)=iind
      fc(nr)=fo
30    continue
40    continue
      mult=2
      ntot=0
      sfli=0.
      sfsq=0.
      sfqu=0.
      do 50 ir=1,nr
      ind=hkl(ir)
      fo=fc(ir)
      call unpac3(h,k,l,ind)
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      call pac4(h,k,l,mult,hklo(ir))
      hklo(nr+ir)=ind
      fob(ir)=fo
      fob(nr+ir)=sqh
      ntot=ntot+mult
      sfli=sfli+mult*fo
      sfsq=sfsq+mult*fo*fo
      sfqu=sfqu+mult*fo**4
50    continue
      nra=nr
      neq=1
      nts=0
      if(kprt.ne.0) write(iecr,2010) nra,sfli,sfsq,sfqu
      return
2010  format(/' expans.',i10,' reflections'/
     . ' sum fo =',e15.5,', sum fosq =',e15.5,', sum foqu =',e15.5)
      end
"ENDOF expans.f"
#=======================================================================
echo fitndo.f
cat >fitndo.f <<"ENDOF fitndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine fitndo(mi,mr,mc,ii,rr,cc)
      implicit none
      integer actual,bod,hmax,i,ia,ib,ibid1,ibid2,icm,icmax,iecr,ierr,
     & ig,ii,ij,ilec,im,imol,incs,iout,ip,ipn,ipr,ir0,is,it,itmax,ix,iy,
     & iz,j0,j1,j2,j3,j4,j5,j6,j7,j8,jt,jtmax,kinv,kmax,kprt,kprtt,ksis,
     & lmax,mc,mcs,mi,mp,mr,mta,n,na,nam,ncm,ncs,ncyc,nd,neq,nfit,nmol,
     & nort,np,nprt,nr,nra,nts,ntyp,sim,sm,tbod,udi
      real a,al,alpha,b,be,beta,bfact,c,cof,coi,corf,cori,corp,da,db,dg,
     & dist,dmaxo,dmino,dtor,dx,dy,dz,eigen,epsn,fmax,fmin,func,funk,ga,
     & gamma,grad,pasa,pasx,pctr,pi,pivot,pv,qd,qq,quad,rbid1,rbid2,
     & rbid3,rbid4,rf,rfl,rfli,rfsq,rm,rms,rncs,ro,rox,rr,rtod,rx,scale,
     & sfli,sfqu,sfsq,sfsq0,sigma,sqhmax,tfac,tncs,to,twopi,tx,ty,tz
      complex cc
      character card*80,forme*40,formr*40,tcar*4000,title*1,zn*1
      logical first,p1
      parameter(na=79,nam=500,ncm=1000,np=6)
      dimension cc(mc),eigen(np*(np+3)),grad(np),ii(mi),pv(6),qq(9,na),
     & quad(np*np),rm(11,nam),rms(np),rox(9),rr(mr),rx(9),sigma(np*np),
     & sim(ncm),sm(0:ncm,nam),title(72)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ctlx/ pctr,fmin,fmax,tfac,ibid1
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ncsdat/ ncs,incs(1000),rncs(9,1000),tncs(3,1000),
     & rbid2(48,1000)
      common/oprt/ kprtt(20)
      common/ortm/ ro(9),rf(9),nort
      common/pote/ sfli,sfsq,sfqu,rfli,rfsq,corf,cori,corp,scale,bfact
      common/reso/ dmaxo,dmino,rbid3(4)
      common/simt/ rbid4(153),ibid2(432),neq,nts
cjn uninitialized values
      data dist,funk,pv,cof,coi,rfl/0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0./
      kprt=0
      actual=0
      ksis=1
      kinv=0
      read(ilec,*) nprt,(kprtt(ipr),ipr=1,nprt)
      read(ilec,*) udi,iout
      call abra(udi,'u','u',0)
      rewind(unit=udi)
      call abra(iout,'f','u',0)
      rewind(iout)
      read(ilec,'(72a1)') title
      write(iecr,2010)
      kprt=kprtt(1)
      read(ilec,*) a,b,c,alpha,beta,gamma
      call celda
      call lecsim
      call setpak
      read(ilec,*) nort
      call ortho
       do i=1,9
      rox(i)=ro(i)
      rx(i)=rf(i)
       enddo
      read(ilec,*) pctr,tfac
      read(ilec,*) dmaxo,dmino
         if(dmaxo.lt.dmino) then
      to=dmaxo
      dmaxo=dmino
      dmino=to
         endif
      read(ilec,'(a)') card
         if(card(1:2).eq.'p1') then
      p1=.true.
      read(ilec,'(a)') card
         else
      p1=.false.
         endif
       do is=1,ncm
      sim(is)=0
      incs(is)=0
        do i=1,9
      rncs(i,is)=0.
        enddo
        do i=1,3
      tncs(i,is)=0.
        enddo
       enddo
         if(card(1:3).eq.'ncs') then
      tcar(1:77)=card(4:80)
c lecturainterna
      read(tcar,*) mcs
      if(mcs.gt.ncm) go to 905
      write(iecr,'(/a,i5)') ' NCS =',mcs
      kprt=0
       do i=1,mcs
      read(ilec,'(a)') card
      write(iecr,'(a)') card
      it=index(card,'#')
      card(it:it)=' '
c lecturainterna
      read(card,*) al,be,ga,tx,ty,tz,is
      sim(is)=1
      call rmxe(al,be,ga,rncs(1,is))
      tncs(1,is)=tx
      tncs(2,is)=ty
      tncs(3,is)=tz
       enddo
      kprt=kprtt(1)
      read(ilec,'(a)') card
         else
      mcs=1
      is=1
      sim(is)=1
      call rmxe(0.,0.,0.,rncs(1,is))
      tncs(1,is)=0.
      tncs(2,is)=0.
      tncs(3,is)=0.
         endif
      tcar(1:65)=card(16:80)
c lecturainterna
      read(tcar,*) ntyp
       do n=1,ntyp
      read(ilec,'(2x,i2,5x,6f9.2)') bod,(qq(i,bod),i=1,6)
      qq(9,bod)=qq(3,bod)
      qq(8,bod)=qq(6,bod)
      qq(7,bod)=qq(5,bod)
      qq(5,bod)=qq(2,bod)
      qq(3,bod)=qq(7,bod)
      qq(2,bod)=qq(4,bod)
       enddo
      read(udi) nd
      nr=min((mi-nd)/(1+neq),(mr-2*nd)/2)
      if(nr.le.0) go to 901
      ir0=1+nr
      call lecfoq(udi,nd,nr,nra,neq,ii(ir0),ii(1),ii(ir0+nd),
     . rr(ir0),rr(ir0+nd),rr(1),rr(ir0+2*nd),cc(1),'h')
      sfsq0=sfsq
      if(9*nra.gt.mr) go to 902
         if(p1) then
      nr=min(mi-2*neq*nra,mr-2*neq*nra)
      if(nr.le.0) go to 901
      call expans(nra,neq,ii(1),ii(1+nra*neq),rr(1),rr(1+nra*neq))
      if(9*nra.gt.mr) go to 902
         endif
      write(iout,'(a,72a1)') 'fiting: ',title
      jtmax=5
10    read(ilec,*,end=40) nmol
      if(nmol.gt.nam) go to 903
      first=.true.
      sfsq=sfsq0
      kprt=kprtt(2)
      read(ilec,*) is,ia,ib,ig,ix,iy,iz
      mp=ia+ib+ig+ix+iy+iz
      read(ilec,*) ncyc,itmax,epsn
         if(ncyc.eq.0) then
      nfit=nmol*nmol
         else if(ncyc.gt.0) then
      nfit=ncyc*nmol
         else
      nfit=-ncyc
         endif
         if(kprt.ne.0) then
      write(iecr,'(/a)') ' parametros a fitear'
      write(iecr,*) ' b-factor      =',is
      write(iecr,*) ' angulo alfa   =',ia
      write(iecr,*) ' angulo beta   =',ib
      write(iecr,*) ' angulo gama   =',ig
      write(iecr,*) ' translacion x =',ix
      write(iecr,*) ' translacion y =',iy
      write(iecr,*) ' translacion z =',iz
         endif
      ip=0
      ipn=mp
      ij=0
         if(ia.ne.0) then
      ip=ip+1
      ia=ip
         else
      ipn=ipn+1
      ia=ipn
         endif
         if(ib.ne.0) then
      ip=ip+1
      ib=ip
         else
      ipn=ipn+1
      ib=ipn
         endif
         if(ig.ne.0) then
      ip=ip+1
      ig=ip
         else
      ipn=ipn+1
      ig=ipn
         endif
         if(ix.ne.0) then
      ip=ip+1
      ix=ip
         else
      ipn=ipn+1
      ix=ipn
         endif
         if(iy.ne.0) then
      ip=ip+1
      iy=ip
         else
      ipn=ipn+1
      iy=ipn
         endif
         if(iz.ne.0) then
      ip=ip+1
      iz=ip
         else
      ipn=ipn+1
      iz=ipn
         endif
      j0=1+nra
      j1=j0+nra
      j2=j1+nra*ia
      j3=j1+nra*ib
      j4=j1+nra*ig
      j5=j1+nra*ix
      j6=j1+nra*iy
      j7=j1+nra*iz
      j8=1+nra*9
       do i=j0,j1-1
      cc(i)=(0.,0.)
       enddo
      write(iecr,'(/a)') ' posiciones iniciales'
      kprt=kprtt(3)
      imol=1
20    read(ilec,'(a)') tcar
      it=index(tcar,'#')
      tcar(it:it)=' '
c lecturainterna
      read(tcar,*) bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      write(iecr,fmt=forme) zn,bod,al,be,ga,tx,ty,tz
      sm(0,imol)=ncs
       do i=1,ncs
      if(sim(incs(i)).eq.0) go to 906
      sm(i,imol)=incs(i)
       enddo
      rm(1,imol)=real(bod)
      rm(2,imol)=al
      rm(3,imol)=be
      rm(4,imol)=ga
      rm(5,imol)=tx
      rm(6,imol)=ty
      rm(7,imol)=tz
      rm(8,imol)=cof
      rm(9,imol)=rfl
      rm(10,imol)=coi
      rm(11,imol)=dist
      tbod=bod+10
         if(tbod.ne.actual) then
      if(actual.ne.0) call cierre(actual,'u')
      actual=tbod
      call abra(actual,'u','u',0)
      rewind(unit=actual)
      read(actual) a,b,c,alpha,beta,gamma,nort,hmax,kmax,lmax,sqhmax
      mta=(hmax+2)*(2*kmax+1)*(2*lmax+1)
      if(9*nra+mta.gt.mc) go to 904
      call lectab(actual,hmax,kmax,lmax,cc(j8))
       do i=1,9
      rf(i)=rx(i)
       enddo
         endif
         if(imol.lt.nmol) then
      call ncsym(al,be,ga,tx,ty,tz)
      call fixmol(hmax,kmax,lmax,nra,neq,ii(j0),cc(j0),cc(j8),'+')
         endif
      imol=imol+1
      if(imol.le.nmol) go to 20
      pasa=-1.
      pasx=-1.
      it=0
      icm=0
      icmax=nmol*(1+nfit/nmol)-1
      kprt=kprtt(4)
30    call ncsym(al,be,ga,tx,ty,tz)
      call interp(hmax,kmax,lmax,nra,neq,ii(j0),
     . cc(j1),cc(j2),cc(j3),cc(j4),cc(j5),cc(j6),cc(j7),cc(j0),cc(j8))
      call setsca(is,nra,ii(1),rr(j0),cc(1),cc(j1),first)
      if(ig.le.mp.and.ia.le.mp.and.(abs(be).lt.1..or.abs(be-180).lt.1.))
     . ij=min(ia,ig)
       do i=1,np
      grad(i)=0.
       enddo
      call quadro(is,ij,nra,mp,ii(1),rr(j0),cc(1),cc(j1),grad,quad,func)
      if(it.eq.0.and.icm.eq.0) funk=func
      ij=0
         if(it.le.itmax.and.func-funk.le.funk*1.e-2) then
      jt=0
      pv(1)=al
      pv(2)=be
      pv(3)=ga
      pv(4)=tx
      pv(5)=ty
      pv(6)=tz
       do i=1,np*np
      sigma(i)=quad(i)
       enddo
      call choler(mp,quad,grad,ksis,kinv,0.)
      da=pasa*grad(ia)*rtod
      db=pasa*grad(ib)*rtod
      dg=pasa*grad(ig)*rtod
      dx=pasx*grad(ix)
      dy=pasx*grad(iy)
      dz=pasx*grad(iz)
      call shift(rox,qq(1,bod),al,be,ga,tx,ty,tz,da,db,dg,dx,dy,dz,qd,
     . it,im)
         else
      jt=jt+1
            if(jt.eq.1) then
      al=pv(1)
      be=pv(2)
      ga=pv(3)
      tx=pv(4)
      ty=pv(5)
      tz=pv(6)
      call rs(mp,mp,sigma,eigen(1),eigen(1+mp),eigen(1+mp*(mp+1)),
     . eigen(1+mp*(mp+2)),1,ierr)
      write(iecr,'(/a,6e15.5)') ' eigen =',(eigen(i),i=1,mp)
               if(eigen(1).gt.0.) then
      pivot=0.
               else
      ip=1
       do i=1,mp
      if(eigen(i).le.0.) ip=i+1
       enddo
      pivot=eigen(ip)-eigen(1)
               endif
      call choler(mp,quad,grad,ksis,kinv,pivot)
      da=pasa*grad(ia)*rtod
      db=pasa*grad(ib)*rtod
      dg=pasa*grad(ig)*rtod
      dx=pasx*grad(ix)
      dy=pasx*grad(iy)
      dz=pasx*grad(iz)
      call shift(rox,qq(1,bod),al,be,ga,tx,ty,tz,da,db,dg,dx,dy,dz,qd,
     . it,im)
      go to 30
            else if(jt.le.jtmax) then
      da=da/2
      db=db/2
      dg=dg/2
      dx=dx/2
      dy=dy/2
      dz=dz/2
      al=al-da
      be=be-db
      ga=ga-dg
      tx=tx-dx
      ty=ty-dy
      tz=tz-dz
      go to 30
            else
      al=pv(1)
      be=pv(2)
      ga=pv(3)
      tx=pv(4)
      ty=pv(5)
      tz=pv(6)
      it=itmax
            endif
         endif
      if(func.lt.funk) funk=func
         if(kprt.ne.0) then
            if(jt.eq.0) then
      write(iecr,*) ' iteracion =',it,', funcion =',func
            else
      write(iecr,*) ' fails =',jt,', funcion =',func
            endif
         endif
      it=it+1
      if(it.le.itmax.and.qd.gt.epsn) go to 30
      im=1+mod(nmol+icmax-icm,nmol)
      da=al-rm(2,im)
      db=be-rm(3,im)
      dg=ga-rm(4,im)
      dx=tx-rm(5,im)
      dy=ty-rm(6,im)
      dz=tz-rm(7,im)
      al=rm(2,im)
      be=rm(3,im)
      ga=rm(4,im)
      tx=rm(5,im)
      ty=rm(6,im)
      tz=rm(7,im)
      it=-1
      call shift(rox,qq(1,bod),al,be,ga,tx,ty,tz,da,db,dg,dx,dy,dz,qd,
     . it,im)
      rm(1,im)=real(bod)
      rm(2,im)=al
      rm(3,im)=be
      rm(4,im)=ga
      rm(5,im)=tx
      rm(6,im)=ty
      rm(7,im)=tz
      rm(8,im)=cof
      rm(9,im)=rfl
      rm(10,im)=coi
      rm(11,im)=dist
       do i=1,np
      rms(i)=0.
       enddo
      call choler(mp,sigma,rms,0,1,0.)
       do i=1,mp
      rms(i)=sqrt(sigma((i-1)*mp+i)*func/(2*nra))
       enddo
      rms(ia)=rms(ia)*rtod
      rms(ib)=rms(ib)*rtod
      rms(ig)=rms(ig)*rtod
      rms(ix)=rms(ix)*a
      rms(iy)=rms(iy)*b
      rms(iz)=rms(iz)*c
      write(iecr,'(a,6f8.2)') ' r-m-s of parameters =',(rms(i),i=1,mp)
      write(iecr,'(a,a,f10.3)') ' scale, correlation coefficients,',
     . ' r-fact, b-factor. function =',func*100.
      write(iecr,'(e15.5,4f10.3)') scale,corf*100,cori*100,rfli*100,
     . bfact*4
      icm=icm+1
         if(icm.lt.nfit) then
      kprt=kprtt(3)
      call ncsym(al,be,ga,tx,ty,tz)
      call fixmol(hmax,kmax,lmax,nra,neq,ii(j0),cc(j0),cc(j8),'+')
      im=1+mod(nmol+icmax-icm,nmol)
      ncs=sm(0,im)
       do i=1,ncs
      incs(i)=sm(i,im)
       enddo
      bod=nint(rm(1,im))
      al=rm(2,im)
      be=rm(3,im)
      ga=rm(4,im)
      tx=rm(5,im)
      ty=rm(6,im)
      tz=rm(7,im)
      cof=rm(8,im)
      rfl=rm(9,im)
      coi=rm(10,im)
      dist=rm(11,im)
      tbod=bod+10
            if(tbod.ne.actual) then
      call cierre(actual,'u')
      actual=tbod
      call abra(actual,'u','u',0)
      rewind(unit=actual)
      read(actual) a,b,c,alpha,beta,gamma,nort,hmax,kmax,lmax,sqhmax
      call lectab(actual,hmax,kmax,lmax,cc(j8))
       do i=1,9
      rf(i)=rx(i)
       enddo
            endif
      call ncsym(al,be,ga,tx,ty,tz)
      call fixmol(hmax,kmax,lmax,nra,neq,ii(j0),cc(j0),cc(j8),'-')
      it=0
      jt=0
      pv(1)=al
      pv(2)=be
      pv(3)=ga
      pv(4)=tx
      pv(5)=ty
      pv(6)=tz
      kprt=kprtt(4)
      go to 30
         else
      write(iecr,*)
      write(iecr,*) ' posiciones finales'
      write(iout,'(2i10)') nmol,1
       do imol=1,nmol
      bod=nint(rm(1,imol))
      al=rm(2,imol)
      be=rm(3,imol)
      ga=rm(4,imol)
      tx=rm(5,imol)
      ty=rm(6,imol)
      tz=rm(7,imol)
      cof=rm(8,imol)
      rfl=rm(9,imol)
      coi=rm(10,imol)
      dist=rm(11,imol)
            if(imol.lt.nmol) then
      write(iecr,fmt=forme) zn,bod,al,be,ga,tx,ty,tz
      write(iout,fmt=forme) zn,bod,al,be,ga,tx,ty,tz
            else
      write(iecr,fmt=forme) zn,bod,al,be,ga,tx,ty,tz,
     . corf*100.,rfli*100.,cori*100.
      write(iout,fmt=forme) zn,bod,al,be,ga,tx,ty,tz,
     . corf*100.,rfli*100.,cori*100.,func*100.
            endif
       enddo
         endif
      go to 10
40    return
901   write(iecr,3010)
      write(iout,3010)
      stop
902   write(iecr,3020) 9*nra
      write(iout,3020) 9*nra
      stop
903   write(iecr,3030) nam,nmol
      write(iout,3030) nam,nmol
      stop
904   write(iecr,3040) 9*nra+mta
      write(iout,3040) 9*nra+mta
      stop
905   write(iecr,3050) ncm,ncs
      write(iout,3050) ncm,ncs
      stop
906   write(iecr,3060)
      write(iout,3060)
      stop
2010  format(/' ****** programme fiting ******'/
     . ' *** fast rigid body refinement ***'/
     . ' *** e.e. castellano, g. oliva and j. navaza (1992),'/
     . ' jnl. appl. cryst. 25, 281-284 ***'/
     . ' *** version york (1999) ***')
3010  format('stop >> fitndo << increase mi and mr')
3020  format('stop >> fitndo << set mr >',i10)
3030  format('stop >> fitndo << nb. molecules greater than',i5,' =',i5)
3040  format('stop >> fitndo << set mc >',i10)
3050  format('stop >> fitndo << nb. ncs greater than',i5,' =',i5)
3060  format('stop >> fitndo << symmetry operation not in symlist')
      end
"ENDOF fitndo.f"
#=======================================================================
echo fixmol.f
cat >fixmol.f <<"ENDOF fixmol.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine fixmol(hmax,kmax,lmax,nra,meq,hkls,ff,ft,mas)
      implicit none
      integer h,hh,hkls,hmax,hs,ih,ik,il,in,incs,ir,is,k,kk,kmax,ks,l,
     & ll,lmax,ls,meq,mss,ncs,neq,nra,nts
      real dh,dk,dl,dmdn,dmn,dtor,dxn,phi,phix,pi,rbid1,rtod,tss,tts,
     & twopi,txn,xh,xk,xl
      complex dfh,dfk,dfl,f,fc,ff,ft,phase,twopii
      character mas*1
      logical fridel,plus
      dimension ff(nra),ft(-1:hmax,-kmax:kmax,-lmax:lmax),hkls(nra,meq)
      common/angkte/ pi,twopi,dtor,rtod
      common/ncsdat/ ncs,incs(1000),rbid1(12,1000),
     & dmn(3,3,1000),dmdn(3,3,3,1000),dxn(3,3,1000),txn(3,1000)
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      twopii=cmplx(0.,twopi)
         if(mas.eq.'+') then
      plus=.true.
         else
      plus=.false.
         endif
      do 20 ir=1,nra
      call unpac3(h,k,l,hkls(ir,1))
      fc=(0.,0.)
      do 10 is=1,neq
      call unpac3(hs,ks,ls,hkls(ir,is))
      phix=h*tss(1,is)+k*tss(2,is)+l*tss(3,is)
       do in=1,ncs
      phi=mod(phix+hs*txn(1,in)+ks*txn(2,in)+ls*txn(3,in),1.)
      phase=cexp(twopii*phi)
      xh=hs*dmn(1,1,in)+ks*dmn(2,1,in)+ls*dmn(3,1,in)
      xk=hs*dmn(1,2,in)+ks*dmn(2,2,in)+ls*dmn(3,2,in)
      xl=hs*dmn(1,3,in)+ks*dmn(2,3,in)+ls*dmn(3,3,in)
      fridel=.false.
         if(xh.lt.0.) then
      xh=-xh
      xk=-xk
      xl=-xl
      fridel=.true.
         endif
      hh=nint(xh)
      dh=xh-hh
      ih=1
      if(dh.lt.0.) ih=-1
      kk=nint(xk)
      dk=xk-kk
      ik=1
      if(dk.lt.0.) ik=-1
      ll=nint(xl)
      dl=xl-ll
      il=1
      if(dl.lt.0.) il=-1
      dfh=(ft(hh+ih,kk,ll)-ft(hh,kk,ll))/ih
      dfk=(ft(hh,kk+ik,ll)-ft(hh,kk,ll))/ik
      dfl=(ft(hh,kk,ll+il)-ft(hh,kk,ll))/il
      f=ft(hh,kk,ll)+dfh*dh+dfk*dk+dfl*dl
      if(fridel) f=conjg(f)
      f=f*phase
      fc=fc+f
       enddo
10    continue
         if(plus) then
      ff(ir)=ff(ir)+fc
         else
      ff(ir)=ff(ir)-fc
         endif
20    continue
      return
      end
"ENDOF fixmol.f"
#=======================================================================
echo hout.f
cat >hout.f <<"ENDOF hout.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine hout(td,nh,nk,pz,ph,zs,ww)
      implicit none
      integer hf,hs,ih,ikz,irec,nh,nk,ph,pz,td,xlw,xup,ylw,yup,zlw,zs,
     & zup
      real rbid1
      complex ww
      dimension ww(nh,nk*pz)
      common/dfftx/ rbid1(6),xlw,ylw,zlw,xup,yup,zup
      save irec
      if(zs.eq.zlw) irec=0
      hf=0
10    hs=hf+1
      hf=hf+ph
      if(hf.gt.nh) hf=nh
      irec=irec+1
      write(td,rec=irec) ((ww(ih,ikz),ih=hs,hf),ikz=1,nk*pz)
      if(hf.lt.nh) go to 10
      return
      end
"ENDOF hout.f"
#=======================================================================
echo indexm.f
cat >indexm.f <<"ENDOF indexm.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine indexm(dmin,hmax,kmax,lmax)
      implicit none
      integer hmax,kmax,lmax
      real a,b,c,dmin,fuzz,rbid1
      common/cell/ a,b,c,rbid1(19)
      data fuzz/1.0001/
      hmax=fuzz*a/dmin
      kmax=fuzz*b/dmin
      lmax=fuzz*c/dmin
      return
      end
"ENDOF indexm.f"
#=======================================================================
echo interp.f
cat >interp.f <<"ENDOF interp.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine interp(hmax,kmax,lmax,nra,meq,hkls,fc,fca,fcb,fcg,fcx,
     & fcy,fcz,ff,ft)
      implicit none
      integer h,hh,hkls,hmax,hs,ia,ih,ik,il,in,incs,ip,ir,is,k,kk,kmax,
     & ks,l,ll,lmax,ls,meq,mss,n,ncs,neq,nphi,nra,nts
      real dh,dk,dl,dm,dmd,dmdn,dmn,dtor,dxn,fmod,phi,phix,pi,rbid1,
     & rtod,tss,tts,twopi,tx,txn,ty,tz,xh,xha,xk,xka,xl,xla
      complex cex,dfh,dfk,dfl,f,fad,fc,fca,fcar,fcb,fcbr,fcg,fcgr,fcr,
     & fcx,fcxr,fcy,fcyr,fcz,fczr,ff,ft,phase,twopii,unoi
      logical fridel
      parameter(nphi=720)
      dimension cex(-nphi:nphi),fad(3),fc(nra),fca(nra),fcb(nra),
     & fcg(nra),fcx(nra),fcy(nra),fcz(nra),ff(nra),
     & ft(-1:hmax,-kmax:kmax,-lmax:lmax),hkls(nra,meq)
      common/angkte/ pi,twopi,dtor,rtod
      common/ncsdat/ ncs,incs(1000),rbid1(12,1000),
     & dmn(3,3,1000),dmdn(3,3,3,1000),dxn(3,3,1000),txn(3,1000)
      common/rotra/ dm(3,3),dmd(3,3,3),tx,ty,tz
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      unoi=(0.,1.)
      twopii=cmplx(0.,twopi)
       do n=-nphi,nphi
      cex(n)=cexp(n*twopii/nphi)
       enddo
      do 30 ir=1,nra
      call unpac3(h,k,l,hkls(ir,1))
      fcr=ff(ir)
      fcar=(0.,0.)
      fcbr=(0.,0.)
      fcgr=(0.,0.)
      fcxr=(0.,0.)
      fcyr=(0.,0.)
      fczr=(0.,0.)
      do 20 is=1,neq
      call unpac3(hs,ks,ls,hkls(ir,is))
      phix=h*tss(1,is)+k*tss(2,is)+l*tss(3,is)
       do in=1,ncs
      phi=mod(phix+hs*txn(1,in)+ks*txn(2,in)+ls*txn(3,in),1.)
      ip=nint(phi*nphi)
      phase=cex(ip)
      xh=hs*dmn(1,1,in)+ks*dmn(2,1,in)+ls*dmn(3,1,in)
      xk=hs*dmn(1,2,in)+ks*dmn(2,2,in)+ls*dmn(3,2,in)
      xl=hs*dmn(1,3,in)+ks*dmn(2,3,in)+ls*dmn(3,3,in)
      fridel=.false.
         if(xh.lt.0.) then
      xh=-xh
      xk=-xk
      xl=-xl
      fridel=.true.
         endif
      hh=nint(xh)
      dh=xh-hh
      ih=1
      if(dh.lt.0.) ih=-1
      kk=nint(xk)
      dk=xk-kk
      ik=1
      if(dk.lt.0.) ik=-1
      ll=nint(xl)
      dl=xl-ll
      il=1
      if(dl.lt.0.) il=-1
      dfh=(ft(hh+ih,kk,ll)-ft(hh,kk,ll))/ih
      dfk=(ft(hh,kk+ik,ll)-ft(hh,kk,ll))/ik
      dfl=(ft(hh,kk,ll+il)-ft(hh,kk,ll))/il
      f=ft(hh,kk,ll)+dfh*dh+dfk*dk+dfl*dl
         if(fridel) then
      f=conjg(f)
      dfh=-conjg(dfh)
      dfk=-conjg(dfk)
      dfl=-conjg(dfl)
         endif
      f=f*phase
      dfh=dfh*phase
      dfk=dfk*phase
      dfl=dfl*phase
      do 10 ia=1,3
      xha=hs*dmdn(1,1,ia,in)+ks*dmdn(2,1,ia,in)+ls*dmdn(3,1,ia,in)
      xka=hs*dmdn(1,2,ia,in)+ks*dmdn(2,2,ia,in)+ls*dmdn(3,2,ia,in)
      xla=hs*dmdn(1,3,ia,in)+ks*dmdn(2,3,ia,in)+ls*dmdn(3,3,ia,in)
      fad(ia)=xha*dfh+xka*dfk+xla*dfl
10    continue
      fcr=fcr+f
      fcar=fcar+fad(1)
      fcbr=fcbr+fad(2)
      fcgr=fcgr+fad(3)
      fcxr=fcxr+f*(hs*dxn(1,1,in)+ks*dxn(2,1,in)+ls*dxn(3,1,in))
      fcyr=fcyr+f*(hs*dxn(1,2,in)+ks*dxn(2,2,in)+ls*dxn(3,2,in))
      fczr=fczr+f*(hs*dxn(1,3,in)+ks*dxn(2,3,in)+ls*dxn(3,3,in))
       enddo
20    continue
      fmod=abs(fcr)
         if(fmod.gt.0.) then
      phi=aimag(clog(fcr))
         else
      phi=0.
         endif
      phase=cexp(-unoi*phi)
      fc(ir)=fcr
      fca(ir)=fcar
      fcb(ir)=fcbr
      fcg(ir)=fcgr
      fcx(ir)=fcxr*twopii
      fcy(ir)=fcyr*twopii
      fcz(ir)=fczr*twopii
30    continue
      return
      end
"ENDOF interp.f"
#=======================================================================
echo inv3.f
cat >inv3.f <<"ENDOF inv3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine inv3(r,s)
      implicit none
      integer r,s
      dimension r(3,3),s(3,3)
      s(1,1)=r(2,2)*r(3,3)-r(2,3)*r(3,2)
      s(1,2)=r(1,3)*r(3,2)-r(1,2)*r(3,3)
      s(1,3)=r(1,2)*r(2,3)-r(1,3)*r(2,2)
      s(2,1)=r(2,3)*r(3,1)-r(2,1)*r(3,3)
      s(2,2)=r(1,1)*r(3,3)-r(1,3)*r(3,1)
      s(2,3)=r(1,3)*r(2,1)-r(1,1)*r(2,3)
      s(3,1)=r(2,1)*r(3,2)-r(2,2)*r(3,1)
      s(3,2)=r(1,2)*r(3,1)-r(1,1)*r(3,2)
      s(3,3)=r(1,1)*r(2,2)-r(1,2)*r(2,1)
      return
      end
"ENDOF inv3.f"
#=======================================================================
echo lecatc.f
cat >lecatc.f <<"ENDOF lecatc.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lecatc(i1,carat,xi,biso,first,last)
      implicit none
      integer i,i1,j,nort
      real a,alpha,b,beta,biso,c,dtor,gamma,pi,rbid1,rf,ro,rtod,twopi,
     & xi,xo
      character atnam*4,carat*4,card*80,forml*80,tcar*80,tipo*4
      logical first,last
      dimension xi(3),xo(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ortm/ ro(3,3),rf(3,3),nort
      save forml,tipo
      carat='    '
         if(first) then
      first=.false.
      rewind(unit=i1)
       do i=1,80
      forml(i:i)=' '
       enddo
10    read(i1,'(a)') card
      call compact(card)
      if(card(1:6).ne.'FORMAT') go to 10
      forml(1:74)=card(7:80)
      read(i1,'(a)') card
            if(card(1:4).eq.'CELL') then
      tipo='frac'
      tcar(1:76)=card(5:80)
c lecturainterna
      read(tcar,*) a,b,c,alpha,beta,gamma
      call celda
      nort=1
      call ortho
            else
      tipo='orto'
      go to 30
            endif
         endif
20    read(i1,'(a)',end=70) card
30    if(card(1:4).ne.'ATOM') go to 20
      read(card,fmt=forml) atnam,xi,biso
c     if(atnam.ne.' CA '
c    . .and.atnam.ne.' C  '.and.atnam.ne.' N  '.and.atnam.ne.' O  '
c    . ) go to 20
      if(atnam(2:2).eq.'H'.or.atnam(2:2).eq.'D'.or.atnam(2:2).eq.'E'.or.
     . atnam(2:2).eq.'X'.or.atnam(1:1).eq.'H') go to 20
      carat(1:2)=atnam(1:2)
         if(tipo.ne.'orto') then
      do 50 i=1,3
      xo(i)=0.
      do 40 j=1,3
      xo(i)=xo(i)+ro(i,j)*xi(j)
40    continue
50    continue
      do 60 i=1,3
      xi(i)=xo(i)
60    continue
      biso=biso*8*pi**2
         endif
      return
70    last=.true.
      return
      end
"ENDOF lecatc.f"
#=======================================================================
echo lecfoq.f
cat >lecfoq.f <<"ENDOF lecfoq.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lecfoq(i1,nd,nr,nra,meq,hklo,hkl,hkls,mfo,pho,fob,hph,
     & foc,phase)
      implicit none
      integer h,hist,hkl,hklo,hkls,hs,i,i1,ibid1,ibid2,iecr,ilec,iout,
     & ir,is,isc,j,k,kprt,ks,l,ls,m,meq,mss,mu,mult,n,nd,neq,nh,nr,nra,
     & ntot,nts
      real a11,a21,a22,a31,a32,a33,bfact,corf,cori,corp,delf,dmax,dmaxo,
     & dmin,dmino,eli,fmax,fmin,fo,fob,hph,mfo,pctr,pho,rbid1,rfli,rfsq,
     & scale,sfli,sfqu,sfsq,sqh,sqhinf,sqhmax,sqhmin,sqhsup,sum,tfac,
     & tss,tts
      complex foc,unoi
      character cbid1*1,phase*1
      logical first
      parameter(nh=1001)
      dimension fob(2*nr),foc(nr),hist(0:nh),hkl(nr*(1+meq)),hklo(nd),
     & hkls(nr,meq),hph(nr),mfo(nd),pho(nd)
      common/ctlx/ pctr,fmin,fmax,tfac,ibid1
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/numo/ ntot,ibid2(6)
      common/pote/ sfli,sfsq,sfqu,rfli,rfsq,corf,cori,corp,scale,bfact
      common/reso/ dmaxo,dmino,dmax,dmin,rbid1(2)
      common/simt/ tss(3,48),tts(9),mss(3,3,48),neq,nts
      common/star/ a11,a21,a22,a31,a32,a33
      unoi=(0.,1.)
      nra=0
      ntot=0
      sqhmin=(1/dmaxo)**2
      sqhmax=(1/dmino)**2
      sfli=0.
      sfsq=0.
      sfqu=0.
      sqhinf=1.e20
      sqhsup=0.
      fmin=1.e20
      fmax=-1.e20
      first=.true.
10    read(i1,end=30) m,hklo,mfo,pho
      if(m.gt.nd) go to 901
      do 20 i=1,m
      call unpac4(h,k,l,mult,hklo(i))
         if(first) then
      mu=mult
      first=.false.
         else
            if(mult.ne.mu) then
      mu=mult
      write(iecr,'(a,4i5)') ' multiplicity mismatch =',mu,h,k,l
            endif
         endif
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.lt.sqhmin.or.sqh.gt.sqhmax) go to 20
      nra=nra+1
      if(nra.gt.nr) go to 902
      fo=mfo(i)
      if(tfac.ne.0.) fo=fo*exp(-tfac*sqh/4.)
      if(fo.lt.fmin) fmin=fo
      if(fo.gt.fmax) fmax=fo
      hkl(nra)=hklo(i)
      fob(nra)=fo
      hph(nra)=pho(i)
      foc(nra)=fo*cexp(unoi*pho(i))
20    continue
      go to 10
30    if(nra.le.0) go to 903
         if(pctr.lt.100.) then
      eli=nra*(100.-pctr)/100.
      delf=fmax-fmin
      sum=0.
      do 40 j=0,nh
      hist(j)=0
40    continue
      do 50 ir=1,nra
      j=nint(nh*(fob(ir)-fmin)/delf)
      hist(j)=hist(j)+1
50    continue
      do 60 j=0,nh
      if(sum.ge.eli) go to 70
      sum=sum+hist(j)
60    continue
70    fmin=j*delf/nh+fmin
         endif
      n=0
      do 90 i=1,nra
      fo=fob(i)
      if(nint(1000*fo/fmin).lt.1000.or.nint(1000*fo/fmax).gt.1000)
     . go to 90
      n=n+1
      call unpac4(h,k,l,mult,hkl(i))
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      ntot=ntot+mult
      sfli=sfli+mult*fo
      sfsq=sfsq+mult*fo*fo
      sfqu=sfqu+mult*fo**4
      if(sqh.lt.sqhinf) sqhinf=sqh
      if(sqh.gt.sqhsup) sqhsup=sqh
      do 80 is=1,neq
      hs=h*mss(1,1,is)+k*mss(2,1,is)+l*mss(3,1,is)
      ks=h*mss(1,2,is)+k*mss(2,2,is)+l*mss(3,2,is)
      ls=h*mss(1,3,is)+k*mss(2,3,is)+l*mss(3,3,is)
      call pac3(hs,ks,ls,hkls(n,is))
80    continue
      hkl(n)=hkl(i)
      fob(n)=fo
         if(phase.eq.'p') then
      hph(n)=hph(i)
         else
      hph(n)=sqh
         endif
      foc(n)=foc(i)
90    continue
      nra=n
      if(nra.le.0) go to 903
      dmaxo=sqrt(1/sqhinf)
      dmino=sqrt(1/sqhsup)
      if(kprt.ne.0) write(iecr,2010) nra,dmaxo,dmino,pctr,tfac,sfli,
     . sfsq,sfqu
      do 100 ir=1,nra
      fob(nra+ir)=hph(ir)
100   continue
      do 120 is=1,neq
      isc=nra*(is-1)
      do 110 ir=1,nra
      hkl(nra+isc+ir)=hkls(ir,is)
110   continue
120   continue
      return
901   write(iecr,3010) m,nd
      write(iout,3010) m,nd
      stop
902   write(iecr,3020) nra,nr
      write(iout,3020) nra,nr
      stop
903   write(iecr,3030)
      write(iout,3030)
      stop
2010  format(/' lecfoq.',i10,' reflections between',f10.3,' and',f10.3/
     . f10.0,'% of total present in that range.'/
     . ' fo = fob*exp(-b*hsq/4). b =',e15.5/
     . ' sum fo =',e15.5,', sum fosq =',e15.5,', sum foqu =',e15.5)
3010  format('stop >> lecfoq << m > nd =',2i10)
3020  format('stop >> lecfoq << nra > nr =',2i10)
3030  format('stop >> lecfoq << no reflection selected')
      end
"ENDOF lecfoq.f"
#=======================================================================
echo lecfos.f
cat >lecfos.f <<"ENDOF lecfos.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lecfos(i1,h,k,l,fo,pho,first,last)
      implicit none
      integer h,i,i1,iecr,ilec,iout,k,kprt,l
      real dtor,fo,pho,pi,rtod,twopi
      character card*80,cbid1*1,fase*5,forml*80,tipo*4
      logical first,last
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      save fase,forml,tipo
c las fases de entrada en grados
         if(first) then
      first=.false.
      rewind(unit=i1)
       do i=1,80
      forml(i:i)=' '
       enddo
10    read(i1,'(a)') card
      call compact(card)
      if(card(1:6).ne.'FORMAT') go to 10
            if(card(7:8).eq.'-I') then
      write(iecr,'(/a/)') ' reading H,K,L,Iob. Using Fob=sqrt(Iob)'
      tipo='iobs'
      forml(1:72)=card(9:80)
            else
      write(iecr,'(/a/)') ' reading H,K,L,Fob'
      tipo='fobs'
      forml(1:74)=card(7:80)
            endif
      read(i1,'(a)') card
            if(card(1:5).eq.'PHASE') then
      write(iecr,'(a/)') ' reading phases'
      fase='phase'
            else
      fase='sigma'
      pho=0.
      go to 30
            endif
         endif
20    read(i1,'(a)',end=40) card
30       if(fase.eq.'phase') then
      read(card,fmt=forml) h,k,l,fo,pho
      pho=pho*dtor
         else
      read(card,fmt=forml) h,k,l,fo
         endif
      if(fo.le.0.) go to 20
      if(tipo.eq.'iobs') fo=sqrt(fo)
      return
40    last=.true.
      return
      end
"ENDOF lecfos.f"
#=======================================================================
echo lecsim.f
cat >lecsim.f <<"ENDOF lecsim.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lecsim
      implicit none
      integer i,iecr,ilec,iout,j,kprt,mss,n,neq,nts
      real tss,tts
      character cbid1*1
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      call symcar
      if(kprt.ne.0) write(iecr,2010) neq,nts
      do 10 n=1,neq
      if(kprt.ne.0) write(iecr,2020) ((mss(i,j,n),j=1,3),tss(i,n),i=1,3)
10    continue
      do 20 n=1,nts
      if(kprt.ne.0) write(iecr,2030) (tts(i,n),i=1,3)
20    continue
      return
2010  format(/' space group.',i5,' equivalent positions and',i5,
     . ' centring translations')
2020  format(3(/3i5,f10.6))
2030  format(/3f10.6)
      end
"ENDOF lecsim.f"
#=======================================================================
echo lectab.f
cat >lectab.f <<"ENDOF lectab.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lectab(i1,hmax,kmax,lmax,ft)
      implicit none
      integer h,hmax,hsup,i1,iecr,ilec,iout,k,kmax,kprt,ksup,l,lmax,
     & lsup,nort
      real a,a11,a21,a22,a31,a32,a33,alpha,b,beta,c,dmax,dmaxo,dmin,
     & dmino,dsq,fuzz,gamma,rbid1,rbid2,rf,ro,sqh,sqhsup
      complex ft
      character cbid1*1
      dimension ft(-1:hmax,-kmax:kmax,-lmax:lmax)
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ortm/ ro(9),rf(9),nort
      common/reso/ dmaxo,dmino,dmax,dmin,rbid2(2)
      common/star/ a11,a21,a22,a31,a32,a33
      data fuzz/1.0001/
      rewind(unit=i1)
      read(i1) a,b,c,alpha,beta,gamma,nort,hsup,ksup,lsup,sqhsup
      call celda
      call ortho
      dsq=0.
      do 30 h=-1,1
      do 20 k=-1,1
      do 10 l=-1,1
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.dsq) dsq=sqh
10    continue
20    continue
30    continue
      dmin=1/(sqrt(sqhsup)-sqrt(dsq))
         if(kprt.ne.0) then
      write(iecr,*) ' '
      write(iecr,*) ' h,k,l limits for array =',hsup,ksup,lsup
      write(iecr,*) ' resolution limit for interpolation =',dmin
      write(iecr,*) ' dimension of array =',
     . (hsup+2)*(2*ksup+1)*(2*lsup+1)
         endif
      if(dmin/dmino.ge.fuzz) go to 901
      read(i1) ft
      return
901   write(iecr,3010) dmin,dmino
      write(iout,3010) dmin,dmino
      stop
3010  format('stop >> lectab << resolution mismatch =',2f10.3)
      end
"ENDOF lectab.f"
#=======================================================================
echo leesc.f
cat >leesc.f <<"ENDOF leesc.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine leesc(i1,o1,mx,my,mz,rr,scale)
      implicit none
      integer i,i1,il,iu,ixyz,ms,mx,mxy,mxyz,my,mz,ns,o1,xy
      real map,rr,scale,sigma,ss,sum1,sum2
      dimension rr(mx*my),ss(7)
      sum1=0.
      sum2=0.
      mxy=mx*my
      mxyz=mx*my*mz
      xy=0
      il=-6
       do ixyz=1,mxyz,7
      il=il+7
      iu=min(il+6,mxyz)
      ns=iu-il+1
      read(i1,*) (ss(i),i=1,ns)
      ms=mxy-xy
         if(ms.le.ns) then
        do i=1,ms
      map=ss(i)/scale
      sum1=sum1+map
      sum2=sum2+map**2
      rr(xy+i)=map
        enddo
      write(o1) rr
            if(ms.lt.ns) then
        do i=1,ns-ms
      map=ss(ms+i)/scale
      sum1=sum1+map
      sum2=sum2+map**2
      rr(i)=map
        enddo
            endif
      xy=ns-ms
         else
        do i=1,ns
      map=ss(i)/scale
      sum1=sum1+map
      sum2=sum2+map**2
      rr(xy+i)=map
        enddo
      xy=xy+ns
         endif
       enddo
      sum1=sum1/mxyz
      sum2=sum2/mxyz
      sigma=sqrt(sum2-sum1**2)
      write(6,'(a,2f15.5)') ' average , sigma =',sum1,sigma
      return
      end
"ENDOF leesc.f"
#=======================================================================
echo length.f
cat >length.f <<"ENDOF length.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function length(card)
      implicit none
      integer i,length
      character card*80
       do i=80,1,-1
      if(card(i:i).ne.' ') go to 10
       enddo
10    length=i
      return
      end
"ENDOF length.f"
#=======================================================================
echo lgauss.f
cat >lgauss.f <<"ENDOF lgauss.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lgauss(uat)
      implicit none
      integer i,ie,iecr,ilec,iout,kprt,mgaus,n,ngaus,ntype,uat
      real ct,emax,et,gauss
      character card*80,cbid1*1,keyid*4
      common/atype/ gauss(30,300),ngaus,ntype
      common/ctype/ keyid(300)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
c los coeficientes estan escritos por pares (a(n),b(n)),
c correspondientes a la formula, f(s) = sum(n) (a(n)*exp(-b(n)*s**2)).
c el termino constante (si hay) debe ser el ultimo.
      ngaus=9
       do n=1,300
        do i=1,30
      gauss(i,n)=0.
        enddo
       enddo
      ntype=0
10    read(uat,'(a)',end=20) card
      ntype=ntype+1
      keyid(ntype)=card(1:4)
      read(uat,*) (gauss(i,ntype),i=1,ngaus)
      go to 10
20    mgaus=(ngaus+1)/2
       do n=1,ntype
      ie=1
      emax=gauss(2,n)
        do i=1,mgaus
         if(gauss(2*i,n).gt.emax) then
      ie=i
      emax=gauss(2*ie,n)
         endif
        enddo
         if(ie.ne.1) then
      ct=gauss(1,n)
      et=gauss(2,n)
      gauss(1,n)=gauss(2*ie-1,n)
      gauss(2,n)=gauss(2*ie,n)
      gauss(2*ie-1,n)=ct
      gauss(2*ie,n)=et
         endif
       enddo
      write(iecr,2010) ntype
       do n=1,ntype
      keyid(n)(3:4)='  '
       enddo
      return
2010  format(/i5,' form factors available (first two characters used).')
      end
"ENDOF lgauss.f"
#=======================================================================
echo lisec.f
cat >lisec.f <<"ENDOF lisec.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lisec(i1,mxy,rr,first,last)
      implicit none
      integer i,i1,il,iu,ixy,j,len,lm,ml,mxy
      real line,rr
      logical first,last
      parameter(len=7)
      dimension line(len),rr(mxy)
      save il,iu,line,lm,ml
         if(first) then
      first=.false.
      ml=len
      lm=len
      ixy=1
         else
            if(lm.ne.len) then
        do i=1,len-lm
      rr(i)=line(i+lm)
        enddo
            endif
      ixy=1+len-lm
         endif
      il=1-lm
       do j=ixy,mxy,len
      il=il+len
      iu=min(il+len-1,mxy)
      lm=iu-il+1
      if(last) ml=lm
      read(i1,*) (line(i),i=1,ml)
        do i=il,iu
      rr(i)=line(i-il+1)
        enddo
       enddo
      return
      end
"ENDOF lisec.f"
#=======================================================================
echo lsqfit.f
cat >lsqfit.f <<"ENDOF lsqfit.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lsqfit(lxy,qxy)
      implicit none
      integer i,iecr,ierr,ilec,iout,j,k,kprt,kprtt
      real al,be,det,ga,lxy,mat,qmx,qxy,rms,rmx,rr,t,trx,val
      double precision som,sum
      character cbid1*1
      dimension lxy(6),mat(3,3),qmx(3,3),qxy(6,6),rmx(3,3),rr(6),trx(3),
     & val(3)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/oprt/ kprtt(10)
      kprt=kprtt(1)
       do i=1,3
        do j=1,3
      sum=0.d0
         do k=1,3
      sum=sum+qxy(i,3+k)*qxy(3+k,j)
         enddo
      qmx(i,j)=sum
        enddo
       enddo
      call rs(3,3,qmx,val,mat,rr(1),rr(4),1,ierr)
      call det3(mat,det)
      t=sign(1.,det)
      sum=0.d0
       do i=1,3
      mat(i,1)=mat(i,1)*t
      sum=sum+qxy(i,i)+qxy(3+i,3+i)-2*sqrt(val(i))
       enddo
      if(sum.gt.0.d0) sum=sqrt(sum)
      rms=sum
      call det3(mat,det)
         if(kprt.ne.0) then
      write(iecr,'(/a,e15.5)') ' determinant',det
      write(iecr,'(/a,3e15.5)') ' eigenvalues',(val(i),i=1,3)
         endif
       do i=1,3
      val(i)=sqrt(1/val(i))
       enddo
       do i=1,3
        do j=1,3
      sum=0.d0
         do k=1,3
      sum=sum+mat(i,k)*val(k)*mat(j,k)
         enddo
      qmx(i,j)=sum
        enddo
       enddo
       do i=1,3
      som=0.d0
        do j=1,3
      sum=0.d0
         do k=1,3
      sum=sum+qxy(3+i,k)*qmx(k,j)
         enddo
      som=som+sum*lxy(j)
      rmx(i,j)=sum
        enddo
      trx(i)=lxy(3+i)-som
       enddo
      call det3(rmx,det)
      write(iecr,'(/a,f15.5)') ' rms = sqrt(<[y-(M.x+T)]^2>) =',rms
      write(iecr,'(/a,f15.5)') ' determinant',det
      write(iecr,'(a,3(/3f15.5))') ' matrix M',((rmx(i,j),j=1,3),i=1,3)
      write(iecr,'(a/3f15.3)') ' translation T',(trx(i),i=1,3)
         if(det.lt.0.) then
       do i=1,3
        do j=1,3
      rmx(i,j)=-rmx(i,j)
        enddo
       enddo
         endif
      kprt=0
      call lsqmx(rmx,mat)
      call rmx2e(mat,al,be,ga)
         if(det.lt.0.) then
      write(iecr,'(/a,6f8.2)') ' transformation (-M,T) =',al,be,ga,trx
         else
      write(iecr,'(/a,6f8.2)') ' transformation (+M,T) =',al,be,ga,trx
         endif
      return
      end
"ENDOF lsqfit.f"
#=======================================================================
echo lsqmx.f
cat >lsqmx.f <<"ENDOF lsqmx.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lsqmx(r1,r2)
      implicit none
      integer i,ierr,j,k
      real mat,r1,r2,r3,rr,val
      double precision sum
      dimension mat(3,3),r1(3,3),r2(3,3),r3(3,3),rr(6),val(3)
       do i=1,3
        do j=1,3
      sum=0.d0
         do k=1,3
      sum=sum+r1(i,k)*r1(j,k)
         enddo
      r3(i,j)=sum
        enddo
       enddo
      call rs(3,3,r3,val,mat,rr(1),rr(4),1,ierr)
       do i=1,3
      val(i)=sqrt(1/val(i))
       enddo
       do i=1,3
        do j=1,3
      sum=0.d0
         do k=1,3
      sum=sum+mat(i,k)*val(k)*mat(j,k)
         enddo
      r3(i,j)=sum
        enddo
       enddo
       do i=1,3
        do j=1,3
      sum=0.d0
         do k=1,3
      sum=sum+r3(i,k)*r1(k,j)
         enddo
      r2(i,j)=sum
        enddo
       enddo
      return
      end
"ENDOF lsqmx.f"
#=======================================================================
echo lungo.f
cat >lungo.f <<"ENDOF lungo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function lungo(card,nfield)
      implicit none
      integer i,lungo,nfield
      character card*1
      dimension card(nfield)
       do i=nfield,1,-1
      if(card(i).ne.' ') go to 10
       enddo
10    lungo=i
      return
      end
"ENDOF lungo.f"
#=======================================================================
echo lwtab4i.f
cat >lwtab4i.f <<"ENDOF lwtab4i.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lwtab4i(i1,hmax,kmax,lmax,ft,o1,hsup,ksup,lsup,ftab)
      implicit none
      integer h,hmax,hsup,i1,iecr,ilec,iout,k,kmax,kprt,ksup,l,lmax,
     & lsup,o1
      real a11,a21,a22,a31,a32,a33,dmin,dsq,rbid1,rbid2,sqh,sqhmax
      complex ft,ftab
      character cbid1*1
      dimension ft(-1:hmax,-kmax:kmax,-lmax:lmax),
     & ftab(-hsup:hsup,-ksup:ksup,-lsup:lsup)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/reso/ rbid1,dmin,rbid2(4)
      common/star/ a11,a21,a22,a31,a32,a33
      dsq=0.
       do h=-1,1
        do k=-1,1
         do l=-1,1
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.dsq) dsq=sqh
         enddo
        enddo
       enddo
      sqhmax=1/dmin**2
      dmin=1/(sqrt(sqhmax)-sqrt(dsq))
c     write(iecr,*) ' '
c     write(iecr,*) ' h,k,l limits for array =',hsup,ksup,lsup
c     write(iecr,*) ' resolution limit for interpolation =',dmin
c     write(iecr,*) ' dimension of array =',
c    . (2*hsup+1)*(2*ksup+1)*(2*lsup+1)
      read(i1) ft
       do l=-lsup,lsup
        do k=-ksup,ksup
         do h=0,hsup
      ftab(h,k,l)=ft(h,k,l)
      ftab(-h,-k,-l)=conjg(ft(h,k,l))
         enddo
        enddo
       enddo
      write(o1) ftab
      return
      end
"ENDOF lwtab4i.f"
#=======================================================================
echo lwudi4i.f
cat >lwudi4i.f <<"ENDOF lwudi4i.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lwudi4i(i1,o1,nd,nr,hklo,mfo,pho,hkl,foc)
      implicit none
      integer h,hkl,hklo,i,i1,iecr,ilec,ind,iout,k,kprt,l,m,mult,nd,nr,
     & nra,o1
      real a,a11,a21,a22,a31,a32,a33,alpha,b,beta,c,dmaxo,dmino,fo,
     & gamma,mfo,phi,pho,rbid1,rbid2,sqh,sqhmax,sqhmin
      complex foc,unoi
      character cbid1*1
      dimension foc(nr),hkl(3*nr),hklo(nd),mfo(nd),pho(nd)
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/reso/ dmaxo,dmino,rbid2(4)
      common/star/ a11,a21,a22,a31,a32,a33
      unoi=(0.,1.)
      nra=0
      sqhmin=(1/dmaxo)**2
      sqhmax=(1/dmino)**2
10    read(i1,end=30) m,hklo,mfo,pho
      if(m.gt.nd) go to 901
      do 20 i=1,m
      call unpac4(h,k,l,mult,hklo(i))
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.sqhmax) go to 20
      nra=nra+1
      if(nra.gt.nr) go to 902
      call pac3(h,k,l,ind)
      fo=mfo(i)
      phi=pho(i)
      hkl(nra)=ind
      foc(nra)=fo*cexp(unoi*phi)
20    continue
      go to 10
30    if(nra.le.0) go to 903
      write(o1) nra,a,b,c,alpha,beta,gamma
       do i=1,nra
      call unpac3(h,k,l,hkl(i))
      hkl(i)=h
      hkl(i+nra)=k
      hkl(i+2*nra)=l
       enddo
      write(o1) nra,(hkl(i),i=1,3*nra),(foc(i),i=1,nra)
      return
901   write(iecr,3010) m,nd
      write(iout,3010) m,nd
      stop
902   write(iecr,3020) nra,nr
      write(iout,3020) nra,nr
      stop
903   write(iecr,3030)
      write(iout,3030)
      stop
3010  format('stop >> lwudi4i << m > nd =',2i10)
3020  format('stop >> lwudi4i << nra > nr =',2i10)
3030  format('stop >> lwudi4i << no reflection selected')
      end
"ENDOF lwudi4i.f"
#=======================================================================
echo mapin.f
cat >mapin.f <<"ENDOF mapin.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine mapin(i1,mx,my,rr)
      implicit none
      integer i,i1,ibid1,ibid2,iecr,ilec,iout,ix,ixlw,ixup,iy,iz,j,k,
     & kfac,kiso,kprt,kprtt,l,mgrid,mss,mtab,mx,mxyz,my,nat,nc,neq,
     & ngrid,nort,nts,nx,ny,nz
      real a,alpha,amax,amin,avge,b,beta,bfac,biso,box,boxm,c,cel,cm,cx,
     & dimt,dmax,dmin,dsmax,dsmin,fuzz,gamma,map,mass,maxm,minm,pas,qm,
     & qx,rbid1,rbid2,rbid3,rf,rmin,ro,rot,rr,sharat,smax,smin,step,
     & traz,tss,tts,val,xc,xlow,xlw,xmap,xsup,xup,yc,ymap,zc,zmap
      character cbid1*1
      logical test
      dimension cel(3),cx(3),mgrid(3),ngrid(3),qm(3,3),qx(3,3),
     & rr(mx,my),step(3),xlw(3),xup(3)
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/dfftx/ xlow(3),xsup(3),ixlw(3),ixup(3)
      common/fozo/ rbid2(2),bfac,ibid1
      common/grid/ ibid2(3),nx,ny,nz
      common/histo/ nc
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/oprt/ kprtt(20)
      common/ortm/ ro(3,3),rf(3,3),nort
      common/outab/ boxm(3),rmin,cm(3),rot(3),val(6),dimt,nat,mtab
      common/reso/ dmax,dmin,rbid3(2),dsmin,dsmax
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      fuzz=0.15
      test=.true.
      rewind(unit=i1)
      read(i1) mgrid,xlow,xsup,alpha,beta,gamma
      neq=1
      nts=0
      nort=1
      do 20 i=1,3
      cm(i)=0.
      rot(i)=0.
      tss(i,1)=0.
      tts(i,1)=0.
      do 10 j=1,3
      qm(i,j)=0.
         if(j.eq.i) then
      mss(i,j,1)=1
         else
      mss(i,j,1)=0
         endif
10    continue
20    continue
      read(ilec,*) kiso,biso
      read(ilec,*) dmax,dmin,nc
      read(ilec,*) box,sharat,kfac,bfac
      pas=1.e20
      do 30 i=1,3
      boxm(i)=xsup(i)-xlow(i)
      mxyz=box*(mgrid(i)-1)
      call contrg(mxyz,i)
      ngrid(i)=mxyz
      cel(i)=ngrid(i)*boxm(i)/(mgrid(i)-1)
      xlw(i)=xlow(i)/cel(i)
      xup(i)=xsup(i)/cel(i)
      ixlw(i)=nint(ngrid(i)*xlw(i))
      ixup(i)=ixlw(i)+mgrid(i)-1
      step(i)=(xsup(i)-xlow(i))/(ixup(i)-ixlw(i))
         if(pas.ge.step(i)) then
      pas=step(i)
      j=i
         endif
30    continue
       do i=1,3
      if(abs(step(i)-pas)/pas.gt.1.e-1) test=.false.
       enddo
      sharat=dmin*(box*mgrid(j)-2)/(2*box*boxm(j))
      dsmin=dmin/sharat
      if(sharat.lt.1.5) test=.false.
      if(.not.test) go to 901
      nx=ngrid(1)
      ny=ngrid(2)
      nz=ngrid(3)
      a=cel(1)
      b=cel(2)
      c=cel(3)
      call celda
      call setpak
      call ortho
      if(kprt.ne.0) write(iecr,2010) xlow,xsup,mgrid,dsmin,sharat,ngrid
      if(kprt.ne.0) write(iecr,2020)
      kprt=kprtt(2)
      smin=1.e20
      smax=-1.e20
      amin=0.
      amax=0.
      mass=0.
      do 60 iz=ixlw(3),ixup(3)
      zc=xlow(3)+(iz-ixlw(3))*step(3)
      read(i1) rr
      minm=1.e20
      maxm=-1.e20
      avge=0.
      do 50 iy=1,my
      yc=xlow(2)+(iy-1)*step(2)
      do 40 ix=1,mx
      xc=xlow(1)+(ix-1)*step(1)
      map=rr(ix,iy)
      if(map.lt.minm) minm=map
      if(map.gt.maxm) maxm=map
      avge=avge+map
         if(map.gt.0.) then
      xmap=map*xc
      ymap=map*yc
      zmap=map*zc
      mass=mass+map
      cm(1)=cm(1)+xmap
      cm(2)=cm(2)+ymap
      cm(3)=cm(3)+zmap
      qm(1,1)=qm(1,1)+xmap*xc
      qm(1,2)=qm(1,2)+xmap*yc
      qm(1,3)=qm(1,3)+xmap*zc
      qm(2,2)=qm(2,2)+ymap*yc
      qm(2,3)=qm(2,3)+ymap*zc
      qm(3,3)=qm(3,3)+zmap*zc
         endif
40    continue
50    continue
      avge=avge/(nx*ny)
      if(kprt.ne.0) write(iecr,'(i10,3e15.5)') iz,minm,maxm,avge
      if(minm.lt.smin) smin=minm
      if(maxm.gt.smax) smax=maxm
      amin=amin+minm
      amax=amax+maxm
60    continue
      kprt=kprtt(1)
      amin=amin/nz
      amax=amax/nz
      if(kprt.ne.0) write(iecr,2030) smin,smax,amin,amax
      do 70 i=1,3
      ixlw(i)=nint((xlow(i)-cm(i)/mass)/step(i)+ngrid(i)/2.)
      ixup(i)=ixlw(i)+mgrid(i)-1
      if(ixlw(i).lt.0.or.ixup(i).ge.ngrid(i)) go to 902
70    continue
      do 90 i=1,3
      cx(i)=cm(i)/(cel(i)*mass)
      do 80 j=1,3
      qx(i,j)=(qm(i,j)/cel(i)-cx(i)*cm(j))/(cel(j)*mass)
80    continue
90    continue
      traz=0.
      do 130 i=1,3
      cm(i)=0.
      do 120 j=1,3
      qm(i,j)=0.
      cm(i)=cm(i)+ro(i,j)*cx(j)
      do 110 k=1,3
      do 100 l=1,3
      qm(i,j)=qm(i,j)+ro(i,k)*ro(j,l)*qx(k,l)
100   continue
110   continue
120   continue
      traz=traz+qm(i,i)
      val(i)=qm(i,i)
130   continue
      val(4)=qm(1,2)
      val(5)=qm(1,3)
      val(6)=qm(2,3)
      rmin=sqrt(traz*3.)
      return
901   write(iecr,3010) step,dsmin*1.5
      write(iout,3010) step,dsmin*1.5
      stop
902   write(iecr,3020) ixlw,ixup
      write(iout,3020) ixlw,ixup
      stop
2010  format(/' model electron density box'/
     . ' lower limits =',3f10.3/' upper limits =',3f10.3/
     . ' sampling of model box edges =',3i10/
     . ' grid resolution =',f10.3,' ; Shannon-rate =',f10.3/
     . ' divisions of unit cell edges =',3i10)
2020  format(/'   z-sect.        minimum        maximum     avg. value')
2030  format(/' absolute min and max =',2e15.5/
     . ' average min and max =',2e15.5)
3010  format('stop >> mapin << sampling and resolution mismatch'/
     . ' the spacings should be similar =',3f10.5/
     . ' maximal allowed resolution =',f10.5)
3020  format('stop >> mapin << wrong grid indices =',6i10)
      end
"ENDOF mapin.f"
#=======================================================================
echo mdftkd.f
cat >mdftkd.f <<"ENDOF mdftkd.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine mdftkd(x,y,n,dim,factor)
      implicit none
      integer dim,f,factor,iecr,ilec,iout,kprt,m,n,p,r,s
      real x,y
      character cbid1*1
      dimension dim(*),factor(*),x(*),y(*)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      s=dim(2)
      f=0
      m=n
10    f=f+1
      p=factor(f)
      if(p.eq.0) go to 20
      m=m/p
      r=m*s
         if(p.eq.1) then
      go to 10
         else if(p.eq.2) then
      call r2cftk(x(1),y(1),x(r+1),y(r+1),n,m,dim)
         else if(p.eq.3) then
      call r3cftk(n,m,x(1),y(1),x(r+1),y(r+1),x(2*r+1),y(2*r+1),dim)
         else if(p.eq.4) then
      call r4cftk(n,m,x(1),y(1),x(r+1),y(r+1),x(2*r+1),y(2*r+1),
     . x(3*r+1),y(3*r+1),dim)
         else if(p.eq.5) then
      call r5cftk(n,m,x(1),y(1),x(r+1),y(r+1),x(2*r+1),y(2*r+1),
     . x(3*r+1),y(3*r+1),x(4*r+1),y(4*r+1),dim)
         else if(p.eq.8) then
      call r8cftk(n,m,x(1),y(1),x(r+1),y(r+1),x(2*r+1),y(2*r+1),
     . x(3*r+1),y(3*r+1),x(4*r+1),y(4*r+1),x(5*r+1),y(5*r+1),
     . x(6*r+1),y(6*r+1),x(7*r+1),y(7*r+1),dim)
         else
      go to 901
         endif
      go to 10
20    return
901   write(iecr,3010)
      write(iout,3010)
      stop
3010  format('stop >> mdftkd << transfer error')
      end
"ENDOF mdftkd.f"
#=======================================================================
echo mintab.f
cat >mintab.f <<"ENDOF mintab.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine mintab(o1,hmax,kmax,lmax,hsup,ksup,lsup,sqhsup,fti,fto)
      implicit none
      integer h,hmax,hsup,is,k,kmax,ksup,l,lmax,lsup,mc,nc,nort,nshe,o1,
     & o2
      real a,a11,a21,a22,a31,a32,a33,alpha,b,beta,c,dmax,dmin,dr,dsq,er,
     & fo,gamma,his,rbid1,rbid2,rbid3,ri,ro,spct,sqh,sqhsup
      complex fti,fto
      parameter(mc=100)
      dimension fti(-1:hmax,-kmax:kmax,-lmax:lmax),
     & fto(-1:hsup,-ksup:ksup,-lsup:lsup),his(3,mc)
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/histo/ nc
      common/ortm/ rbid2(18),nort
      common/reso/ dmax,dmin,rbid3(4)
      common/star/ a11,a21,a22,a31,a32,a33
      data o2/7/
      sqh=0
      if(hsup.eq.hmax.and.ksup.eq.kmax.and.lsup.eq.lmax) go to 40
      do 30 l=-lsup,lsup
      do 20 k=-ksup,ksup
      do 10 h=-1,hsup
      fto(h,k,l)=fti(h,k,l)
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
10    continue
20    continue
30    continue
40    rewind(unit=o1)
      write(o1) a,b,c,alpha,beta,gamma,nort,hsup,ksup,lsup,sqhsup
      write(o1) fto
      if(nc.gt.mc) nc=mc
      dsq=0
       do h=-1,1
        do k=-1,1
         do l=-1,1
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.dsq) dsq=sqh
         enddo
        enddo
       enddo
      dmin=1/(sqrt(sqhsup)-sqrt(dsq))
      er=3./2.
      ri=(1/dmax)**er
      ro=(1/dmin)**er
      dr=(ro-ri)/(nc-1)
       do is=1,nc
      his(1,is)=(ri+dr*(is-1))**(2./er)
      his(2,is)=0
      his(3,is)=0
       enddo
      nshe=nc-1
       do l=-lsup,lsup
        do k=-ksup,ksup
         do h=0,hsup
         if(h.eq.0.and.(k.gt.0.or.(k.eq.0.and.l.gt.0))) then
      fo=fto(h,k,l)
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
          do is=1,nshe
            if(sqh.ge.his(1,is).and.sqh.lt.his(1,is+1)) then
      his(2,is)=his(2,is)+fo**2
      his(3,is)=his(3,is)+1
            endif
          enddo
         endif
         enddo
        enddo
       enddo
      open(unit=o2,file='HISTT',form='formatted',status='unknown')
       do is=1,nshe
      sqh=(sqrt(his(1,is+1))+sqrt(his(1,is)))/2
      spct=0
      if(his(3,is).ne.0) spct=log(his(2,is)/his(3,is))
      write(o2,'(f7.1,a,f7.1,3f10.5,i10)') sqrt(1/his(1,is)),' -',
     . sqrt(1/his(1,is+1)),spct,sqh,1/sqh,nint(his(3,is))
       enddo
      return
      end
"ENDOF mintab.f"
#=======================================================================
echo multes.f
cat >multes.f <<"ENDOF multes.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine multes(h,k,l,mult,ires)
      implicit none
      integer h,hh,hkl,iecr,iind,ilec,ind,indo,iout,ires,k,kk,kprt,l,ll,
     & m,mss,mult,n,neq,nts
      real pr,tss,tts
      character cbid1*1
      logical first,primo
      dimension hkl(48)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/simt/ tss(3,48),tts(9),mss(3,3,48),neq,nts
      data first/.true./
      save indo,primo
         if(first) then
      call pac3(0,0,0,indo)
      first=.false.
      primo=.true.
         endif
      if(h.lt.0) go to 901
      call pac3(h,k,l,ind)
         if(ind.eq.indo) then
      mult=1
      ires=1
      go to 40
         endif
      mult=0
      ires=0
      do 30 n=1,neq
      hh=h*mss(1,1,n)+k*mss(2,1,n)+l*mss(3,1,n)
      kk=h*mss(1,2,n)+k*mss(2,2,n)+l*mss(3,2,n)
      ll=h*mss(1,3,n)+k*mss(2,3,n)+l*mss(3,3,n)
         if(hh.eq.-h.and.kk.eq.-k.and.ll.eq.-l) then
      pr=mod(h*tss(1,n)+k*tss(2,n)+l*tss(3,n),1.)
      ires=1+mod(12+nint(12*pr),12)
         endif
c pacote
         if(hh.lt.0.or.(hh.eq.0.and.(ll.gt.0.or.(ll.eq.0.and.kk.gt.0))))
     . then
      hh=-hh
      kk=-kk
      ll=-ll
         endif
      call pac3(hh,kk,ll,iind)
         if(primo.and.iind.lt.ind) then
      if(kprt.ne.0) write(iecr,3001)
      primo=.false.
         endif
      if(n.eq.1) go to 20
      do 10 m=1,mult
      if(hkl(m).eq.iind) go to 30
10    continue
20    mult=mult+1
      hkl(mult)=iind
30    continue
      mult=mult*2
40    return
901   write(iecr,3010)
      write(iout,3010)
      stop
3001  format(/' >> warning << data is not optimally sorted')
3010  format('stop >> multes << reflection out of order')
      end
"ENDOF multes.f"
#=======================================================================
echo ncsrms.f
cat >ncsrms.f <<"ENDOF ncsrms.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program ncsrms
      implicit none
      integer bod,body,i,i0,i1,i2,id,iecr,ilec,incs,indi,ine,ins,iout,
     & irun,kprt,length,lungo,m,mf,mm,n,nbody,ncm,ncs,nlungo,nmol,nort,
     & nrun,num,seed,tbod
      real a,al,alpha,b,be,beta,c,cosx,dtor,dtx,dty,dtz,eps,ga,gamma,ph,
     & pi,qa,qd,qq,qr,qt,r0,r1,r2,ran0,rbid1,rf,rms,rms2,rmsmeps,
     & rmspeps,ro,rtod,ten,th,tmax,tmin,twopi,tx,ty,tz,u,xhi
      character card*80,cart*4000,crmsq*1,forme*40,formr*40,tcar*4000,
     & zn*1
      logical fix,run
      external lungo,ran0,length
      parameter(ncm=1000)
      dimension body(200),cart(200),i0(100),incs(ncm),qq(3,3,100),r0(9),
     & r1(9),r2(9),ten(6),u(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ortm/ ro(3,3),rf(3,3),nort
      data i0/100*0/,qq/900*0./,nlungo/4000/
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      kprt=0
      iout=9
      formr='(2x,i2,       3f7.1,3f8.4,  1x,4f6.1   )'
      forme='(1x,a1,i2,    3f7.1,3f8.4,  1x,401i4   )'
      zn='#'
      i1=1
      i2=2
      id=8
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call abra(id,'f','u',0)
      rewind(unit=id)
      read(id,*)
      read(id,*) a,b,c,alpha,beta,gamma
      call celda
10    read(id,'(a)') card
      ine=index(card,'e')
      ins=index(card,'s')
      if(ine.lt.1.and.ins.lt.1) go to 10
      read(id,*) nort
      call ortho
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call abra(i2,'f','u',0)
      rewind(unit=i2)
      read(i2,*) seed
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      write(iecr,'(a)')' Input list of independent molecules:'
      call abra(i1,'f','u',0)
      rewind(unit=i1)
      read(i1,*)
      read(i1,*)
      n=0
20    read(i1,'(a)',end=30) tcar
      n=n+1
      cart(200-n)=tcar
      indi=index(tcar,'#')
      tcar(indi:indi)=' '
      read(tcar,*) bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      write(iecr,forme) zn,bod,al,be,ga,tx,ty,tz,ncs
         if(i0(bod).eq.0) then
      tbod=bod+10
      i0(bod)=1
      call abra(tbod,'f','u',0)
      rewind(unit=tbod)
       do i=1,8
      read(tbod,*)
       enddo
      read(tbod,'(17x,6f9.2)') ten
      qq(1,1,bod)=ten(1)
      qq(1,2,bod)=ten(4)
      qq(1,3,bod)=ten(5)
      qq(2,1,bod)=ten(4)
      qq(2,2,bod)=ten(2)
      qq(2,3,bod)=ten(6)
      qq(3,1,bod)=ten(5)
      qq(3,2,bod)=ten(6)
      qq(3,3,bod)=ten(3)
      call cierre(tbod,'f')
         endif
      go to 20
30    nmol=n
      write(iecr,'(a,i3)')' Number of independent molecules:',nmol
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
40    write(iecr,'(2a/a)') ' Enter the positions in the input list',
     . ' of the molecules to move:',
     . ' (<enter> for selecting all the molecules)'
      read(ilec,'(a)') card
      call compact(card)
         if(length(card).eq.0) then
       do n=1,nmol
      body(n)=n
       enddo
      nbody=nmol
         else
      n=0
50          if(length(card).gt.0) then
      n=n+1
      read(card,*) body(n)
               if(body(n).gt.nmol) then
      write(iecr,'(a)') ' Wrong position'
      go to 40
               endif
      indi=index(card,' ')
       do i=1,indi
      card(i:i)=' '
       enddo
      call compact(card)
      go to 50
            endif
      nbody=n
         endif
      mf=0
      mm=nmol-nbody
       do m=1,nmol
      fix=.true.
        do n=1,nbody
      if(body(n).eq.m) fix=.false.
        enddo
         if(fix) then
      mf=mf+1
      cart(mf)=cart(200-m)
         else
      mm=mm+1
      cart(mm)=cart(200-m)
         endif
       enddo
         if(nmol-nbody.gt.0) then
      write(iecr,'(a,i3)') ' Unchanged molecules:',nmol-nbody
       do n=1,nmol-nbody
      tcar=cart(n)
      indi=index(tcar,'#')
      tcar(indi:indi)=' '
      read(tcar,*) bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      write(iecr,forme) zn,bod,al,be,ga,tx,ty,tz,ncs
       enddo
         endif
      write(iecr,'(a,i3)') ' Molecules to move:',nbody
       do n=nmol-nbody+1,nmol
      tcar=cart(n)
      indi=index(tcar,'#')
      tcar(indi:indi)=' '
      read(tcar,*) bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      write(iecr,forme) zn,bod,al,be,ga,tx,ty,tz,ncs
      qr=sqrt(4.*(qq(1,1,bod)+qq(2,2,bod)))
      write(iecr,'(a,f10.2)') ' Maximal rotational rms:',qr
       enddo
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      write(iecr,'(a)') ' Enter a rms shift value:'
      read(ilec,*) rms
      run=.true.
       do while(run)
      write(iecr,'(a,3(/a))')
     . 'Enter which type of transformation should be applied:',
     . '  [R] Rotation',
     . '  [T] Translation',
     . '  [A] Rotation+translation'
      read(ilec,'(a)') card
         if((card(1:1).ne.'R').and.(card(1:1).ne.'r').and.
     . (card(1:1).ne.'T').and.(card(1:1).ne.'t').and.
     . (card(1:1).ne.'A').and.(card(1:1).ne.'a')) then
      write(iecr,'(a)') ' Option not valid'
         else
      read(card,'(a)') crmsq
      run=.false.
         endif
       enddo
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      write(iecr,'(a)') ' Enter number of random trials:'
      read(ilec,*) nrun
      rms2=rms*rms
      rmsmeps=rms2-rms
      rmspeps=rms2+rms
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      write(tcar,'(3a,f10.3,a,i3)') ' r-m-s shift [',crmsq,']:',rms,
     . ' Number of trials:',nrun
      write(iecr,'(a)') tcar(1:lungo(tcar,nlungo))
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
c the first one is taken as reference
      call abra(iout,'f','u',0)
      rewind(unit=iout)
      write(iout,'(3a,f8.3)') 'fiting: * r-m-s shift [',crmsq,']: ',rms
      write(iout,'(2i5)') nmol,-nbody
        do n=1,nmol
      tcar=cart(n)
      indi=index(tcar,'#')
      tcar(indi:indi)=' '
      read(tcar,*) bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      write(iout,forme) zn,bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
        enddo
c~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       do irun=1,nrun
      write(iout,'(2i5)') nmol,1
        do n=1,nmol-nbody
      tcar=cart(n)
      indi=index(tcar,'#')
      tcar(indi:indi)=' '
      read(tcar,*) bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      write(iout,forme) zn,bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
        enddo
        do n=nmol-nbody+1,nmol
      tcar=cart(n)
      indi=index(tcar,'#')
      tcar(indi:indi)=' '
      read(tcar,*) bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
c.....Rotation..........................................................
         if(crmsq.eq.'R'.or.crmsq.eq.'r') then
      call rmxe(al,be,ga,r0)
      num=0
      if(rms2.gt.4.*(qq(1,1,bod)+qq(2,2,bod))) num=10000
         do while(num.lt.10000)
      num=num+1
      th=pi*ran0(seed)
      ph=twopi*ran0(seed)
      u(1)=sin(th)*cos(ph)
      u(2)=sin(th)*sin(ph)
      u(3)=cos(th)
      call rtmsq(qq(1,1,bod),u,qr)
            if(2.*qr.gt.rms2) then
      cosx=1.-rms2/qr
      xhi=acos(cosx)*rtod
      call rmxp(xhi,u,r1)
      call pro2mx(r2,r0,r1)
      call rmx2e(r2,al,be,ga)
      write(iout,forme) zn,bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      num=20000
            endif
         enddo
            if(num.eq.10000) then
      u(1)=0.
      u(2)=0.
      u(3)=1.
      call rtmsq(qq(1,1,bod),u,qr)
      write(iecr,'(a,i2,a,f10.3)') ' >>> Warning <<< molecule #',n,
     . ' rms changed to maximal allowed value:',sqrt(2.*qr)
      if(rms2.le.2.*qr) write(iecr,'(a)')
     . ' Number of iterations exceeded'
      xhi=180.
      call rmxp(xhi,u,r1)
      call pro2mx(r2,r0,r1)
      call rmx2e(r2,al,be,ga)
      write(iout,forme) zn,bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
            endif
c.....Translation.......................................................
         else if(crmsq.eq.'T'.or.crmsq.eq.'t') then
      tmax=1.
      tmin=-1.
      num=0
         do while(num.lt.10000)
      num=num+1
      dtx=tmin+(tmax-tmin)*ran0(seed)
      dty=0.
      dtz=0.
      call trmsq(dtx,dty,dtz,ro,qt)
            if(qt.lt.rms2) then
      eps=sqrt(abs(a*a*dtx*dtx-rms2-rms))/b
      dty=-eps+2*eps*ran0(seed)
      call trmsq(dtx,dty,dtz,ro,qt)
               if(qt.lt.rms2) then
      eps=sqrt(rms2-a*a*dtx*dtx+b*b*dty*dty)/c
      dtz=-eps+2*eps*ran0(seed)
      call trmsq(dtx,dty,dtz,ro,qt)
                  if((qt.gt.rmsmeps).and.(qt.lt.rmspeps)) then
      tx=tx+dtx
      ty=ty+dty
      tz=tz+dtz
      write(iout,forme) zn,bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      num=20000
                  endif
               endif
            endif
         enddo
c.....Rotation+Translation..............................................
         else if(crmsq.eq.'A'.or.crmsq.eq.'a') then
      call rmxe(al,be,ga,r0)
      num=0
         do while(num.lt.10000)
      num=num+1
      th=pi*ran0(seed)
      ph=twopi*ran0(seed)
      u(1)=sin(th)*cos(ph)
      u(2)=sin(th)*sin(ph)
      u(3)=cos(th)
      call rtmsq(qq(1,1,bod),u,qr)
      xhi=pi*ran0(seed)
      qa=(1.-cos(xhi))*qr
            if(qa.lt.rms2) then
      run=.true.
          do while(run)
      eps=sqrt(rms2-qa)/a
      dtx=-eps+2*eps*ran0(seed)
      dty=0.
      dtz=0.
      call trmsq(dtx,dty,dtz,ro,qt)
               if(qt.lt.rms2-qa) then
      eps=sqrt(rms2-qa-a*a*dtx*dtx)/b
      dty=-eps+2*eps*ran0(seed)
      call trmsq(dtx,dty,dtz,ro,qt)
                  if(qt.lt.rms2-qa) then
      eps=sqrt(rms2-qa-a*a*dtx*dtx-b*b*dty*dty)/c
      dtz=eps
      call trmsq(dtx,dty,dtz,ro,qt)
      qd=qa+qt
                     if((qd.lt.rmspeps).and.(qd.gt.rmsmeps)) then
      tx=tx+dtx
      ty=ty+dty
      tz=tz+dtz
      xhi=xhi*rtod
      call rmxp(xhi,u,r1)
      call pro2mx(r2,r0,r1)
      call rmx2e(r2,al,be,ga)
      write(iout,forme) zn,bod,al,be,ga,tx,ty,tz,ncs,(incs(i),i=1,ncs)
      run=.false.
      num=20000
                     endif
                  endif
               endif
          enddo
            endif
         enddo
c.......................................................................
         endif
        enddo
       enddo
         if(run) then
      write(iecr,'(a)') ' >>> Error <<< in format'
         else
      run=.false.
         endif
      stop
      end
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function ran0(seed)
      implicit none
      integer ia,im,iq,ir,k,mask,seed
      real am,ran0
      parameter(ia=16807,im=2147483647,iq=127773,ir=2836,mask=123459876)
      am=1./im
      seed=ieor(seed,mask)
      k=seed/iq
      seed=ia*(seed-k*iq)-ir*k
      if(seed.lt.0) seed=seed+im
      ran0=am*seed
      seed=ieor(seed,mask)
      return
      end
"ENDOF ncsrms.f"
#=======================================================================
echo ncsym.f
cat >ncsym.f <<"ENDOF ncsym.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine ncsym(al,be,ga,tx,ty,tz)
      implicit none
      integer i,iecr,ilec,in,incs,iout,is,kprt,kprtt,ncs,nort
      real al,be,dm,dmd,dmdn,dmn,dtor,dxn,ga,pi,r1,r2,rf,rncs,ro,rox,
     & rtod,tncs,tr,twopi,tx,txn,ty,tz
      character cbid1*1
      dimension r1(9),r2(9),rox(9)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ncsdat/ ncs,incs(1000),rncs(9,1000),tncs(3,1000),
     & dmn(3,3,1000),dmdn(3,3,3,1000),dxn(3,3,1000),txn(3,1000)
      common/ortm/ ro(9),rf(9),nort
      common/rotra/ dm(3,3),dmd(3,3,3),tr(3)
      kprtt=kprt
      kprt=0
      call setmat(al,be,ga,tx,ty,tz)
      call rbinv(rf,rox)
      call rmxe(al,be,ga,r1)
      do 10 in=1,ncs
      is=incs(in)
      call pro3mx(dxn(1,1,in),rf,rncs(1,is),rox)
       do i=1,3
      txn(i,in)=dxn(i,1,in)*tx+dxn(i,2,in)*ty+dxn(i,3,in)*tz+tncs(i,is)
       enddo
      call pro2mx(r2,rncs(1,is),r1)
      call pro3mx(dmn(1,1,in),rf,r2,ro)
       do i=1,3
      call pro3mx(dmdn(1,1,i,in),rf,rncs(1,is),dmd(1,1,i))
       enddo
10    continue
      kprt=kprtt
      return
      end
"ENDOF ncsym.f"
#=======================================================================
echo o2fndo.f
cat >o2fndo.f <<"ENDOF o2fndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine o2fndo(na,nd,atab,cardd,ncorps)
      implicit none
      integer atab,bod,bref,i,i1,i2,ibid1,id,iecr,ilec,io1,iout,it,
     & ixflag,j,kprt,lungo,n,na,ncorps,ncyc,nd,neq,nh,nite,nlungo,nmol,
     & nort,nsol,nts,number,tbod
      real cel,cutoff,dmax,dmaxt,dmin,dmint,qq,rbid1,rbid2,rf,rmsr,ro,t
      character card*80,cardd*80,cardm*4000,forme*40,formr*40,tcar*80,
     & yn*1,zn*1
      parameter(nh=1000)
      dimension atab(na),cardd(nh),ixflag(3),qq(6)
      external lungo
      common/cell/ cel(6),rbid1(16)
      common/files/ id,i1,i2,io1
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ortm/ ro(9),rf(9),nort
      common/simt/ rbid2(153),ibid1(432),neq,nts
      data nlungo/4000/
       do i=1,na
      atab(i)=0
       enddo
      rewind(unit=i1)
      read(i1,'(a)') card
      read(i1,*) nmol,nsol
       do i=1,nmol
      read(i1,fmt=formr) bod
      atab(bod)=bod
       enddo
      j=0
       do i=1,na
         if(atab(i).ne.0) then
      j=j+1
      atab(j)=atab(i)
         endif
       enddo
      na=j
      yn='*'
      rewind(unit=ilec)
      read(ilec,*)
      read(ilec,*)
      read(ilec,*) cutoff,number
      read(ilec,*) dmax,dmin
         if(dmax.lt.dmin) then
      t=dmax
      dmax=dmin
      dmin=t
         endif
      tcar=cardd(nd)
c lecturainterna
      read(tcar,*) dmaxt,dmint
      if(dmin.lt.dmint) dmin=dmint
      write(tcar,'(2f10.2)') dmax,dmin
      cardd(nd)=tcar
      read(ilec,*) ncyc,nite,rmsr,bref
      if(nsol.lt.0) ncyc=nsol
      rewind(unit=id)
      read(id,*)
      read(id,*) cel
      call celda
      it=ilec
      ilec=id
      call lecsim
      ilec=it
      read(id,*) nort
      call ortho
      read(ilec,'(a)') card
         if(card(1:2).eq.'p1') then
      neq=1
      nts=0
      nd=nd+1
      cardd(nd)=card
      read(ilec,*)
         endif
      nd=nd+1
      write(tcar,'(a,i5)') 'inertia tensors',na
      cardd(nd)=tcar
       do i=1,na
      bod=atab(i)
      tbod=bod+10
      call abra(tbod,'f','u',0)
      rewind(unit=tbod)
        do j=1,8
      read(tbod,*)
        enddo
      read(tbod,'(17x,6f9.2)') qq
      call cierre(tbod,'f')
      nd=nd+1
      write(tcar,'(1x,a,i2,5x,6f9.2)') yn,bod,qq
      cardd(nd)=tcar
       enddo
         if(ncorps.eq.1) then
      call sgfr(ixflag)
      write(card,'(7i2)') bref,1,1,1,ixflag
         else
      write(card,'(7i2)') bref,1,1,1,1,1,1
         endif
       do n=1,nd
      write(iout,'(a)') cardd(n)
       enddo
      nd=1
      write(tcar,'(i3,17x,a)') ncorps,'++++++++++++++++++++'
      cardd(nd)=tcar
      nd=nd+1
      cardd(nd)=card
      nd=nd+1
      write(tcar,'(i5,5x,i5,f10.3)') ncyc,nite,rmsr*dmin
      cardd(nd)=tcar
      rewind(unit=i1)
      read(i1,'(a)') card
10    read(i1,*,end=20) nmol
       do n=1,nd
      write(iout,'(a)') cardd(n)
       enddo
       do i=1,nmol
      read(i1,'(a)') cardm
      write(iout,'(a)') cardm(1:lungo(cardm,nlungo))
       enddo
      go to 10
20    return
      end
"ENDOF o2fndo.f"
#=======================================================================
echo oicndo.f
cat >oicndo.f <<"ENDOF oicndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine oicndo(cart)
      implicit none
      integer i,i1,i2,id,iecr,ilec,ine,ins,io1,iout,jd,jj,kprt,luout,
     & luudi,ma,n,na,ncorps,nd,nh,nort
      real bsharp,cel,dmax,dmin,pctrf
      character card*80,cardd*80,cart*80,cbid1*1,option*6,tcar*80,type*6
      parameter(na=79,nh=1000)
      dimension cardd(nh),cel(6),jj(3*na)
      common/files/ id,i1,i2,io1
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
c logicalunit
      id=8
      i1=1
      i2=0
      io1=99
      luudi=10
      luout=9
      option=cart(5:10)
      write(iecr,2010) option
       do n=1,100
        do i=1,80
      cardd(n)(i:i)=' '
        enddo
       enddo
      nd=1
      cardd(nd)(1:76)=cart(5:80)
         if(option.eq.'fiting') then
      nd=nd+1
      write(tcar,'(a)') '2    1 1             :printing'
      cardd(nd)=tcar
      nd=nd+1
         endif
      call abra(id,'f','u',0)
      rewind(unit=id)
      read(id,*)
      nd=nd+1
      read(ilec,'(a)') cardd(nd)
      read(id,*) cel
      nd=nd+1
      write(tcar,'(6f10.3)') cel
      cardd(nd)=tcar
10    nd=nd+1
      read(id,'(a)') cardd(nd)
      ine=index(cardd(nd),'e')
      ins=index(cardd(nd),'s')
      if(ine.lt.1.and.ins.lt.1) go to 10
      read(id,*) nort
      nd=nd+1
      write(tcar,'(i1)') nort
      cardd(nd)=tcar
      read(id,*) pctrf,bsharp
      nd=nd+1
      write(tcar,'(2f10.1)') pctrf,bsharp
      cardd(nd)=tcar
      read(id,*) dmax,dmin
      nd=nd+1
      write(tcar,'(2f10.2)') dmax,dmin
      cardd(nd)=tcar
      jd=1
20    read(id,'(a)',end=30) card
      cardd(nd+jd)=card
      jd=jd+1
      go to 20
30    call abra(iout,'f','u',0)
      rewind(iout)
         if(option.eq.'fiting') then
      write(tcar,'(2i3,14x,a)') luudi,luout,' :logical units'
      cardd(3)=tcar
      call abra(i1,'f','u',0)
      rewind(unit=i1)
      read(i1,'(a)') type
      read(i1,*) ncorps
      write(iecr,2020) ncorps,type
      ma=3*na
      call o2fndo(ma,nd,jj(1),cardd,ncorps)
         else
      write(iecr,*) ' option not available'
         endif
      return
2010  format(/' ****** programme oic ******'//' prepares ',a6,' input')
2020  format(/' positions coming from a',i3,'-body ',a6,' output')
      end
"ENDOF oicndo.f"
#=======================================================================
echo optimo.f
cat >optimo.f <<"ENDOF optimo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine optimo(dsmin,sharat,bfac)
      implicit none
      integer h,hh,iecr,ilec,iout,k,kk,kprt,l,ll,mx,my,mz,n,nh,nx,ny,nz,
     & sx,sy,sz
      real a,alpha,ast,b,beta,bf,bfac,bfi,bfu,bst,c,ca,cast,cb,cbst,cg,
     & cgst,cst,dmin,dsmin,elim,error,gamma,gi,ox,oy,oz,sa,sast,sb,sbst,
     & sg,sgst,sharat,sqh,vol
      character cbid1*1
      external befac
      dimension hh(100),kk(100),ll(100)
      common/cell/ a,b,c,alpha,beta,gamma,ca,cb,cg,sa,sb,sg,ast,bst,cst,
     & cast,cbst,cgst,sast,sbst,sgst,vol
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/optima/ h,k,l,nx,ny,nz,gi(3,3)
      dmin=dsmin*sharat
      nx=2.*(a/dsmin+1.)
      ny=2.*(b/dsmin+1.)
      nz=2.*(c/dsmin+1.)
      call contrg(nx,1)
      call contrg(ny,2)
      call contrg(nz,3)
      gi(1,1)=ast*ast
      gi(1,2)=ast*bst*cgst
      gi(1,3)=ast*cst*cbst
      gi(2,2)=bst*bst
      gi(2,3)=bst*cst*cast
      gi(3,3)=cst*cst
      gi(2,1)=gi(1,2)
      gi(3,1)=gi(1,3)
      gi(3,2)=gi(2,3)
      nh=0
       do sx=-1,1
      mx=sx*nx
        do sy=-1,1
      my=sy*ny
         do sz=-1,1
      mz=sz*nz
      if(sx.lt.0.or.(sx.eq.0.and.(sz.gt.0.or.(sz.eq.0.and.sy.ge.0))))
     . go to 10
      ox=gi(1,1)*mx+gi(1,2)*my+gi(1,3)*mz
      oy=gi(2,1)*mx+gi(2,2)*my+gi(2,3)*mz
      oz=gi(3,1)*mx+gi(3,2)*my+gi(3,3)*mz
      sqh=ox*mx+oy*my+oz*mz
      nh=nh+1
      hh(nh)=mx/(dmin*sqrt(sqh))
      kk(nh)=my/(dmin*sqrt(sqh))
      ll(nh)=mz/(dmin*sqrt(sqh))
10    continue
         enddo
        enddo
       enddo
      elim=10.*3./4.
      bfac=0.
       do n=1,nh
      h=hh(n)
      k=kk(n)
      l=ll(n)
      error=exp(-elim)
      bfi=0.
      bfu=100000.
      call zero(befac,error,bfi,bfu,bf)
      if(bf.gt.bfac) bfac=bf
       enddo
      return
      end
"ENDOF optimo.f"
#=======================================================================
echo origen.f
cat >origen.f <<"ENDOF origen.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program origen
      implicit none
      integer bod,i,i0,ia,id,iecr,ilec,iout,it,j,kprt,ncod,nort,tbod
      real a,al,al0,alpha,b,be,be0,beta,biso,c,c0,dtor,ga,ga0,gamma,pi,
     & r,r0,rbid1,rf,rfx,ro,rp,rtod,rx,tra,twopi,tx,xi,xo
      character atnam*4,card*80,cbid1*1,forml*80,tcar*80
      logical first
      dimension c0(3,100),i0(100),r(3,3),r0(9,100),rfx(3,3),rp(9),
     & rx(3,3),tra(3),tx(3),xi(3),xo(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ortm/ ro(3,3),rf(3,3),nort
      data i0/100*0/,c0/300*0./,r0/900*0./
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      kprt=1
      iout=9
      id=8
      call abra(id,'f','u',0)
      rewind(unit=id)
      read(id,*)
      read(id,*) a,b,c,alpha,beta,gamma
      call celda
      it=ilec
      ilec=id
      call lecsim
      ilec=it
      read(id,*) nort
      write(iecr,'(/a,i3)') ' orthogonalizing code in d/data.d =',nort
      write(iecr,'(/a)') ' enter input orthogonalizing code'
      read(ilec,*) nort
      call ortho
      ncod=nort
      write(iecr,'(/a/a)') ' enter output orthogonalizing code',
     . ' (for SuMI, same as in d/data.d)'
      read(ilec,*) nort
         if(nort.ne.ncod) then
       do i=1,3
        do j=1,3
      rfx(i,j)=rf(i,j)
        enddo
       enddo
      write(iecr,'(/a)') ' output orthogonalization'
      call ortho
      call pro2mx(rp,ro,rfx)
         endif
      call abra(iout,'f','u',0)
      rewind(unit=iout)
      al=0.
      be=0.
      ga=0.
      tra(1)=0.
      tra(2)=0.
      tra(3)=0.
10    write(iecr,'(/a)') ' enter model-nb. (d/xyz[#].d) [#=0 to stop]'
      read(ilec,*) bod
      if(bod.le.0) go to 120
      first=.true.
      ia=0
         if(i0(bod).eq.0) then
      tbod=bod+10
      call abra(tbod,'f','u',0)
      rewind(unit=tbod)
      i0(bod)=1
20    read(tbod,'(a)') card
      if(card(1:7).ne.' center') go to 20
      read(card,'(17x,3f9.2)') (c0(i,bod),i=1,3)
      read(tbod,'(17x,3f9.2)') al0,be0,ga0
      kprt=0
      call rmxe(al0,be0,ga0,r0(1,bod))
      kprt=1
      call cierre(tbod,'f')
         endif
      call rmxe(al,be,ga,r)
      call pro2mx(rx,r,r0(1,bod))
         if(nort.ne.ncod) then
      call pro2mx(r,rp,rx)
       do i=1,3
        do j=1,3
      rx(i,j)=r(i,j)
        enddo
       enddo
         endif
      do 40 i=1,3
      tx(i)=0.
      do 30 j=1,3
      tx(i)=tx(i)+ro(i,j)*tra(j)
30    continue
40    continue
      do 60 i=1,3
      do 50 j=1,3
      tx(i)=tx(i)-rx(i,j)*c0(j,bod)
50    continue
60    continue
         if(bod.lt.10) then
      write(iout,'(a,i1)') 'echo mol',bod
      write(iout,'(a,i1,a,i1,a)') 'cat >mol',bod,' <<"ENDOF mol',bod,'"'
         else
      write(iout,'(a,i2)') 'echo mol',bod
      write(iout,'(a,i2,a,i2,a)') 'cat >mol',bod,' <<"ENDOF mol',bod,'"'
         endif
      tbod=bod+50
      call abra(tbod,'f','u',0)
      rewind(unit=tbod)
       do i=1,80
      forml(i:i)=' '
       enddo
70    read(tbod,'(a)') card
         if(card(1:6).ne.'FORMAT') then
      if(first) write(iout,'(a)') card
      go to 70
         else
      write(iout,'(a,3f9.3,3f7.2)') 'CRYST ',a,b,c,alpha,beta,gamma
      write(iout,'(a)') card
      first=.false.
         endif
      forml(1:66)=card(7:72)
80    read(tbod,'(a)',end=110) card
      if(card(1:4).ne.'ATOM') go to 80
      read(card,fmt=forml) atnam,xi,biso
c     if(atnam.ne.' C  '.and.atnam.ne.' N  '.and.atnam.ne.' O  '.and.
c    . atnam.ne.' CA ') go to 80
      if(atnam(2:2).eq.'H'.or.atnam(2:2).eq.'D'.or.atnam(2:2).eq.'E'.or.
     . atnam(2:2).eq.'X') go to 80
      do 100 i=1,3
      xo(i)=0.
      do 90 j=1,3
      xo(i)=xo(i)+rx(i,j)*xi(j)
90    continue
      xo(i)=xo(i)+tx(i)
100   continue
      ia=ia+1
      write(tcar,'(i7)') ia
      card(5:11)=tcar(1:7)
      write(tcar,'(3f8.3)') xo
      card(31:54)=tcar(1:24)
      write(iout,'(a)') card
      go to 80
110   close(unit=tbod)
         if(bod.lt.10) then
      write(iout,'(a,i1,a)') '"ENDOF mol',bod,'"'
         else
      write(iout,'(a,i2,a)') '"ENDOF mol',bod,'"'
         endif
      go to 10
120   stop
      end
"ENDOF origen.f"
#=======================================================================
echo ortho.f
cat >ortho.f <<"ENDOF ortho.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine ortho
      implicit none
      integer i,iecr,ij,ilec,iout,ip,iq,is,isym,it,itr,j,kprt,mss,n0,
     & neq,nort,nsym,nts
      real a,alpha,arg,ast,b,beta,bst,c,c0,c1,c2,c3,ca,cast,cb,cbst,cg,
     & cgst,cst,det,fuzz,gamma,gd,gi,p,p1,p2,p3,proy,rbid1,rf,ro,rs,rx,
     & sa,sast,sb,sbst,sg,sgst,unor,v1,v2,v3,vol
      character cbid1*1
      dimension c0(3,48),c1(3),c2(3),c3(3),gd(3,3),gi(3,3),n0(48),rs(9),
     & rx(3,3),v1(3),v2(3),v3(3)
      common/cell/ a,b,c,alpha,beta,gamma,ca,cb,cg,sa,sb,sg,ast,bst,cst,
     & cast,cbst,cgst,sast,sbst,sgst,vol
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ortm/ ro(3,3),rf(3,3),nort
      common/simt/ rbid1(153),mss(9,48),neq,nts
cjn uninitialized values
      data iq,proy/0,0./
      fuzz=0.001
      if(nort.eq.0.and.neq.eq.1) nort=1
      if(nort.ne.0) go to 190
      gd(1,1)=a*a
      gd(1,2)=a*b*cg
      gd(1,3)=a*c*cb
      gd(2,2)=b*b
      gd(2,3)=b*c*ca
      gd(3,3)=c*c
      gd(2,1)=gd(1,2)
      gd(3,1)=gd(1,3)
      gd(3,2)=gd(2,3)
      gi(1,1)=ast*ast
      gi(1,2)=ast*bst*cgst
      gi(1,3)=ast*cst*cbst
      gi(2,2)=bst*bst
      gi(2,3)=bst*cst*cast
      gi(3,3)=cst*cst
      gi(2,1)=gi(1,2)
      gi(3,1)=gi(1,3)
      gi(3,2)=gi(2,3)
      nsym=1
      do 60 is=2,neq
      n0(is)=0
      do 10 ij=1,9
      rs(ij)=mss(ij,is)
10    continue
      call det3(rs,det)
      itr=mss(1,is)+mss(5,is)+mss(9,is)
      if(nint(det).ne.1.or.itr.gt.2) go to 60
      isym=itr+3+abs(itr)/2
         if(isym.ge.nsym) then
      nsym=isym
      call pro2mx(rx,gd,rs)
            if(itr.gt.-1) then
      unor=sqrt(3.-itr*(itr-2.))*vol
      c3(1)=(rx(3,2)-rx(2,3))/unor
      c3(2)=(rx(1,3)-rx(3,1))/unor
      c3(3)=(rx(2,1)-rx(1,2))/unor
            else
      do 20 i=1,3
      arg=(rx(i,i)+gd(i,i))/2
      if(arg.le.0.) arg=0.
      v3(i)=sqrt(arg)
20    continue
               if(v3(3).ne.0.) then
      v3(1)=sign(v3(1),rx(1,3)+gd(1,3))
      v3(2)=sign(v3(2),rx(2,3)+gd(2,3))
               else if(v3(2).ne.0.) then
      v3(1)=sign(v3(1),rx(1,2)+gd(1,2))
               endif
      do 40 i=1,3
      c3(i)=0.
      do 30 j=1,3
      c3(i)=c3(i)+gi(j,i)*v3(j)
30    continue
40    continue
            endif
      n0(is)=isym
      do 50 i=1,3
      c0(i,is)=c3(i)
50    continue
      p3=abs(c3(3))/cst
      p2=abs(c3(2))/bst
      p1=abs(c3(1))/ast
      proy=max(p3,p2,p1)
         endif
60    continue
         if(nsym.eq.1) then
      nort=1
      go to 190
         endif
      ip=0
      do 70 is=2,neq
      if(n0(is).ne.nsym) go to 70
      p3=abs(c0(3,is))/cst
      p2=abs(c0(2,is))/bst
      p1=abs(c0(1,is))/ast
      p=max(p3,p2,p1)
      if(proy-p.gt.fuzz) go to 70
         if(p-p3.le.fuzz) then
      it=3
         else if(p-p2.le.fuzz) then
      it=2
         else if(p-p1.le.fuzz) then
      it=1
         else
      go to 901
         endif
      if(ip.eq.3.and.it.ne.3) go to 70
      proy=p
      ip=it
      iq=is
70    continue
      do 80 i=1,3
      c3(i)=c0(i,iq)
      if(c0(ip,iq).lt.0.) c3(i)=-c3(i)
80    continue
      do 100 i=1,3
      v3(i)=0.
      do 90 j=1,3
      v3(i)=v3(i)+gd(i,j)*c3(j)
90    continue
100   continue
      do 110 i=1,3
      c1(i)=0.
      c2(i)=0.
      v1(i)=0.
110   continue
      p1=abs(v3(1))/a
      p2=abs(v3(2))/b
      p3=abs(v3(3))/c
      p=min(p1,p2,p3)
         if(p1-p.le.fuzz) then
      c1(1)=1/a
      proy=v3(1)/a
         else if(p2-p.le.fuzz) then
      c1(2)=1/b
      proy=v3(2)/b
         else if(p3-p.le.fuzz) then
      c1(3)=1/c
      proy=v3(3)/c
         else
      go to 901
         endif
      do 120 i=1,3
      c1(i)=c1(i)-proy*c3(i)
120   continue
      unor=0.
      do 140 i=1,3
      do 130 j=1,3
      v1(i)=v1(i)+gd(i,j)*c1(j)
130   continue
      unor=unor+c1(i)*v1(i)
140   continue
      unor=sqrt(unor)
      do 150 i=1,3
      c1(i)=c1(i)/unor
      v1(i)=v1(i)/unor
150   continue
      v2(1)=(c3(2)*c1(3)-c3(3)*c1(2))*vol
      v2(2)=(c3(3)*c1(1)-c3(1)*c1(3))*vol
      v2(3)=(c3(1)*c1(2)-c3(2)*c1(1))*vol
      do 170 i=1,3
      do 160 j=1,3
      c2(i)=c2(i)+gi(j,i)*v2(j)
160   continue
170   continue
      do 180 i=1,3
      ro(1,i)=v1(i)
      ro(2,i)=v2(i)
      ro(3,i)=v3(i)
      rf(i,1)=c1(i)
      rf(i,2)=c2(i)
      rf(i,3)=c3(i)
180   continue
      go to 220
190   do 210 j=1,3
      do 200 i=1,3
      ro(i,j)=0.
      rf(i,j)=0.
200   continue
210   continue
         if(nort.eq.1) then
      ro(1,1)=a
      ro(1,2)=b*cg
      ro(1,3)=c*cb
      ro(2,2)=b*sg
      ro(2,3)=-c*sb*cast
      ro(3,3)=c*sa*sbst
      rf(1,1)=ast*sbst*sg
      rf(1,2)=-ast*sbst*cg
      rf(1,3)=ast*cbst
      rf(2,2)=bst*sast
      rf(2,3)=bst*cast
      rf(3,3)=cst
         else if(nort.eq.2) then
      ro(1,2)=b
      ro(1,3)=c*ca
      ro(1,1)=a*cg
      ro(2,3)=c*sa
      ro(2,1)=-a*sg*cbst
      ro(3,1)=a*sb*sgst
      rf(2,1)=bst*sgst*sa
      rf(2,2)=-bst*sgst*ca
      rf(2,3)=bst*cgst
      rf(3,2)=cst*sbst
      rf(3,3)=cst*cbst
      rf(1,3)=ast
         else if(nort.eq.3) then
      ro(1,3)=c
      ro(1,1)=a*cb
      ro(1,2)=b*ca
      ro(2,1)=a*sb
      ro(2,2)=-b*sa*cgst
      ro(3,2)=b*sg*sast
      rf(3,1)=cst*sast*sb
      rf(3,2)=-cst*sast*cb
      rf(3,3)=cst*cast
      rf(1,2)=ast*sgst
      rf(1,3)=ast*cgst
      rf(2,3)=bst
         endif
220      if(kprt.ne.0) then
      write(iecr,2010) nort
      write(iecr,2020) ((ro(i,j),j=1,3),i=1,3),((rf(i,j),j=1,3),i=1,3)
         endif
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
2010  format(/' transformation of coordinates (direct or reciprocal)'/
     . ' nort=0, orthog axes have z along highest symmetry axis'/
     . ' nort=1, orthog axes have x along a, z along cstar'/
     . ' nort=2, orthog axes have x along b, z along astar'/
     . ' nort=3, orthog axes have x along c, z along bstar'/
     . ' here nort is',i5)
2020  format(' orthogonalizing matrix for xyz'/3(/3f10.3)/
     . /' orthogonalizing matrix for hkl'/3(/3f10.6))
3010  format('stop >> ortho << increase fuzz')
      end
"ENDOF ortho.f"
#=======================================================================
echo pac3.f
cat >pac3.f <<"ENDOF pac3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pac3(ih,ik,il,ind)
      implicit none
      integer hm,iecr,ih,ik,il,ilec,ind,iout,km,kprt,lm,maxint,nh,nk,nl
      character cbid1*1
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/paco3/ hm,km,lm,nh,nk,nl,maxint
      if(ih+hm.lt.0.or.ih+hm.ge.nh.or.ik+km.lt.0.or.ik+km.ge.nk.or.
     . il+lm.lt.0.or.il+lm.ge.nl) go to 901
      ind=((il+lm)*nk+ik+km)*nh+ih+hm
      return
901   write(iecr,3010) ih,ik,il
      write(iout,3010) ih,ik,il
      stop
3010  format('stop >> pac3 << maximal indices exceeded =',3i5)
      end
"ENDOF pac3.f"
#=======================================================================
echo pac4.f
cat >pac4.f <<"ENDOF pac4.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pac4(ih,ik,il,im,ind)
      implicit none
      integer hm,iecr,ih,ik,il,ilec,im,ind,iout,km,kprt,lm,nh,nk,nl,nm
      character cbid1*1
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/paco/ hm,km,lm,nh,nk,nl,nm
      if(ih+hm.lt.0.or.ih+hm.ge.nh.or.ik+km.lt.0.or.ik+km.ge.nk.or.
     . il+lm.lt.0.or.il+lm.ge.nl.or.im.lt.0.or.im.ge.nm) go to 901
      ind=(((il+lm)*nk+ik+km)*nh+ih+hm)*nm+im
      return
901   write(iecr,3010) ih,ik,il
      write(iout,3010) ih,ik,il
      stop
3010  format('stop >> pac4 << maximal indices exceeded =',3i5)
      end
"ENDOF pac4.f"
#=======================================================================
echo pak3.f
cat >pak3.f <<"ENDOF pak3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pak3(i,j,k,ind)
      implicit none
      integer i,iecr,ilec,ind,iout,j,k,kprt,m,n
      character cbid1*1
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      data m,n/2,5/
      if(i+m.lt.0.or.i+m.ge.n.or.j+m.lt.0.or.j+m.ge.n.or.
     . k+m.lt.0.or.k+m.ge.n) go to 901
      ind=((k+m)*n+j+m)*n+i+m
      return
901   write(iecr,3010) i,j,k
      write(iout,3010) i,j,k
      stop
3010  format('stop >> pak3 << maximal indices exceeded =',3i5)
      end
"ENDOF pak3.f"
#=======================================================================
echo phkl1.f
cat >phkl1.f <<"ENDOF phkl1.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine phkl1(nd,ph,nk,nz,hs,hkl,hklo,ww,fo)
      implicit none
      integer h,hf,hh,hkl,hklo,hlw,hs,hup,i,i1,ibid1,iecr,ilec,indo,io1,
     & iout,j,k,kk,klw,kprt,krep,kup,l,ll,llw,lup,m,nd,nk,ntot,nxyz,nz,
     & o1,ph
      real a11,a21,a22,a31,a32,a33,bfac,fooo,rbid1,scale,sqh,vol,zn
      complex f,fo,uno,ww
      character cbid1*1
      dimension fo(nd),hkl(nd),hklo(nd),ww(ph,nk,nz)
      common/cell/ rbid1(21),vol
      common/dfft/ hlw,hup,klw,kup,llw,lup,ibid1,nxyz
      common/fozo/ fooo,zn,bfac,krep
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/star/ a11,a21,a22,a31,a32,a33
      common/tapes/ i1,io1,o1
      save indo,j,ntot
      uno=(1.,0.)
      scale=vol/nxyz
         if(hs.eq.hlw) then
      call pac3(0,0,0,indo)
      j=0
      ntot=0
      rewind(unit=o1)
         endif
      hf=hs+ph-1
      rewind(unit=io1)
10    read(io1,end=30) m,hkl
      do 20 i=1,m
      call unpac3(h,k,l,hkl(i))
      if(h.lt.hs.or.h.gt.hf) go to 20
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      hh=h-hs+1
      kk=k+1
      if(kk.le.0) kk=kk+nk
      ll=l+1
      if(ll.le.0) ll=ll+nz
      f=conjg(ww(hh,kk,ll))*scale*exp(-bfac*sqh/4.)
      if(hkl(i).eq.indo) f=real(f)*uno
      j=j+1
      hklo(j)=hkl(i)
      fo(j)=f
         if(j.eq.nd) then
      write(o1) j,hklo,fo
      ntot=ntot+j
      j=0
         endif
20    continue
      go to 10
30       if(hf.eq.hup) then
      if(j.ne.0) write(o1) j,hklo,fo
      ntot=ntot+j
      if(kprt.ne.0) write(iecr,2010) ntot,bfac
         endif
      return
2010  format(/' phkl1.',i10,' coefficients written'/
     . ' fo = f*exp(-b*hsq/4)*vol. b =',f10.3)
      end
"ENDOF phkl1.f"
#=======================================================================
echo pro2mx.f
cat >pro2mx.f <<"ENDOF pro2mx.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pro2mx(ro,r2,r1)
      implicit none
      integer i,j,k
      real r1,r2,ro
      double precision add,d1,d2
      dimension d1(3,3),d2(3,3),r1(3,3),r2(3,3),ro(3,3)
       do i=1,3
        do j=1,3
      d1(i,j)=r1(i,j)
      d2(i,j)=r2(i,j)
        enddo
       enddo
       do i=1,3
        do j=1,3
      add=0.d0
         do k=1,3
      add=add+d2(i,k)*d1(k,j)
         enddo
      ro(i,j)=add
        enddo
       enddo
      return
      end
"ENDOF pro2mx.f"
#=======================================================================
echo pro3mx.f
cat >pro3mx.f <<"ENDOF pro3mx.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pro3mx(ro,r3,r2,r1)
      implicit none
      integer i,j,k,l
      real r1,r2,r3,ro
      double precision add,d1,d2,d3
      dimension d1(3,3),d2(3,3),d3(3,3),r1(3,3),r2(3,3),r3(3,3),ro(3,3)
       do i=1,3
        do j=1,3
      d1(i,j)=r1(i,j)
      d2(i,j)=r2(i,j)
      d3(i,j)=r3(i,j)
        enddo
       enddo
       do i=1,3
        do j=1,3
      add=0.d0
         do k=1,3
          do l=1,3
      add=add+d3(i,k)*d2(k,l)*d1(l,j)
          enddo
         enddo
      ro(i,j)=add
        enddo
       enddo
      return
      end
"ENDOF pro3mx.f"
#=======================================================================
echo propre.f
cat >propre.f <<"ENDOF propre.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program propre
      implicit none
      integer bod,i,i1,id,iecr,ilec,iout,it,j,kprt,lun,n,nbody,nmol,
     & nort,ord,tri
      real a,alpha,ayc,b,beta,c,dtor,gamma,pi,rbid1,rf,ro,rtod,rx,seuil,
     & twopi
      character card*80,forme*40,formr*40,title*80,zn*1
      dimension ayc(9),bod(79),rx(9)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ortm/ ro(3,3),rf(9),nort
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      kprt=0
      iout=9
      zn='#'
      formr='(2x,i2,    3f7.1,3f8.4,  1x,4f6.1      )'
      forme='(1x,a1,i2, 3f7.1,3f8.4,  1x,3f6.1,2i3,a)'
c logicalunit
      id=8
      call abra(id,'f','u',0)
      rewind(unit=id)
      read(id,*)
      read(id,*) a,b,c,alpha,beta,gamma
      call celda
      it=ilec
      ilec=id
      call lecsim
      ilec=it
      read(id,*) nort
      call ortho
      read(ilec,*) nbody,seuil
      i1=1
      call abra(i1,'f','o',0)
      rewind(unit=i1)
      read(i1,'(a)') title
      read(i1,'(i10)') nmol
       do i=1,nmol
      lun=80+i
      call abra(lun,'f','u',0)
      rewind(unit=lun)
       enddo
      rewind(i1)
      read(i1,*)
      tri=0
10    read(i1,*,end=20) n
      tri=tri+1
         if(n.ne.nmol) then
      write(iecr,'(a)') ' different bodies'
      stop
         endif
       do i=1,nmol
      read(i1,'(a)') card
      lun=80+i
      write(lun,'(a)') card
      read(card,fmt=formr) bod(i)
       enddo
      go to 10
20    call cierre(i1,'f')
       do i=1,nmol
      lun=80+i
      rewind(lun)
      call suprime(lun,bod(i),seuil)
      rewind(lun)
       enddo
      iout=i1
      call abra(iout,'f','u',0)
      rewind(unit=iout)
      write(iout,'(a)') title
       do n=1,tri
      write(iout,'(2i10)') nmol,1
        do i=1,nmol
      lun=80+i
      read(lun,fmt=forme) zn,bod(i),(ayc(j),j=1,9),ord
      call rmxe(ayc(1),ayc(2),ayc(3),rx)
      call rmx2e(rx,ayc(1),ayc(2),ayc(3))
         if(i.le.nmol-nbody) then
      write(iout,fmt=forme) zn,bod(i),(ayc(j),j=1,6)
         else
cjn   write(iout,fmt=forme) zn,bod(i),(ayc(j),j=1,9),ord,n,i,'#'
      write(iout,fmt=forme) zn,bod(i),(ayc(j),j=1,9),n,i,'#'
         endif
        enddo
       enddo
      stop
      end
"ENDOF propre.f"
#=======================================================================
echo pv2rt.f
cat >pv2rt.f <<"ENDOF pv2rt.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program pv2rt
      implicit none
      integer bod,i,i0,id,iecr,ilec,iout,j,kprt,length,mss,neq,nmol,
     & nort,nts,tbod
      real a,al,al0,alpha,b,be,be0,beta,c,c0,dtor,ga,ga0,gamma,pi,pot,r,
     & r0,rbid1,rf,ro,rtod,rx,t,tss,tts,twopi,tx
      character card*80,cart*80,forme*40,formr*40,zn*1
      external length
      dimension c0(3,100),cart(200),i0(100),pot(2),r(3,3),r0(9,100),
     & rx(3,3),t(3),tx(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ortm/ ro(3,3),rf(3,3),nort
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      data i0/100*0/,c0/300*0./,r0/900*0./
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      kprt=0
      iout=9
      zn='#'
      formr='(2x,i2,       3f7.1,3f8.4,1x,3f6.1,f7.2)'
      forme='(1x,a1,i2,    6f10.3        ,2f6.1     )'
      id=8
      neq=1
      nts=0
       do i=1,3
        do j=1,3
      mss(i,j,1)=0.
        enddo
       enddo
       do i=1,3
      tss(i,1)=0.
      tts(i,1)=0.
      mss(i,i,1)=1.
       enddo
      call abra(id,'f','u',0)
      rewind(unit=id)
      read(id,*)
      read(id,*) a,b,c,alpha,beta,gamma
      call celda
      read(id,*)
      read(id,*) nort
      call ortho
      read(ilec,*)
      read(ilec,*)
      nmol=0
10    read(ilec,'(a)',end=30) card
      if(length(card).eq.0) go to 30
      nmol=nmol+1
      read(card,fmt=formr) bod,al,be,ga,t,pot
         if(i0(bod).eq.0) then
      tbod=bod+10
      i0(bod)=1
      call abra(tbod,'f','u',0)
      rewind(unit=tbod)
20    read(tbod,'(a)') card
      if(card(1:7).ne.' center') go to 20
c lectura interna
      read(card(18:80),*) (c0(i,bod),i=1,3)
      read(tbod,'(17x,3f9.2)') al0,be0,ga0
      call rmxe(al0,be0,ga0,r0(1,bod))
      call cierre(tbod,'f')
         endif
      call rmxe(al,be,ga,r)
      call pro2mx(rx,r,r0(1,bod))
      call rmx2e(rx,al,be,ga)
       do i=1,3
      tx(i)=0.
        do j=1,3
      tx(i)=tx(i)+ro(i,j)*t(j)
        enddo
       enddo
       do i=1,3
        do j=1,3
      tx(i)=tx(i)-rx(i,j)*c0(j,bod)
        enddo
       enddo
      write(cart(nmol),fmt=forme) zn,bod,al,be,ga,tx
      go to 10
30    continue
      write(cart(nmol),fmt=forme) zn,bod,al,be,ga,tx,pot
       do i=1,nmol
      write(iecr,'(a)') cart(i)(1:length(cart(i)))
       enddo
      stop
      end
"ENDOF pv2rt.f"
#=======================================================================
echo pythag.f
cat >pythag.f <<"ENDOF pythag.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function pythag(a,b)
      implicit none
      real a,b,p,pythag,r,s,t,u
      p=max(abs(a),abs(b))
      if(p.eq.0.0e0) go to 20
      r=(min(abs(a),abs(b))/p)**2
10    continue
      t=4.0e0+r
      if(t.eq.4.0e0) go to 20
      s=r/t
      u=1.0e0+2.0e0*s
      p=u*p
      r=(s/u)**2*r
      go to 10
20    pythag=p
      return
      end
"ENDOF pythag.f"
#=======================================================================
echo pzc.f
cat >pzc.f <<"ENDOF pzc.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pzc(o1,nx,ny,nz,zs,rr)
      implicit none
      integer i,iecr,ilec,iout,j,kprt,kprtt,mx,my,mz,nx,ny,nz,o1,xlw,
     & xup,ylw,yup,zlw,zs,zup
      real a,alpha,amax,amin,avge,b,beta,c,gamma,map,maxm,minm,rbid1,rr,
     & smax,smin,xlow,xsup
      character cbid1*1
      dimension rr(nx,ny)
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/dfftx/ xlow(3),xsup(3),xlw,ylw,zlw,xup,yup,zup
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/oprt/ kprtt(20)
      save amax,amin,smax,smin
         if(zs.eq.0) then
      mx=xup-xlw+1
      my=yup-ylw+1
      mz=zup-zlw+1
      rewind(unit=o1)
      write(o1) mx,my,mz,xlow,xsup,alpha,beta,gamma
      if(kprt.ne.0) write(iecr,2010)
      smin=1.e20
      smax=-1.e20
      amin=0.
      amax=0.
      kprt=kprtt(2)
         endif
      if(zs.lt.zlw.or.zs.gt.zup) go to 30
      minm=1.e20
      maxm=-1.e20
      avge=0.
      do 20 j=ylw+1,yup+1
      do 10 i=xlw+1,xup+1
      map=rr(i,j)
      if(map.lt.minm) minm=map
      if(map.gt.maxm) maxm=map
      avge=avge+map
10    continue
20    continue
      avge=avge/(nx*ny)
      if(kprt.ne.0) write(iecr,'(i10,3e15.5)') zs,minm,maxm,avge
      if(minm.lt.smin) smin=minm
      if(maxm.gt.smax) smax=maxm
      amin=amin+minm
      amax=amax+maxm
      write(o1) ((rr(i,j),i=xlw+1,xup+1),j=ylw+1,yup+1)
         if(zs.eq.zup) then
      kprt=kprtt(1)
      amin=amin/nz
      amax=amax/nz
      if(kprt.ne.0) write(iecr,2020) smin,smax,amin,amax
         endif
30    return
2010  format(/'   z-sect.        minimum        maximum     avg. value')
2020  format(/' absolute min and max =',2e15.5/
     . ' average min and max =',2e15.5)
      end
"ENDOF pzc.f"
#=======================================================================
echo quadro.f
cat >quadro.f <<"ENDOF quadro.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine quadro(is,ij,nra,np,hkl,hsq,foc,fcd,grad,quad,func)
      implicit none
      integer h,hkl,i,ij,is,j,k,l,mult,n,np,nra
      real bfact,corf,cori,corp,func,grad,hsq,quad,rfli,rfsq,scale,sex,
     & sfli,sfqu,sfsq
      complex df,fcd,foc
      dimension fcd(nra,0:np),foc(nra),grad(np),hkl(nra),hsq(nra),
     & quad(np,np)
      common/pote/ sfli,sfsq,sfqu,rfli,rfsq,corf,cori,corp,scale,bfact
      do 20 i=1,np
      grad(i)=0.
      do 10 j=1,np
      quad(i,j)=0.
10    continue
20    continue
      func=0.
      sex=scale
      do 50 n=1,nra
      call unpac4(h,k,l,mult,hkl(n))
      if(is.ne.0) sex=scale*exp(-bfact*hsq(n))
      df=conjg(fcd(n,0)-foc(n)*sex)
      func=func+mult*abs(df)**2
      do 40 i=1,np
      grad(i)=grad(i)+mult*real(df*fcd(n,i))
      do 30 j=i,np
      quad(i,j)=quad(i,j)+mult*real(conjg(fcd(n,i))*fcd(n,j))
30    continue
40    continue
50    continue
      func=func/(2*sfsq)
      do 70 i=1,np
      grad(i)=grad(i)/sfsq
      do 60 j=i,np
      quad(i,j)=quad(i,j)/sfsq
      quad(j,i)=quad(i,j)
60    continue
70    continue
         if(ij.ne.0) then
      do 80 i=1,np
      if(i.eq.ij) go to 80
      quad(i,ij)=0.
      quad(ij,i)=0.
80    continue
         endif
      return
      end
"ENDOF quadro.f"
#=======================================================================
echo quanta.f
cat >quanta.f <<"ENDOF quanta.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine quanta(na,cxyz1,cxyz2,qxy,lxy)
      implicit none
      integer i,iecr,ilec,iout,j,kprt,kprtt,n,na
      real cxyz1,cxyz2,lxy,qxy,xy
      double precision qd,qr,qt,sl,sq
      character cbid1*1
      dimension cxyz1(3,na),cxyz2(3,na),lxy(6),qxy(6,6),sl(6),sq(6,6),
     & xy(6)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/oprt/ kprtt(10)
      kprt=kprtt(2)
       do i=1,6
        do j=1,6
      sq(i,j)=0.d0
        enddo
      sl(i)=0.d0
       enddo
       do n=1,na
        do i=1,3
      xy(i)=cxyz1(i,n)
      xy(3+i)=cxyz2(i,n)
        enddo
        do i=1,6
         do j=1,6
      sq(i,j)=sq(i,j)+xy(i)*xy(j)
         enddo
      sl(i)=sl(i)+xy(i)
        enddo
       enddo
       do i=1,6
        do j=1,6
      qxy(i,j)=(sq(i,j)/na)-(sl(i)/na)*(sl(j)/na)
        enddo
      lxy(i)=sl(i)/na
       enddo
         if(kprt.ne.0) then
      write(iecr,'(/a,2(/3f15.5))') ' <x> and <y>',(lxy(i),i=1,6)
      write(iecr,'(/a,3(/3f15.5))') ' <x*x>',((qxy(i,j),j=1,3),i=1,3)
      write(iecr,'(/a,3(/3f15.5))') ' <y*y>',((qxy(i,j),j=4,6),i=4,6)
      write(iecr,'(/a,3(/3f15.5))') ' <x*y>',((qxy(i,j),j=4,6),i=1,3)
         endif
      qr=0.d0
      qt=0.d0
        do i=1,3
      qr=qr+qxy(i,i)+qxy(3+i,3+i)-qxy(i,3+i)-qxy(3+i,i)
      qt=qt+(lxy(i)-lxy(3+i))**2
        enddo
      qd=qr+qt
      if(qd.gt.0.d0) qd=sqrt(qd)
      if(qr.gt.0.d0) qr=sqrt(qr)
      if(qt.gt.0.d0) qt=sqrt(qt)
      write(iecr,'(/a,3f8.2)') ' rms shift (rot,tra,all) =',qr,qt,qd
      return
      end
"ENDOF quanta.f"
#=======================================================================
echo r2cftk.f
cat >r2cftk.f <<"ENDOF r2cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r2cftk(x0,y0,x1,y1,n,m,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,i,i0,i1,i2,imax,j,m,m1,m2,mm2,ms2,
     & n,ns
      real angle,c,is,iu,ktes,rs,ru,s,twopi,x0,x1,y0,y1
      logical fold,zero
      dimension dim(*),x0(*),x1(*),y0(*),y1(*)
      common/fftkte/ twopi,ktes(7)
cjn uninitialized values
      data c,s/0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      ms2=m/2+1
      imax=ms2
      if(2*ms2.lt.m+2) imax=imax+1
      m2=m*2
      mm2=m2*d2
      m1=-1
      do 70 i=1,ms2
      fold=i.gt.1.and.i.lt.imax
      del=(i-1)*d2+1
      m1=m1+1
      angle=m1*twopi/m2
      zero=angle.eq.0.
      if(zero) go to 20
      c=cos(angle)
      s=sin(angle)
      go to 20
10    fold=.false.
      del=(m+1-i)*d2+1
      c=-c
20    do 60 i0=del,ns,mm2
      do 50 i1=i0,d1,d3
      i2=i1+d4
      do 40 j=i1,i2,d5
      rs=x0(j)+x1(j)
      is=y0(j)+y1(j)
      ru=x0(j)-x1(j)
      iu=y0(j)-y1(j)
      x0(j)=rs
      y0(j)=is
      if(zero) go to 30
      x1(j)=ru*c+iu*s
      y1(j)=iu*c-ru*s
      go to 40
30    x1(j)=ru
      y1(j)=iu
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r2cftk.f"
#=======================================================================
echo r3cftk.f
cat >r3cftk.f <<"ENDOF r3cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r3cftk(n,m,x0,y0,x1,y1,x2,y2,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,j,k,k1,kk,l,m,m3,mm3,mover2,n,ns
      real a,angle,b,c1,c2,fjm1,fm3,i0,i1,i2,ia,ib,is,ktes,r0,r1,r2,ra,
     & rb,rs,s1,s2,t,twopi,x0,x1,x2,y0,y1,y2
      logical fold,zero
      dimension dim(*),x0(*),x1(*),x2(*),y0(*),y1(*),y2(*)
      common/fftkte/ twopi,a,b,ktes(5)
cjn uninitialized values
      data c1,c2,s1,s2/0.,0.,0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      m3=m*3
      fm3=m3
      mm3=d2*m3
      mover2=m/2+1
      fjm1=-1.
      do 70 j=1,mover2
      fold=j.gt.1.and.2*j.lt.m+2
      del=(j-1)*d2+1
      fjm1=fjm1+1.
      angle=twopi*fjm1/fm3
      zero=angle.eq.0.
      if(zero) go to 20
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      go to 20
10    fold=.false.
      del=(m+1-j)*d2+1
      t=c1*a+s1*b
      s1=c1*b-s1*a
      c1=t
      t=c2*a-s2*b
      s2=-c2*b-s2*a
      c2=t
20    do 60 kk=del,ns,mm3
      do 50 l=kk,d1,d3
      k1=l+d4
      do 40 k=l,k1,d5
      r0=x0(k)
      i0=y0(k)
      rs=x1(k)+x2(k)
      is=y1(k)+y2(k)
      x0(k)=r0+rs
      y0(k)=i0+is
      ra=r0+rs*a
      ia=i0+is*a
      rb=(x1(k)-x2(k))*b
      ib=(y1(k)-y2(k))*b
      if(zero) go to 30
      r1=ra+ib
      i1=ia-rb
      r2=ra-ib
      i2=ia+rb
      x1(k)=r1*c1+i1*s1
      y1(k)=i1*c1-r1*s1
      x2(k)=r2*c2+i2*s2
      y2(k)=i2*c2-r2*s2
      go to 40
30    x1(k)=ra+ib
      y1(k)=ia-rb
      x2(k)=ra-ib
      y2(k)=ia+rb
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r3cftk.f"
#=======================================================================
echo r4cftk.f
cat >r4cftk.f <<"ENDOF r4cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r4cftk(n,m,x0,y0,x1,y1,x2,y2,x3,y3,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,j,k,k1,kk,l,m,m4,mm4,mover2,n,ns
      real angle,c1,c2,c3,fjm1,fm4,i1,i2,i3,is0,is1,iu0,iu1,ktes,r1,r2,
     & r3,rs0,rs1,ru0,ru1,s1,s2,s3,t,twopi,x0,x1,x2,x3,y0,y1,y2,y3
      logical fold,zero
      dimension dim(*),x0(*),x1(*),x2(*),x3(*),y0(*),y1(*),y2(*),y3(*)
      common/fftkte/ twopi,ktes(7)
cjn uninitialized values
      data c1,c2,c3,s1,s2,s3/0.,0.,0.,0.,0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      m4=m*4
      fm4=m4
      mm4=d2*m4
      mover2=m/2+1
      fjm1=-1.
      do 70 j=1,mover2
      fold=j.gt.1.and.2*j.lt.m+2
      del=(j-1)*d2+1
      fjm1=fjm1+1.
      angle=twopi*fjm1/fm4
      zero=angle.eq.0.
      if(zero) go to 20
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      c3=c2*c1-s2*s1
      s3=s2*c1+c2*s1
      go to 20
10    fold=.false.
      del=(m+1-j)*d2+1
      t=c1
      c1=s1
      s1=t
      c2=-c2
      t=c3
      c3=-s3
      s3=-t
20    do 60 kk=del,ns,mm4
      do 50 l=kk,d1,d3
      k1=l+d4
      do 40 k=l,k1,d5
      rs0=x0(k)+x2(k)
      is0=y0(k)+y2(k)
      ru0=x0(k)-x2(k)
      iu0=y0(k)-y2(k)
      rs1=x1(k)+x3(k)
      is1=y1(k)+y3(k)
      ru1=x1(k)-x3(k)
      iu1=y1(k)-y3(k)
      x0(k)=rs0+rs1
      y0(k)=is0+is1
      if(zero) go to 30
      r1=ru0+iu1
      i1=iu0-ru1
      r2=rs0-rs1
      i2=is0-is1
      r3=ru0-iu1
      i3=iu0+ru1
      x2(k)=r1*c1+i1*s1
      y2(k)=i1*c1-r1*s1
      x1(k)=r2*c2+i2*s2
      y1(k)=i2*c2-r2*s2
      x3(k)=r3*c3+i3*s3
      y3(k)=i3*c3-r3*s3
      go to 40
30    x2(k)=ru0+iu1
      y2(k)=iu0-ru1
      x1(k)=rs0-rs1
      y1(k)=is0-is1
      x3(k)=ru0-iu1
      y3(k)=iu0+ru1
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r4cftk.f"
#=======================================================================
echo r5cftk.f
cat >r5cftk.f <<"ENDOF r5cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r5cftk(n,m,x0,y0,x1,y1,x2,y2,x3,y3,x4,y4,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,j,k,k1,kk,l,m,m5,mm5,mover2,n,ns
      real a1,a2,angle,b1,b2,c1,c2,c3,c4,e,fjm1,fm5,i0,i1,i2,i3,i4,ia1,
     & ia2,ib1,ib2,is1,is2,iu1,iu2,ktes,r0,r1,r2,r3,r4,ra1,ra2,rb1,rb2,
     & rs1,rs2,ru1,ru2,s1,s2,s3,s4,t,twopi,x0,x1,x2,x3,x4,y0,y1,y2,y3,y4
      logical fold,zero
      dimension dim(*),x0(*),x1(*),x2(*),x3(*),x4(*),y0(*),y1(*),y2(*),
     & y3(*),y4(*)
      common/fftkte/ twopi,ktes(2),a1,b1,a2,b2,e
cjn uninitialized values
      data c1,c2,c3,c4,s1,s2,s3,s4/0.,0.,0.,0.,0.,0.,0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      m5=m*5
      fm5=m5
      mm5=d2*m5
      mover2=m/2+1
      fjm1=-1.
      do 70 j=1,mover2
      fold=j.gt.1.and.2*j.lt.m+2
      del=(j-1)*d2+1
      fjm1=fjm1+1.
      angle=twopi*fjm1/fm5
      zero=angle.eq.0.
      if(zero) go to 20
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      c3=c2*c1-s2*s1
      s3=s2*c1+c2*s1
      c4=c2*c2-s2*s2
      s4=s2*c2+c2*s2
      go to 20
10    fold=.false.
      del=(m+1-j)*d2+1
      t=c1*a1+s1*b1
      s1=c1*b1-s1*a1
      c1=t
      t=c2*a2+s2*b2
      s2=c2*b2-s2*a2
      c2=t
      t=c3*a2-s3*b2
      s3=-c3*b2-s3*a2
      c3=t
      t=c4*a1-s4*b1
      s4=-c4*b1-s4*a1
      c4=t
20    do 60 kk=del,ns,mm5
      do 50 l=kk,d1,d3
      k1=l+d4
      do 40 k=l,k1,d5
      r0=x0(k)
      i0=y0(k)
      rs1=x1(k)+x4(k)
      is1=y1(k)+y4(k)
      ru1=x1(k)-x4(k)
      iu1=y1(k)-y4(k)
      rs2=x2(k)+x3(k)
      is2=y2(k)+y3(k)
      ru2=x2(k)-x3(k)
      iu2=y2(k)-y3(k)
      x0(k)=r0+rs1+rs2
      y0(k)=i0+is1+is2
      ra1=r0+rs1*a1+rs2*a2
      ia1=i0+is1*a1+is2*a2
      ra2=r0+rs1*a2+rs2*a1
      ia2=i0+is1*a2+is2*a1
      rb1=ru1*b1+ru2*b2
      ib1=iu1*b1+iu2*b2
      rb2=ru1*b2-ru2*b1
      ib2=iu1*b2-iu2*b1
      if(zero) go to 30
      r1=ra1+ib1
      i1=ia1-rb1
      r2=ra2+ib2
      i2=ia2-rb2
      r3=ra2-ib2
      i3=ia2+rb2
      r4=ra1-ib1
      i4=ia1+rb1
      x1(k)=r1*c1+i1*s1
      y1(k)=i1*c1-r1*s1
      x2(k)=r2*c2+i2*s2
      y2(k)=i2*c2-r2*s2
      x3(k)=r3*c3+i3*s3
      y3(k)=i3*c3-r3*s3
      x4(k)=r4*c4+i4*s4
      y4(k)=i4*c4-r4*s4
      go to 40
30    x1(k)=ra1+ib1
      y1(k)=ia1-rb1
      x2(k)=ra2+ib2
      y2(k)=ia2-rb2
      x3(k)=ra2-ib2
      y3(k)=ia2+rb2
      x4(k)=ra1-ib1
      y4(k)=ia1+rb1
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r5cftk.f"
#=======================================================================
echo r8cftk.f
cat >r8cftk.f <<"ENDOF r8cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r8cftk(n,m,x0,y0,x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6,
     & x7,y7,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,j,k,k1,kk,l,m,m8,mm8,mover2,n,ns
      real angle,c1,c2,c3,c4,c5,c6,c7,e,fjm1,fm8,i1,i2,i3,i4,i5,i6,i7,
     & is0,is1,is2,is3,iss0,iss1,isu0,isu1,iu0,iu1,iu2,iu3,ius0,ius1,
     & iuu0,iuu1,ktes,r1,r2,r3,r4,r5,r6,r7,rs0,rs1,rs2,rs3,rss0,rss1,
     & rsu0,rsu1,ru0,ru1,ru2,ru3,rus0,rus1,ruu0,ruu1,s1,s2,s3,s4,s5,s6,
     & s7,t,twopi,x0,x1,x2,x3,x4,x5,x6,x7,y0,y1,y2,y3,y4,y5,y6,y7
      logical fold,zero
      dimension dim(*),x0(*),x1(*),x2(*),x3(*),x4(*),x5(*),x6(*),x7(*),
     & y0(*),y1(*),y2(*),y3(*),y4(*),y5(*),y6(*),y7(*)
      common/fftkte/ twopi,ktes(6),e
cjn uninitialized values
      data c1,c2,c3,c4,c5,c6,c7,s1,s2,s3,s4,s5,s6,s7
     & /0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      m8=m*8
      fm8=m8
      mm8=d2*m8
      mover2=m/2+1
      fjm1=-1.
      do 70 j=1,mover2
      fold=j.gt.1.and.2*j.lt.m+2
      del=(j-1)*d2+1
      fjm1=fjm1+1.
      angle=twopi*fjm1/fm8
      zero=angle.eq.0.
      if(zero) go to 20
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      c3=c2*c1-s2*s1
      s3=s2*c1+c2*s1
      c4=c2*c2-s2*s2
      s4=s2*c2+c2*s2
      c5=c4*c1-s4*s1
      s5=s4*c1+c4*s1
      c6=c4*c2-s4*s2
      s6=s4*c2+c4*s2
      c7=c4*c3-s4*s3
      s7=s4*c3+c4*s3
      go to 20
10    fold=.false.
      del=(m+1-j)*d2+1
      t=(c1+s1)*e
      s1=(c1-s1)*e
      c1=t
      t=s2
      s2=c2
      c2=t
      t=(-c3+s3)*e
      s3=(c3+s3)*e
      c3=t
      c4=-c4
      t=-(c5+s5)*e
      s5=(-c5+s5)*e
      c5=t
      t=-s6
      s6=-c6
      c6=t
      t=(c7-s7)*e
      s7=-(c7+s7)*e
      c7=t
20    do 60 kk=del,ns,mm8
      do 50 l=kk,d1,d3
      k1=l+d4
      do 40 k=l,k1,d5
      rs0=x0(k)+x4(k)
      is0=y0(k)+y4(k)
      ru0=x0(k)-x4(k)
      iu0=y0(k)-y4(k)
      rs1=x1(k)+x5(k)
      is1=y1(k)+y5(k)
      ru1=x1(k)-x5(k)
      iu1=y1(k)-y5(k)
      rs2=x2(k)+x6(k)
      is2=y2(k)+y6(k)
      ru2=x2(k)-x6(k)
      iu2=y2(k)-y6(k)
      rs3=x3(k)+x7(k)
      is3=y3(k)+y7(k)
      ru3=x3(k)-x7(k)
      iu3=y3(k)-y7(k)
      rss0=rs0+rs2
      iss0=is0+is2
      rsu0=rs0-rs2
      isu0=is0-is2
      rss1=rs1+rs3
      iss1=is1+is3
      rsu1=rs1-rs3
      isu1=is1-is3
      rus0=ru0-iu2
      ius0=iu0+ru2
      ruu0=ru0+iu2
      iuu0=iu0-ru2
      rus1=ru1-iu3
      ius1=iu1+ru3
      ruu1=ru1+iu3
      iuu1=iu1-ru3
      t=(rus1+ius1)*e
      ius1=(ius1-rus1)*e
      rus1=t
      t=(ruu1+iuu1)*e
      iuu1=(iuu1-ruu1)*e
      ruu1=t
      x0(k)=rss0+rss1
      y0(k)=iss0+iss1
      if(zero) go to 30
      r1=ruu0+ruu1
      i1=iuu0+iuu1
      r2=rsu0+isu1
      i2=isu0-rsu1
      r3=rus0+ius1
      i3=ius0-rus1
      r4=rss0-rss1
      i4=iss0-iss1
      r5=ruu0-ruu1
      i5=iuu0-iuu1
      r6=rsu0-isu1
      i6=isu0+rsu1
      r7=rus0-ius1
      i7=ius0+rus1
      x4(k)=r1*c1+i1*s1
      y4(k)=i1*c1-r1*s1
      x2(k)=r2*c2+i2*s2
      y2(k)=i2*c2-r2*s2
      x6(k)=r3*c3+i3*s3
      y6(k)=i3*c3-r3*s3
      x1(k)=r4*c4+i4*s4
      y1(k)=i4*c4-r4*s4
      x5(k)=r5*c5+i5*s5
      y5(k)=i5*c5-r5*s5
      x3(k)=r6*c6+i6*s6
      y3(k)=i6*c6-r6*s6
      x7(k)=r7*c7+i7*s7
      y7(k)=i7*c7-r7*s7
      go to 40
30    x4(k)=ruu0+ruu1
      y4(k)=iuu0+iuu1
      x2(k)=rsu0+isu1
      y2(k)=isu0-rsu1
      x6(k)=rus0+ius1
      y6(k)=ius0-rus1
      x1(k)=rss0-rss1
      y1(k)=iss0-iss1
      x5(k)=ruu0-ruu1
      y5(k)=iuu0-iuu1
      x3(k)=rsu0-isu1
      y3(k)=isu0+rsu1
      x7(k)=rus0-ius1
      y7(k)=ius0+rus1
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r8cftk.f"
#=======================================================================
echo rbinv.f
cat >rbinv.f <<"ENDOF rbinv.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rbinv(a,ai)
      implicit none
      integer i,i1,ii,j,j1,jj
      real a,ai,c,d,x
      dimension a(3,3),ai(3,3),c(3,3),x(3,3)
      do 40 ii=1,3
      do 30 jj=1,3
      i=0
      do 20 i1=1,3
      if(i1.eq.ii)go to 20
      i=i+1
      j=0
      do 10 j1=1,3
      if(j1.eq.jj)go to 10
      j=j+1
      x(i,j)=a(i1,j1)
10    continue
20    continue
      c(ii,jj)=(-1)**(ii+jj)*(x(1,1)*x(2,2)-x(1,2)*x(2,1))
30    continue
40    continue
      d=0
      do 50 i=1,3
      d=d+a(i,1)*c(i,1)
50    continue
      do 70 i=1,3
      do 60 j=1,3
      ai(i,j)=c(j,i)/d
60    continue
70    continue
      return
      end
"ENDOF rbinv.f"
#=======================================================================
echo realft.f
cat >realft.f <<"ENDOF realft.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine realft(n,dim,even,odd)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,i,i0,i1,i2,j,k,n,ns2,ns4
      real a,angle,b,c,co,d,e,even,f,ktes,odd,si,twopi
      dimension dim(*),even(*),odd(*)
      common/fftkte/ twopi,ktes(7)
      ns2=n/2
      call cmplft(ns2,dim,even,odd)
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns4=ns2/2
      if(ns4.lt.1) go to 40
      do 30 i=1,ns4
      del=(ns2-2*i)*d2
      angle=i*twopi/n
      co=cos(angle)
      si=sin(angle)
      i0=i*d2+1
      do 20 i1=i0,d1,d3
      i2=i1+d4
      do 10 j=i1,i2,d5
      k=j+del
      a=(even(k)+even(j))/2.
      b=(even(k)-even(j))/2.
      c=(odd(k)+odd(j))/2.
      d=(odd(k)-odd(j))/2.
      e=b*co-c*si
      f=b*si+c*co
      even(j)=a+f
      even(k)=a-f
      odd(j)=e-d
      odd(k)=e+d
10    continue
20    continue
30    continue
40    if(ns2.lt.1) return
      do 60 i1=1,d1,d3
      i2=i1+d4
      do 50 j=i1,i2,d5
      even(j)=even(j)+odd(j)
      odd(j)=0.
50    continue
60    continue
      return
      end
"ENDOF realft.f"
#=======================================================================
echo reffo.f
cat >reffo.f <<"ENDOF reffo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine reffo(o1,nd,hklo)
      implicit none
      integer h,hklo,hlw,hmax,hmin,hrmax,hup,i,iecr,ilec,index,iout,
     & ires,j,k,klw,kmax,kmin,kprt,krmax,kup,l,llw,lmax,lmin,lrmax,lup,
     & mult,nd,nra,nrt,ntot,nxyz,o1
      real a11,a21,a22,a31,a32,a33,demax,demin,drmax,drmin,rbid1,sqh,
     & sqhmax,sqhsup
      character cbid1*1
      logical deja,exts
      dimension hklo(nd)
      common/dfft/ hlw,hup,klw,kup,llw,lup,nra,nxyz
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/reso/ drmax,drmin,demax,demin,rbid1(2)
      common/star/ a11,a21,a22,a31,a32,a33
      hlw=0
      hup=0
      klw=0
      kup=0
      llw=0
      lup=0
      nra=0
      nrt=0
      ntot=0
      sqhmax=(1/drmin)**2
      sqhsup=0.
      call indexm(drmin,hmax,kmax,lmax)
      hmin=0
      kmin=-kmax
      lmin=-lmax
      index=0
      j=0
      rewind(unit=o1)
c pacote
      do 30 l=lmin,lmax
      do 20 k=kmin,kmax
      do 10 h=hmin,hmax
      call sympac(h,k,l,index,deja,exts)
      if(deja.or.exts) go to 10
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.sqhmax) go to 10
      call pac3(h,k,l,index)
      call multes(h,k,l,mult,ires)
      nrt=nrt+mult
      if(h.lt.hlw) hlw=h
      if(h.gt.hup) hup=h
      if(k.lt.klw) klw=k
      if(k.gt.kup) kup=k
      if(l.lt.llw) llw=l
      if(l.gt.lup) lup=l
      if(sqh.gt.sqhsup) sqhsup=sqh
      nra=nra+1
      j=j+1
      hklo(j)=index
         if(j.eq.nd) then
      write(o1) j,hklo
      ntot=ntot+j
      j=0
         endif
10    continue
20    continue
30    continue
         if(ntot.ne.0) then
      if(j.ne.0) write(o1) j,hklo
         else
      write(o1) j,(hklo(i),i=1,j)
      nd=j
         endif
      if(nra.eq.0) go to 901
      nrt=nrt/2+mod(nrt,2)
      demin=sqrt(1/sqhsup)
      call indexm(drmin,hrmax,krmax,lrmax)
      if(kprt.ne.0) write(iecr,2010) nra,nd,nrt
      if(kprt.ne.0) write(iecr,2020) drmin,hrmax,krmax,lrmax
      if(kprt.ne.0) write(iecr,2030) demin,hlw,hup,klw,kup,llw,lup
      demin=drmin
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
2010  format(/i10,' coefficients selected, packed by',i10/
     . ' number of coefficients when extended to p1 =',i10)
2020  format(' requested resolution =',f10.3/
     . ' maximal indices according to requested resolution =',3i5)
2030  format(' data resolution =',f10.3/' maximal indices in data'/
     . ' hmin, hmax =',2i5,', kmin, kmax =',2i5,', lmin, lmax =',2i5)
3010  format('stop >> reffo << no coefficient selected')
      end
"ENDOF reffo.f"
#=======================================================================
echo rmsq.f
cat >rmsq.f <<"ENDOF rmsq.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program rmsq
      implicit none
      integer i1,i2,iecr,ilec,iout,kprt,kprtt,length,ma,n,na,na1,nprt
      real dtor,lxy,pi,qxy,rr,rtod,twopi
      character aa*4,cbid1*1,lun*80
      external length
      parameter(ma=500000)
      dimension aa(2*ma),lxy(6),qxy(6,6),rr(6*ma)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/oprt/ kprtt(10)
      data i1,i2/98,99/
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      iout=9
       do n=1,10
      kprtt(n)=0
       enddo
      write(iecr,'(a)') ' enter printing flags [N  1 0 ... ]'
      read(ilec,'(a)') lun
         if(length(lun).ne.0) then
      read(lun,*) nprt,(kprtt(n),n=1,nprt)
         endif
10    write(iecr,'(a)') ' enter the target-coord [y] filename'
      read(ilec,'(a)',end=20) lun
      if(lun(1:3).eq.'end'.or.lun(1:3).eq.'   ') go to 20
      open(unit=i1,file=lun,form='formatted',status='old')
      write(iecr,'(a,a)') ' target file =',lun(1:40)
      write(iecr,'(a)') ' enter the search-coord [x] filename'
      read(ilec,'(a)') lun
      open(unit=i2,file=lun,form='formatted',status='old')
      write(iecr,'(a,a)') ' search file =',lun(1:40)
      call cordin(i2,ma,aa(1),rr(1),na)
      close(unit=i2)
      call cordin(i1,ma,aa(1+na),rr(1+3*na),na1)
      close(unit=i1)
         if(na1.ne.na) then
      write(iecr,3001) na1,na
      go to 10
         endif
      call quanta(na,rr(1),rr(1+3*na),qxy,lxy)
      call lsqfit(lxy,qxy)
      go to 10
20    stop
3001  format(/' >> warning << different nb. of atoms =',2i10)
      end
"ENDOF rmsq.f"
#=======================================================================
echo rmx2e.f
cat >rmx2e.f <<"ENDOF rmx2e.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmx2e(rote,alpha,beta,gamma)
      implicit none
      integer i,iecr,ilec,iout,j,kprt
      real alpha,beta,dtor,fuzz,gamma,pi,rote,rtod,twopi
      double precision ang,cang,rotx,sang
      character cbid1*1
      dimension rote(3,3),rotx(3,3)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      data fuzz/0.001/
       do i=1,3
        do j=1,3
      rotx(i,j)=dble(rote(i,j))
        enddo
       enddo
      cang=sqrt(min(max(2.d0-(rotx(1,3)**2+rotx(2,3)**2+rotx(3,1)**2+
     . rotx(3,2)**2+rotx(3,3)**2),0.d0),1.d0))
      ang=acos(sign(cang,rotx(3,3)))
      sang=sin(ang)
         if(sang.gt.fuzz) then
      alpha=atan2(rotx(2,3),rotx(1,3))
      gamma=atan2(rotx(3,2),-rotx(3,1))
         else
      alpha=atan2(-rotx(1,2),rotx(1,1)*rotx(3,3))
      gamma=0.
         endif
      alpha=mod(twopi+alpha,twopi)*rtod
      beta=ang*rtod
      gamma=mod(twopi+gamma,twopi)*rtod
      if(kprt.ne.0) write(iecr,'(a,3f10.3)')
     . ' euler; alpha,beta,gamma =',alpha,beta,gamma
      return
      end
"ENDOF rmx2e.f"
#=======================================================================
echo rmx2p.f
cat >rmx2p.f <<"ENDOF rmx2p.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmx2p(rote,xhi,vn)
      implicit none
      integer i,iecr,ilec,iout,j,kprt
      real dtor,fuzz,pi,rote,rtod,twopi,vn,vnorm,xhi
      double precision ang,cang,rotx,sang,scale,vecx
      character cbid1*1
      dimension rote(3,3),rotx(3,3),vecx(3),vn(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      data fuzz/0.001/
       do i=1,3
        do j=1,3
      rotx(i,j)=dble(rote(i,j))
        enddo
       enddo
      cang=min(max((rotx(1,1)+rotx(2,2)+rotx(3,3)-1)/2,-1.d0),1.d0)
      ang=acos(cang)
      sang=sin(ang)
         if(sang.gt.fuzz) then
      scale=2*sang
      vecx(1)=(rotx(3,2)-rotx(2,3))/scale
      vecx(2)=(rotx(1,3)-rotx(3,1))/scale
      vecx(3)=(rotx(2,1)-rotx(1,2))/scale
         else
            if(cang.gt.0.) then
      vecx(1)=0.d0
      vecx(2)=0.d0
      vecx(3)=1.d0
            else
       do i=1,3
      vecx(i)=sqrt(max((rotx(i,i)+1)/2,0.d0))
       enddo
               if(vecx(3).gt.fuzz) then
      vecx(1)=sign(vecx(1),rotx(1,3))
      vecx(2)=sign(vecx(2),rotx(2,3))
               else if(vecx(2).gt.fuzz) then
      vecx(1)=sign(vecx(1),rotx(1,2))
               endif
            endif
         endif
      xhi=ang*rtod
       do i=1,3
      vn(i)=vecx(i)
       enddo
      vnorm=vecx(1)**2+vecx(2)**2+vecx(3)**2
      if(kprt.ne.0) write(iecr,'(a,f10.3,3f10.6,f10.6)')
     . ' polar; xhi,versor,norm =',xhi,vn,vnorm
      return
      end
"ENDOF rmx2p.f"
#=======================================================================
echo rmxe.f
cat >rmxe.f <<"ENDOF rmxe.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmxe(alpha,beta,gamma,rotx)
      implicit none
      integer iecr,ilec,iout,kprt
      real alf,alpha,bet,beta,cosa,cosb,cosg,dtor,gam,gamma,pi,rotx,
     & rtod,sina,sinb,sing,twopi
      character cbid1*1
      dimension rotx(3,3)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      if(kprt.ne.0) write(iecr,'(a,3f10.3)')
     . ' euler matrix; alpha,beta,gamma =',alpha,beta,gamma
      alf=alpha*dtor
      bet=beta*dtor
      gam=gamma*dtor
      cosa=cos(alf)
      cosb=cos(bet)
      cosg=cos(gam)
      sina=sin(alf)
      sinb=sin(bet)
      sing=sin(gam)
      rotx(1,1)= cosa*cosb*cosg-sina*sing
      rotx(1,2)=-cosa*cosb*sing-sina*cosg
      rotx(1,3)= cosa*sinb
      rotx(2,1)= sina*cosb*cosg+cosa*sing
      rotx(2,2)=-sina*cosb*sing+cosa*cosg
      rotx(2,3)= sina*sinb
      rotx(3,1)=     -sinb*cosg
      rotx(3,2)=      sinb*sing
      rotx(3,3)=      cosb
      return
      end
"ENDOF rmxe.f"
#=======================================================================
echo rmxp.f
cat >rmxp.f <<"ENDOF rmxp.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmxp(xhi,vn,rotx)
      implicit none
      integer eijk,i,j,k
      real ang,cang,dtor,pi,rotx,rtod,sang,twopi,vn,xhi
      dimension eijk(3,3,3),rotx(3,3),vn(3)
      common/angkte/ pi,twopi,dtor,rtod
      data eijk/
     & 0,0,0,0,0,-1,0,1,0,0,0,1,0,0,0,-1,0,0,0,-1,0,1,0,0,0,0,0/
      ang=xhi*dtor
      cang=cos(ang)
      sang=sin(ang)
       do j=1,3
        do i=1,3
      rotx(i,j)=(1-cang)*vn(i)*vn(j)
      if(i.eq.j) rotx(i,j)=rotx(i,j)+cang
         do k=1,3
         if(eijk(i,k,j).eq.1) then
      rotx(i,j)=rotx(i,j)+sang*vn(k)
         else if(eijk(i,k,j).eq.-1) then
      rotx(i,j)=rotx(i,j)-sang*vn(k)
         endif
         enddo
        enddo
       enddo
      return
      end
"ENDOF rmxp.f"
#=======================================================================
echo rs.f
cat >rs.f <<"ENDOF rs.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rs(nm,n,a,w,z,fv1,fv2,matz,ierr)
      implicit none
      integer ierr,matz,n,nm
      real a,fv1,fv2,w,z
      dimension a(nm,n),fv1(n),fv2(n),w(n),z(nm,n)
      if(n.le.nm) go to 10
      ierr=10*n
      go to 50
10    if(matz.ne.0) go to 20
      call tred1(nm,n,a,w,fv1,fv2)
      call tqlrat(n,w,fv2,ierr)
      go to 50
20    call tred2(nm,n,a,w,fv1,z)
      call tql2(nm,n,w,fv1,z,ierr)
50    return
      end
"ENDOF rs.f"
#=======================================================================
echo rt2pv.f
cat >rt2pv.f <<"ENDOF rt2pv.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program rt2pv
      implicit none
      integer bod,i,i0,id,iecr,ilec,incs,ind,iout,j,kprt,lungo,mss,ncm,
     & ncs,neq,nlungo,nmol,nort,nts,tbod
      real a,al,al0,alpha,b,be,be0,beta,c,c0,dtor,ga,ga0,gamma,pi,r,r0,
     & rbid1,rf,ro,rtod,rx,t,tss,tts,twopi,tx
      character card*4000,cart*4000,forme*40,formr*40,zn*1
      external lungo
      parameter(ncm=1000)
      dimension c0(3,100),cart(200),i0(100),incs(ncm),r(3,3),r0(9,100),
     & rx(3,3),t(3),tx(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ortm/ ro(3,3),rf(3,3),nort
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      data i0/100*0/,c0/300*0./,r0/900*0./,nlungo/4000/
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      kprt=0
      iout=9
      zn='#'
      formr='(2x,i2,       6f10.3                   )'
      forme='(1x,a1,i2,3f7.1,3f8.4,1x,    401i4     )'
      id=8
      call abra(id,'f','u',0)
      rewind(unit=id)
      read(id,*)
      read(id,*) a,b,c,alpha,beta,gamma
      call celda
      neq=1
      nts=0
       do i=1,3
        do j=1,3
      mss(i,j,1)=0.
        enddo
       enddo
       do i=1,3
      tss(i,1)=0.
      tts(i,1)=0.
      mss(i,i,1)=1.
       enddo
      read(id,*)
      read(id,*) nort
      call ortho
      nmol=0
10    read(ilec,'(a)',end=30) card
      if(lungo(card,nlungo).eq.0) go to 30
      nmol=nmol+1
      ind=index(card,'#')
      card(ind:ind)=' '
c lectura interna
      read(card,*) bod,al,be,ga,tx,ncs,(incs(i),i=1,ncs)
         if(i0(bod).eq.0) then
      tbod=bod+10
      i0(bod)=1
      call abra(tbod,'f','u',0)
      rewind(unit=tbod)
20    read(tbod,'(a)') card
      if(card(1:7).ne.' center') go to 20
c lectura interna
      read(card(18:80),*) (c0(i,bod),i=1,3)
      read(tbod,'(17x,3f9.2)') al0,be0,ga0
      call rmxe(180.-ga0,be0,180.-al0,r0(1,bod))
      call cierre(tbod,'f')
         endif
      call rmxe(al,be,ga,rx)
      call pro2mx(r,rx,r0(1,bod))
      call rmx2e(r,al,be,ga)
       do i=1,3
        do j=1,3
      tx(i)=tx(i)+rx(i,j)*c0(j,bod)
        enddo
       enddo
       do i=1,3
      t(i)=0.
        do j=1,3
      t(i)=t(i)+rf(i,j)*tx(j)
        enddo
       enddo
      write(cart(nmol),forme) zn,bod,al,be,ga,t,ncs,(incs(i),i=1,ncs)
cjn cambiar cuando se cambia forme
      call compakt(cart(nmol)(3:nlungo),nlungo-2)
      go to 10
30    continue
      write(iecr,'(a)') 'fiting:  rt2pv'
      write(iecr,'(2i10)') nmol,1
       do i=1,nmol
      write(iecr,'(a)') cart(i)(1:lungo(cart(i),nlungo))
       enddo
      stop
      end
"ENDOF rt2pv.f"
#=======================================================================
echo rtmsq.f
cat >rtmsq.f <<"ENDOF rtmsq.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rtmsq(qq,u,qr)
      implicit none
      integer i
      real qq,qr,u
      dimension qq(3,3),u(3)
      qr=0.
       do i=1,3
      qr=qr+qq(i,i)*(1.-u(i)*u(i))
       enddo
      qr=2.*qr
      return
      end
"ENDOF rtmsq.f"
#=======================================================================
echo rz1.f
cat >rz1.f <<"ENDOF rz1.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rz1(nx,ny,pz,zs,rr)
      implicit none
      integer i,i1,io1,j,k,mx,my,mz,nx,ny,o1,pz,xlw,xup,ylw,yup,zlw,zs,
     & zup
      real alpha,beta,gamma,rbid1,rr,xlow,xsup
      dimension rr(nx,ny,pz),xlow(3),xsup(3)
      common/dfftx/ rbid1(6),xlw,ylw,zlw,xup,yup,zup
      common/tapes/ i1,io1,o1
         if(zs.eq.zlw) then
      rewind(unit=i1)
      read(i1) mx,my,mz,xlow,xsup,alpha,beta,gamma
         endif
      do 30 k=1,pz
      do 20 j=1,ny
      do 10 i=1,nx
      rr(i,j,k)=0.
10    continue
20    continue
30    continue
      do 40 k=1,pz
      read(i1) ((rr(i,j,k),i=xlw+1,xup+1),j=1,ny)
40    continue
      return
      end
"ENDOF rz1.f"
#=======================================================================
echo select.f
cat >select.f <<"ENDOF select.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program select
      implicit none
      integer id,ids,iecr,ilec,ind,ind1,ind2,ind3,indl,long,lungo,mod,
     & mol,mols,n,nfield,nlungo
      real high,low,res
      character card*4000,field*20,lectura*4000
      external lungo
      dimension ids(100),mols(100)
      data ilec,iecr/5,6/,nlungo/4000/
      read(ilec,'(a)') card
      if(lungo(card,nlungo).eq.0) go to 901
c #######################
      nfield=0
10    call compakt(card,nlungo)
      nfield=nfield+1
      ind1=index(card,'--')
      ind2=index(card,'=')
      card(ind1:ind1+1)='  '
         if(nfield.lt.3) then
      ind3=index(card,'--')-1
      if(ind3.le.0) go to 901
         else
      ind3=lungo(card,nlungo)
         endif
       do n=1,20
      field(n:n)=' '
       enddo
      field(1:ind2-ind1-2)=card(ind1+2:ind2-1)
      call compakt(field,20)
       do n=1,nlungo
      lectura(n:n)=' '
       enddo
      lectura(1:ind3-ind2)=card(ind2+1:ind3)
      call compakt(lectura,nlungo)
       do n=1,ind3
      card(n:n)=' '
       enddo
c ### EMAP ##############
         if(index(field,'emap').ne.0) then
      long=lungo(lectura,nlungo)
      write(iecr,'(a,a)') 'EMAP=',lectura(1:long)
c ### MODELS ############
         else if(index(field,'model').ne.0) then
      mod=0
      mol=0
20    long=lungo(lectura,nlungo)
            if(long.gt.0) then
      mod=mod+1
      indl=index(lectura,',')
               if(indl.eq.0) then
      indl=long
               else
      lectura(indl:indl)=' '
               endif
      ind1=index(lectura,':')
      lectura(ind1:ind1)=' '
      read(lectura(ind1:indl),*) n
      ind2=index(lectura(1:indl),'#')
               if(ind2.eq.0) then
      ind2=indl
      id=mod
               else
      lectura(ind2:ind2)=' '
      read(lectura(ind2:indl),*) id
               endif
      ind=min(ind1,ind2)
      write(iecr,'(a,a)') 'MODELS=',lectura(1:ind)
      mol=mol+n
      mols(mod)=n
      ids(mod)=id
       do n=1,min(indl,long)
      lectura(n:n)=' '
       enddo
      call compakt(lectura,nlungo)
      go to 20
            endif
      write(iecr,'(a,100i3)') 'MOLECULES=',mod,(mols(n),n=1,mod)
      write(iecr,'(a,100i3)') 'IDENTIFYS=',(ids(n),n=1,mod)
c ### RESOLUTION ########
         else if(index(field,'resol').ne.0) then
      long=lungo(lectura,nlungo)
      ind=index(lectura,',')
      if(ind.ne.0) lectura(ind:ind)=' '
      read(lectura(1:long),*) low,high
            if(low.lt.high) then
      res=low
      low=high
      high=res
            endif
      write(iecr,'(a,2f7.2)') 'RESOLUTION=',low,high
c ### ERROR #############
         else
      go to 901
         endif
      if(nfield.lt.3) go to 10
      stop
901   write(iecr,3010)
      stop
3010  format('stop >> select << Usage:'/
     . './select --emap=emap.ezd'/
     . '--models=mod1.pdb:2,mod2.map:2'/
     . '--resolution=400.0,15.0')
      end
"ENDOF select.f"
#=======================================================================
echo setmat.f
cat >setmat.f <<"ENDOF setmat.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine setmat(alpha,beta,gamma,tx,ty,tz)
      implicit none
      integer nort
      real alf,alpha,bet,beta,cosa,cosb,cosg,dm,dmd,dtor,gam,gamma,pi,
     & rf,ro,rtod,rx,sina,sinb,sing,tr,twopi,tx,ty,tz
      dimension rx(3,3)
      common/angkte/ pi,twopi,dtor,rtod
      common/ortm/ ro(9),rf(9),nort
      common/rotra/ dm(3,3),dmd(3,3,3),tr(3)
      tr(1)=tx
      tr(2)=ty
      tr(3)=tz
      alf=dtor*alpha
      bet=dtor*beta
      gam=dtor*gamma
      cosa=cos(alf)
      cosb=cos(bet)
      cosg=cos(gam)
      sina=sin(alf)
      sinb=sin(bet)
      sing=sin(gam)
      rx(1,1)= cosa*cosb*cosg-sina*sing
      rx(1,2)=-cosa*cosb*sing-sina*cosg
      rx(1,3)= cosa*sinb
      rx(2,1)= sina*cosb*cosg+cosa*sing
      rx(2,2)=-sina*cosb*sing+cosa*cosg
      rx(2,3)= sina*sinb
      rx(3,1)=     -sinb*cosg
      rx(3,2)=      sinb*sing
      rx(3,3)=      cosb
      call pro3mx(dm(1,1),rf,rx,ro)
      rx(1,1)=-sina*cosb*cosg-cosa*sing
      rx(1,2)= sina*cosb*sing-cosa*cosg
      rx(1,3)=-sina*sinb
      rx(2,1)= cosa*cosb*cosg-sina*sing
      rx(2,2)=-cosa*cosb*sing-sina*cosg
      rx(2,3)= cosa*sinb
      rx(3,1)= 0.
      rx(3,2)= 0.
      rx(3,3)= 0.
      call pro2mx(dmd(1,1,1),rx,ro)
      rx(1,1)=-cosa*sinb*cosg
      rx(1,2)= cosa*sinb*sing
      rx(1,3)= cosa*cosb
      rx(2,1)=-sina*sinb*cosg
      rx(2,2)= sina*sinb*sing
      rx(2,3)= sina*cosb
      rx(3,1)=     -cosb*cosg
      rx(3,2)=      cosb*sing
      rx(3,3)=     -sinb
      call pro2mx(dmd(1,1,2),rx,ro)
      rx(1,1)=-cosa*cosb*sing-sina*cosg
      rx(1,2)=-cosa*cosb*cosg+sina*sing
      rx(1,3)= 0.
      rx(2,1)=-sina*cosb*sing+cosa*cosg
      rx(2,2)=-sina*cosb*cosg-cosa*sing
      rx(2,3)= 0.
      rx(3,1)=      sinb*sing
      rx(3,2)=      sinb*cosg
      rx(3,3)= 0.
      call pro2mx(dmd(1,1,3),rx,ro)
      return
      end
"ENDOF setmat.f"
#=======================================================================
echo setpak.f
cat >setpak.f <<"ENDOF setpak.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine setpak
      implicit none
      integer hm,hs,ibid1,id,iecr,ilec,iout,km,kprt,ks,lm,ls,maxint,mh,
     & mk,ml,neq,nh,nk,nl,nm,nts
      real a,b,c,rbid1,rbid2,xlam
      character cbid1*1
      common/cell/ a,b,c,rbid1(19)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/paco/ hm,km,lm,nh,nk,nl,nm
      common/paco3/ hs,ks,ls,mh,mk,ml,maxint
      common/simt/ rbid2(153),ibid1(432),neq,nts
      maxint=(2**30)+(2**30-1)
      id=maxint/(2*neq+1)
      xlam=(id/(a*b*c))**(1./3)
      hm=xlam*a/2-1
      km=xlam*b/2-1
      lm=xlam*c/2-1
      nh=xlam*a
      nk=xlam*b
      nl=xlam*c
      nm=2*neq+1
      if(kprt.ne.0) write(iecr,2010) 2/xlam
      id=maxint
      xlam=(id/(a*b*c))**(1./3)
      hs=xlam*a/2-1
      ks=xlam*b/2-1
      ls=xlam*c/2-1
      mh=xlam*a
      mk=xlam*b
      ml=xlam*c
      return
2010  format(/' setpak. maximal resolution allowed =',f10.6)
      end
"ENDOF setpak.f"
#=======================================================================
echo setsca.f
cat >setsca.f <<"ENDOF setsca.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine setsca(is,nra,hkl,hsq,foc,fc,first)
      implicit none
      integer h,hkl,ibid1,iecr,ilec,iout,is,k,kprt,l,mult,n,nra,ntot
      real bfact,c0,c2,c4,cc,corf,cori,corp,d0,d2,d4,db,dbo,dc,desc,f,
     & f2,fo,fo2,hess,hsq,q,qdh,rfli,rfsq,scale,sfli,sfqu,sfsq,sfsq0,
     & sqh,xnorm,ynorm
      complex cf,cfo,fc,foc,mf
      character cbid1*1
      logical first
      dimension fc(nra),foc(nra),hkl(nra),hsq(nra)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/numo/ ntot,ibid1(6)
      common/pote/ sfli,sfsq,sfqu,rfli,rfsq,corf,cori,corp,scale,bfact
      save sfsq0
cjn uninitialized values
      data dbo/0./
         if(first) then
      sfsq0=sfsq
      bfact=0.
      first=.false.
         endif
      rfsq=1.e5
10    d0=0.
      d2=0.
      d4=0.
      c0=0.
      c2=0.
      c4=0.
      do 20 n=1,nra
      call unpac4(h,k,l,mult,hkl(n))
      cf=fc(n)
      if(is.ne.0) cf=cf*exp(bfact*hsq(n))
      f=abs(cf)
      fo=abs(foc(n))
      dc=mult*f*fo
      cc=mult*f*f
         if(is.ne.0) then
      sqh=hsq(n)
      qdh=sqh*sqh
      d2=d2+dc*sqh
      c2=c2+cc*sqh
      d4=d4+dc*qdh
      c4=c4+cc*qdh
         endif
      d0=d0+dc
      c0=c0+cc
20    continue
         if(is.ne.0) then
      q=1.-d0*d0/(c0*sfsq0)
            if(q.lt.rfsq) then
      rfsq=q
      desc=d2*c0-d0*c2
      hess=-(d4*c0+d2*c2-2*d0*c4)
      if(hess.lt.0.) hess=-hess
      db=desc/hess
      if(abs(db).gt.0.625) db=sign(0.625,db)
      dbo=db
            else
      db=-dbo/2.
      dbo=-db
            endif
      bfact=bfact+db
      if(abs(db).gt.0.025) go to 10
         endif
      scale=c0/d0
      d0=0.
      c0=0.
      d2=0.
      c2=0.
      rfli=0.
      sfli=0.
      sfsq=0.
      sfqu=0.
      do 30 n=1,nra
      call unpac4(h,k,l,mult,hkl(n))
      cfo=foc(n)*scale
      if(is.ne.0) cfo=cfo*exp(-bfact*hsq(n))
      fo=abs(cfo)
      fo2=fo*fo
      cf=fc(n)
      f=abs(cf)
      f2=f*f
      rfli=rfli+mult*abs(f-fo)
      mf=mult*conjg(cf)
      d0=d0+real(mf*cfo)
      c0=c0+real(mf*cf)
      d2=d2+mult*f2*fo2
      c2=c2+mult*f2*f2
      sfli=sfli+mult*fo
      sfsq=sfsq+mult*fo2
      sfqu=sfqu+mult*fo2*fo2
30    continue
      xnorm=sqrt(1/sfsq)
      ynorm=sqrt(1/sfqu)
      corf=xnorm*d0/sqrt(c0)
      cori=ynorm*d2/sqrt(c2)
      rfli=rfli/sfli
         if(kprt.ne.0) then
      write(iecr,*)
      write(iecr,*) ' calculated scale and b-factor =',scale,bfact*4
      write(iecr,'(a,a,3f10.5)') ' correlation coefficients and ',
     . 'r-factor =',corf*100,cori*100,rfli*100
         endif
      return
      end
"ENDOF setsca.f"
#=======================================================================
echo sgfr.f
cat >sgfr.f <<"ENDOF sgfr.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine sgfr(ixflag)
      implicit none
      integer dt2,h,hh,hkl,i,idet,iecr,ilec,ind1,ind2,indb,indm,iout,
     & ixflag,j,k,kk,kprt,l,ll,m,mcd,md,mdet,mdt1,mdt2,mdt3,met,mr,mss,
     & mult,n,neq,nor,norm,nts,u,v,w
      real cel,rbid1,rbid2
      character cbid1*1
      logical divide,prop
      dimension dt2(10,10),hkl(10),ixflag(3),md(3,3),met(10,10),mr(3,3),
     & nor(10),u(3),v(3),w(3)
      common/cell/ cel(6),rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/simt/ rbid2(153),mss(3,3,48),neq,nts
cjn uninitialized values
      data indb,j/0,0/
      prop=.true.
      mult=0
      do 40 n=1,neq
      mdet=mss(1,1,n)*mss(2,2,n)*mss(3,3,n)
     .+mss(1,2,n)*mss(2,3,n)*mss(3,1,n)+mss(1,3,n)*mss(2,1,n)*mss(3,2,n)
     .-mss(1,3,n)*mss(2,2,n)*mss(3,1,n)-mss(1,2,n)*mss(2,1,n)*mss(3,3,n)
     .-mss(1,1,n)*mss(2,3,n)*mss(3,2,n)
      if(mdet.lt.0) prop=.false.
      do 30 i=1,3
      u(1)=0
      u(2)=0
      u(3)=0
      u(i)=-1
       do j=1,3
      u(j)=u(j)+mss(i,j,n)
       enddo
      h=u(1)
      k=u(2)
      l=u(3)
      if(h.eq.0.and.k.eq.0.and.l.eq.0) go to 30
         if(l.lt.0.or.(l.eq.0.and.(k.lt.0.or.(k.eq.0.and.h.lt.0)))) then
      h=-h
      k=-k
      l=-l
         endif
      call pak3(h,k,l,indm)
      norm=h*h+k*k+l*l
      if(mult.eq.0) go to 20
      do 10 m=1,mult
      if(hkl(m).eq.indm) go to 30
      call unpak3(hh,kk,ll,hkl(m))
         if((hh*h+kk*k+ll*l)**2.eq.nor(m)*norm) then
            if(nor(m).gt.norm) then
      hkl(m)=indm
      nor(m)=norm
            endif
      go to 30
         endif
10    continue
20    mult=mult+1
      hkl(mult)=indm
      nor(mult)=norm
30    continue
40    continue
      ixflag(1)=1
      ixflag(2)=1
      ixflag(3)=1
         if(mult.eq.0) then
            if(neq.eq.1) then
      ixflag(1)=0
      ixflag(2)=0
      ixflag(3)=0
      return
            else
      go to 901
            endif
         endif
       do i=1,mult
      nor(i)=nor(i)*1000+hkl(i)
       enddo
      call sort2(mult,nor(1),hkl(1))
      mdt1=100
      mdt2=100
      mdt3=0
      do 50 i=1,mult
      call unpak3(h,k,l,hkl(i))
      met(i,i)=h*h+k*k+l*l
       do j=1,i-1
      call unpak3(hh,kk,ll,hkl(j))
      met(i,j)=hh*h+kk*k+ll*l
      met(j,i)=met(i,j)
       enddo
      mdt1=min(met(i,i),mdt1)
       do j=1,i-1
      dt2(i,j)=met(i,i)*met(j,j)-met(i,j)*met(j,i)
      if(dt2(i,j).ne.0) mdt2=min(dt2(i,j),mdt2)
        do k=1,j-1
      mdt3=max(met(i,i)*met(j,j)*met(k,k)+met(i,j)*met(j,k)*met(k,i)+
     . met(i,k)*met(j,i)*met(k,j)-met(i,k)*met(j,j)*met(k,i)-
     . met(i,j)*met(j,i)*met(k,k)-met(i,i)*met(j,k)*met(k,j),mdt3)
        enddo
       enddo
50    continue
      if(mdt3.ne.0) return
       do i=1,3
      u(i)=0
      v(i)=0
      w(i)=0
       enddo
      ind1=0
      ind2=0
         if(mdt2.ne.100) then
       do i=2,mult
        do j=1,i-1
            if(dt2(i,j).eq.mdt2) then
               if(met(i,j).eq.0) then
      if(ind1.eq.0) ind1=i*100+j*10+9
               else
      if(ind2.eq.0) ind2=i*100+j*10+9
               endif
            endif
        enddo
       enddo
            if(ind1.ne.0) then
      indb=ind1
            else if(ind2.ne.0) then
      indb=ind2
            endif
      i=indb/100
      j=(indb-i*100)/10
      k=indb-i*100-j*10
      call unpak3(u(1),u(2),u(3),hkl(i))
      call unpak3(v(1),v(2),v(3),hkl(j))
      w(1)=u(2)*v(3)-u(3)*v(2)
      w(2)=u(3)*v(1)-u(1)*v(3)
      w(3)=u(1)*v(2)-u(2)*v(1)
      mcd=max(abs(w(1)),abs(w(2)),abs(w(3)))
60    divide=.true.
       do i=1,3
      if(mod(w(i),mcd).ne.0) divide=.false.
       enddo
            if(.not.divide) then
      mcd=mcd-1
      go to 60
            endif
      w(1)=w(1)/mcd
      w(2)=w(2)/mcd
      w(3)=w(3)/mcd
         else if(mdt1.ne.100) then
      call unpak3(u(1),u(2),u(3),hkl(1))
            if(u(1).ne.0) then
      v(2)=sign(1,u(1))
      w(3)=1
            else if(u(2).ne.0) then
      v(3)=sign(1,u(2))
      w(1)=1
            else if(u(3).ne.0) then
      v(1)=sign(1,u(3))
      w(2)=1
            endif
         endif
      call trip(u,v,w,idet)
         if(idet.lt.0) then
      call unpak3(u(1),u(2),u(3),hkl(j))
      call unpak3(v(1),v(2),v(3),hkl(i))
      idet=-idet
         endif
      do 70 j=1,3
      md(1,j)=u(j)
      md(2,j)=v(j)
      md(3,j)=w(j)
70    continue
      call inv3(md,mr)
         if(mdt2.ne.100) then
            if(mr(1,1).eq.0.and.mr(1,2).eq.0) then
      ixflag(1)=0
            else if(mr(2,1).eq.0.and.mr(2,2).eq.0) then
      ixflag(2)=0
            else if(mr(3,1).eq.0.and.mr(3,2).eq.0) then
      ixflag(3)=0
            else
      ixflag(3)=0
            endif
         else
            if(mr(1,1).eq.0.and.mr(2,1).eq.0) then
      ixflag(1)=0
      ixflag(2)=0
            endif
            if(mr(1,1).eq.0.and.mr(3,1).eq.0) then
      ixflag(1)=0
      ixflag(3)=0
            endif
            if(mr(2,1).eq.0.and.mr(3,1).eq.0) then
      ixflag(2)=0
      ixflag(3)=0
            endif
         endif
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
3010  format('stop >> sgfr << no basis selected')
      end
"ENDOF sgfr.f"
#=======================================================================
echo shift.f
cat >shift.f <<"ENDOF shift.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine shift(ro,qq,al,be,ga,tx,ty,tz,da,db,dg,dx,dy,dz,qd,it,
     & im)
      implicit none
      integer i,iecr,ilec,im,iout,it,j,k,kprt,kprtt,l
      real al,be,da,db,dg,dt,dto,dx,dy,dz,ga,qa,qd,qq,qt,r0,r1,r2,ro,tx,
     & ty,tz
      double precision add,dqq,dr0
      character cbid1*1
      dimension dqq(3,3),dr0(3,3),dt(3),dto(3),qq(3,3),r0(3,3),r1(3,3),
     & r2(3,3),ro(3,3)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      kprtt=kprt
      kprt=0
      call rmxe(al,be,ga,r0)
      al=al+da
      be=be+db
      ga=ga+dg
      call rmxe(180-ga,be,180-al,r1)
      call pro2mx(r2,r0,r1)
       do i=1,3
        do j=1,3
      dr0(i,j)=r0(i,j)
      dqq(i,j)=qq(i,j)
        enddo
       enddo
      qa=0.
       do i=1,3
      qa=qa+qq(i,i)
        do j=1,3
      add=0.
         do k=1,3
          do l=1,3
      add=add+dr0(i,k)*dr0(j,l)*dqq(k,l)
          enddo
         enddo
      qa=qa-r2(i,j)*add
        enddo
       enddo
      qa=2*qa
      dt(1)=dx
      dt(2)=dy
      dt(3)=dz
      qt=0.
       do i=1,3
      dto(i)=0.
        do j=1,3
      dto(i)=dto(i)+ro(i,j)*dt(j)
        enddo
      qt=qt+dto(i)*dto(i)
       enddo
      tx=tx+dx
      ty=ty+dy
      tz=tz+dz
      qd=qa+qt
      if(qd.gt.0.) qd=sqrt(qd)
      if(qa.gt.0.) qa=sqrt(qa)
      if(qt.gt.0.) qt=sqrt(qt)
      kprt=kprtt
         if(it.lt.0) then
      write(iecr,'(/a,i5)') ' MOLECULE #',im
      write(iecr,'(a,3f9.2)') ' cumulated r-m-s shifts =',qa,qt,qd
         else
      if(kprt.ne.0) write(iecr,'(a,3f9.2)')
     . ' r-m-s shifts: rotation, translation, total =',qa,qt,qd
         endif
      return
      end
"ENDOF shift.f"
#=======================================================================
echo shrinke.f
cat >shrinke.f <<"ENDOF shrinke.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine shrinke(i1,o1,xlow,xup,ylow,yup,zlow,zup,xl,xu,yl,yu,
     & zl,zu,rr,ss,scale,cm)
      implicit none
      integer i1,ix,iy,iz,mxy,nxy,nxyz,o1,xl,xlow,xu,xup,yl,ylow,yu,yup,
     & zl,zlow,zu,zup
      real avege,cm,map,rr,scale,sigma,ss
      double precision com,sum,sum1,sum2
      character card*80
      logical first,last
      dimension cm(3),com(3),rr(xlow:xup,ylow:yup),ss(xl:xu,yl:yu)
      mxy=(xup-xlow+1)*(yup-ylow+1)
      nxy=(xu-xl+1)*(yu-yl+1)
      nxyz=(xu-xl+1)*(yu-yl+1)*(zu-zl+1)
      sum1=0.d0
      sum2=0.d0
      first=.true.
      last=.false.
       do iz=zlow,zup
      if(iz.eq.zup) last=.true.
      call lisec(i1,mxy,rr,first,last)
         if(iz.ge.zl.and.iz.le.zu) then
      if(iz.eq.zu) last=.true.
        do iy=yl,yu
         do ix=xl,xu
      map=rr(ix,iy)/scale
      sum1=sum1+map
      sum2=sum2+map**2
         enddo
        enddo
         endif
       enddo
      sum1=sum1/nxyz
      sum2=sum2/nxyz
      avege=sum1
      sigma=sqrt(sum2-sum1**2)
      scale=sigma*scale
      write(6,'(a,2f15.5/a,f12.5)') ' input avge, sigma =',avege,sigma,
     . ' SCALE set to = ',scale
      rewind(unit=i1)
10    read(i1,'(a)') card
      if(card(1:3).ne.'MAP') go to 10
      sum1=0.d0
      sum2=0.d0
      com(1)=0.d0
      com(2)=0.d0
      com(3)=0.d0
      sum=0.d0
      first=.true.
      last=.false.
       do iz=zlow,zup
      if(iz.eq.zup) last=.true.
      call lisec(i1,mxy,rr,first,last)
         if(iz.ge.zl.and.iz.le.zu) then
      if(iz.eq.zu) last=.true.
        do iy=yl,yu
         do ix=xl,xu
      map=rr(ix,iy)/scale-avege/sigma
      sum1=sum1+map
      sum2=sum2+map**2
         if(map.gt.0.) then
      com(1)=com(1)+map*ix
      com(2)=com(2)+map*iy
      com(3)=com(3)+map*iz
      sum=sum+map
         endif
      ss(ix,iy)=map
         enddo
        enddo
      call essec(o1,nxy,ss,last)
         endif
       enddo
      cm(1)=com(1)/sum
      cm(2)=com(2)/sum
      cm(3)=com(3)/sum
      sum1=sum1/nxyz
      sum2=sum2/nxyz
      avege=sum1
      sigma=sqrt(sum2-sum1**2)
      write(6,'(a,2f15.5)') ' average , sigma =',avege,sigma
      return
      end
"ENDOF shrinke.f"
#=======================================================================
echo shrinkv.f
cat >shrinkv.f <<"ENDOF shrinkv.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine shrinkv(i1,o1,xlow,xup,ylow,yup,zlow,zup,xl,xu,yl,yu,
     & zl,zu,rr,ss)
      implicit none
      integer i1,ix,iy,iz,mxy,nxy,nxyz,o1,xl,xlow,xu,xup,yl,ylow,yu,yup,
     & zl,zlow,zu,zup
      real avege,map,rr,sigma,ss
      double precision sum1,sum2
      logical first,last
      dimension rr(xlow:xup,ylow:yup),ss(xl:xu,yl:yu)
      mxy=(xup-xlow+1)*(yup-ylow+1)
      nxy=(xu-xl+1)*(yu-yl+1)
      nxyz=(xu-xl+1)*(yu-yl+1)*(zu-zl+1)
      sum1=0.d0
      sum2=0.d0
      first=.true.
      last=.false.
       do iz=zlow,zup
      if(iz.eq.zup) last=.true.
      call lisec(i1,mxy,rr,first,last)
         if(iz.ge.zl.and.iz.le.zu) then
      if(iz.eq.zu) last=.true.
        do iy=yl,yu
         do ix=xl,xu
      map=rr(ix,iy)
      sum1=sum1+map
      sum2=sum2+map**2
      ss(ix,iy)=map
         enddo
        enddo
      call essec(o1,nxy,ss,last)
         endif
       enddo
      sum1=sum1/nxyz
      sum2=sum2/nxyz
      avege=sum1
      sigma=sqrt(sum2-sum1**2)
      write(6,'(a,2f15.5)') ' average , sigma =',avege,sigma
      return
      end
"ENDOF shrinkv.f"
#=======================================================================
echo sort2.f
cat >sort2.f <<"ENDOF sort2.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine sort2(n,k0,a1)
      implicit none
      integer a1,i,ii,ij,il,iu,j,k,k0,kt,ku,l,m,n,u
      dimension a1(n),il(160),iu(160),k0(n)
      ii=1
      i=ii
      j=n
      m=1
10    if(i.ge.j) go to 90
20    k=i
      ij=(i+j)/2
      kt=k0(ij)
      if(k0(i).le.kt) go to 30
      k0(ij)=k0(i)
      k0(i)=kt
      kt=k0(ij)
      u=a1(i)
      a1(i)=a1(ij)
      a1(ij)=u
30    l=j
      if(k0(j).ge.kt) go to 50
      k0(ij)=k0(j)
      k0(j)=kt
      kt=k0(ij)
      u=a1(ij)
      a1(ij)=a1(j)
      a1(j)=u
      if(k0(i).le.kt) go to 50
      k0(ij)=k0(i)
      k0(i)=kt
      kt=k0(ij)
      u=a1(ij)
      a1(ij)=a1(i)
      a1(i)=u
      go to 50
40    ku=k0(l)
      k0(l)=k0(k)
      k0(k)=ku
      u=a1(l)
      a1(l)=a1(k)
      a1(k)=u
50    l=l-1
      if(k0(l).gt.kt) go to 50
60    k=k+1
      if(k0(k).lt.kt) go to 60
      if(k.lt.l) go to 40
      if(k.gt.l) go to 70
      k=k+1
      l=l-1
70    if(l-i.le.j-k) go to 80
      il(m)=i
      iu(m)=l
      m=m+1
      i=k
      go to 100
80    il(m)=k
      iu(m)=j
      m=m+1
      j=l
      go to 100
90    m=m-1
      if(m.eq.0) go to 130
      i=il(m)
      j=iu(m)
100   if(j-i.ge.11) go to 20
      if(i.eq.ii) go to 10
      i=i-1
110   i=i+1
      if(i.eq.j) go to 90
      if(k0(i).le.k0(i+1)) go to 110
      kt=k0(i+1)
      u=a1(i+1)
      k=i
120   k0(k+1)=k0(k)
      a1(k+1)=a1(k)
      k=k-1
      if(k0(k).gt.kt) go to 120
      k0(k+1)=kt
      a1(k+1)=u
      go to 110
130   return
      end
"ENDOF sort2.f"
#=======================================================================
echo sort3.f
cat >sort3.f <<"ENDOF sort3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine sort3(n,k0,a1,a2)
      implicit none
      integer i,ii,ij,il,iu,j,k,k0,kt,ku,l,m,n
      real a1,a2,u,v
      dimension a1(n),a2(n),il(160),iu(160),k0(n)
      ii=1
      i=ii
      j=n
      m=1
10    if(i.ge.j) go to 90
20    k=i
      ij=(i+j)/2
      kt=k0(ij)
      if(k0(i).le.kt) go to 30
      k0(ij)=k0(i)
      k0(i)=kt
      kt=k0(ij)
      u=a1(i)
      a1(i)=a1(ij)
      a1(ij)=u
      v=a2(i)
      a2(i)=a2(ij)
      a2(ij)=v
30    l=j
      if(k0(j).ge.kt) go to 50
      k0(ij)=k0(j)
      k0(j)=kt
      kt=k0(ij)
      u=a1(ij)
      a1(ij)=a1(j)
      a1(j)=u
      v=a2(ij)
      a2(ij)=a2(j)
      a2(j)=v
      if(k0(i).le.kt) go to 50
      k0(ij)=k0(i)
      k0(i)=kt
      kt=k0(ij)
      u=a1(ij)
      a1(ij)=a1(i)
      a1(i)=u
      v=a2(ij)
      a2(ij)=a2(i)
      a2(i)=v
      go to 50
40    ku=k0(l)
      k0(l)=k0(k)
      k0(k)=ku
      u=a1(l)
      a1(l)=a1(k)
      a1(k)=u
      v=a2(l)
      a2(l)=a2(k)
      a2(k)=v
50    l=l-1
      if(k0(l).gt.kt) go to 50
60    k=k+1
      if(k0(k).lt.kt) go to 60
      if(k.lt.l) go to 40
      if(k.gt.l) go to 70
      k=k+1
      l=l-1
70    if(l-i.le.j-k) go to 80
      il(m)=i
      iu(m)=l
      m=m+1
      i=k
      go to 100
80    il(m)=k
      iu(m)=j
      m=m+1
      j=l
      go to 100
90    m=m-1
      if(m.eq.0) go to 130
      i=il(m)
      j=iu(m)
100   if(j-i.ge.11) go to 20
      if(i.eq.ii) go to 10
      i=i-1
110   i=i+1
      if(i.eq.j) go to 90
      if(k0(i).le.k0(i+1)) go to 110
      kt=k0(i+1)
      u=a1(i+1)
      v=a2(i+1)
      k=i
120   k0(k+1)=k0(k)
      a1(k+1)=a1(k)
      a2(k+1)=a2(k)
      k=k-1
      if(k0(k).gt.kt) go to 120
      k0(k+1)=kt
      a1(k+1)=u
      a2(k+1)=v
      go to 110
130   return
      end
"ENDOF sort3.f"
#=======================================================================
echo sort5.f
cat >sort5.f <<"ENDOF sort5.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine sort5(n,k0,a1,a2,a3,a4)
      implicit none
      integer a4,i,ii,ij,il,iu,j,k,l,m,n,x
      real a1,a2,a3,k0,kt,ku,u,v,w
      dimension a1(n),a2(n),a3(n),a4(n),il(160),iu(160),k0(n)
      ii=1
      i=ii
      j=n
      m=1
10    if(i.ge.j) go to 90
20    k=i
      ij=(i+j)/2
      kt=k0(ij)
      if(k0(i).le.kt) go to 30
      k0(ij)=k0(i)
      k0(i)=kt
      kt=k0(ij)
      u=a1(i)
      a1(i)=a1(ij)
      a1(ij)=u
      v=a2(i)
      a2(i)=a2(ij)
      a2(ij)=v
      w=a3(i)
      a3(i)=a3(ij)
      a3(ij)=w
      x=a4(i)
      a4(i)=a4(ij)
      a4(ij)=x
30    l=j
      if(k0(j).ge.kt) go to 50
      k0(ij)=k0(j)
      k0(j)=kt
      kt=k0(ij)
      u=a1(ij)
      a1(ij)=a1(j)
      a1(j)=u
      v=a2(ij)
      a2(ij)=a2(j)
      a2(j)=v
      w=a3(ij)
      a3(ij)=a3(j)
      a3(j)=w
      x=a4(ij)
      a4(ij)=a4(j)
      a4(j)=x
      if(k0(i).le.kt) go to 50
      k0(ij)=k0(i)
      k0(i)=kt
      kt=k0(ij)
      u=a1(ij)
      a1(ij)=a1(i)
      a1(i)=u
      v=a2(ij)
      a2(ij)=a2(i)
      a2(i)=v
      w=a3(ij)
      a3(ij)=a3(i)
      a3(i)=w
      x=a4(ij)
      a4(ij)=a4(i)
      a4(i)=x
      go to 50
40    ku=k0(l)
      k0(l)=k0(k)
      k0(k)=ku
      u=a1(l)
      a1(l)=a1(k)
      a1(k)=u
      v=a2(l)
      a2(l)=a2(k)
      a2(k)=v
      w=a3(l)
      a3(l)=a3(k)
      a3(k)=w
      x=a4(l)
      a4(l)=a4(k)
      a4(k)=x
50    l=l-1
      if(k0(l).gt.kt) go to 50
60    k=k+1
      if(k0(k).lt.kt) go to 60
      if(k.lt.l) go to 40
      if(k.gt.l) go to 70
      k=k+1
      l=l-1
70    if(l-i.le.j-k) go to 80
      il(m)=i
      iu(m)=l
      m=m+1
      i=k
      go to 100
80    il(m)=k
      iu(m)=j
      m=m+1
      j=l
      go to 100
90    m=m-1
      if(m.eq.0) go to 130
      i=il(m)
      j=iu(m)
100   if(j-i.ge.11) go to 20
      if(i.eq.ii) go to 10
      i=i-1
110   i=i+1
      if(i.eq.j) go to 90
      if(k0(i).le.k0(i+1)) go to 110
      kt=k0(i+1)
      u=a1(i+1)
      v=a2(i+1)
      w=a3(i+1)
      x=a4(i+1)
      k=i
120   k0(k+1)=k0(k)
      a1(k+1)=a1(k)
      a2(k+1)=a2(k)
      a3(k+1)=a3(k)
      a4(k+1)=a4(k)
      k=k-1
      if(k0(k).gt.kt) go to 120
      k0(k+1)=kt
      a1(k+1)=u
      a2(k+1)=v
      a3(k+1)=w
      a4(k+1)=x
      go to 110
130   return
      end
"ENDOF sort5.f"
#=======================================================================
echo sortndo.f
cat >sortndo.f <<"ENDOF sortndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine sortndo(nd,nr,hkl,rr)
      implicit none
      integer h,hkl,hlw,hmax,hmin,ht,hup,i,iecr,ilec,ind,index,indo,
     & iout,ir,ires,is,j,k,klw,kmax,kmin,kprt,kt,kup,l,llw,lmax,lmin,lt,
     & lup,mc,mr,mult,multt,nc,nd,nort,nr,nra,nras,nshe,nt,o1,udi,uxd
      real a,a11,a21,a22,a31,a32,a33,alpha,b,beta,c,cpct,demax,demin,
     & dinf,dmax,dmin,dr,dsup,er,fmax,fo,gamma,his,pct,phi,rbid1,rbid2,
     & ri,ro,rr,scale,spct,sqh,sqhmax,sqhmin,sum1,sum2,t
      complex cc,cphi,unoi
      character cbid1*1,title*1
      logical deja,exts,first,last
      parameter(mc=100)
      dimension cc(0:11),his(4,mc),hkl(nr),rr(nr,2),title(72)
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ortm/ rbid2(18),nort
      common/star/ a11,a21,a22,a31,a32,a33
      data o1/7/,cc/
     & ( 1.       , 0.)       ,( 0.96592583, 0.25881905),
     & ( 0.8660254, 0.5)      ,( 0.70710678, 0.70710678),
     & ( 0.5      , 0.8660254),( 0.25881905, 0.96592583),
     & ( 0.       , 1.)       ,(-0.25881905, 0.96592583),
     & (-0.5      , 0.8660254),(-0.70710678, 0.70710678),
     & (-0.8660254, 0.5)      ,(-0.96592583, 0.25881905)/
      unoi=(0.,1.)
      kprt=1
      read(ilec,*) uxd,udi,iout
      call abra(uxd,'f','u',0)
      rewind(unit=uxd)
      call abra(udi,'u','u',0)
      call abra(iout,'f','u',0)
      rewind(iout)
      read(ilec,'(72a1)') title
      write(iecr,2010) title
      read(ilec,*) a,b,c,alpha,beta,gamma
      call celda
      call lecsim
      call setpak
      read(ilec,*) nort
      call ortho
      call pac3(0,0,0,indo)
      hlw=0
      hup=0
      klw=0
      kup=0
      llw=0
      lup=0
      ir=0
      sqhmin=1.e20
      sqhmax=0.
      fmax=-1.e20
      first=.true.
      last=.false.
10    call lecfos(uxd,h,k,l,fo,phi,first,last)
      if(last) go to 20
      call assymu(h,k,l,phi,exts)
      if(exts) go to 10
      call pac3(h,k,l,ind)
      if(ind.eq.indo) go to 10
      if(h.lt.hlw) hlw=h
      if(h.gt.hup) hup=h
      if(k.lt.klw) klw=k
      if(k.gt.kup) kup=k
      if(l.lt.llw) llw=l
      if(l.gt.lup) lup=l
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(ind.ne.indo.and.sqh.lt.sqhmin) sqhmin=sqh
      if(sqh.gt.sqhmax) sqhmax=sqh
      if(fo.gt.fmax) fmax=fo
      ir=ir+1
      if(ir.gt.nr) go to 901
      hkl(ir)=ind
      rr(ir,1)=fo
      rr(ir,2)=phi
      go to 10
20    if(ir.eq.0) go to 902
      if(kprt.ne.0) write(iecr,2020) ir
      rewind(unit=udi)
      first=.true.
      mr=ir
      nra=0
      nras=0
      index=0
      i=0
      call sort3(mr,hkl,rr(1,1),rr(1,2))
      dmax=sqrt(1/sqhmin)
      dmin=sqrt(1/sqhmax)
      read(ilec,*) dsup,dinf,nc
         if(dsup.lt.dinf) then
      t=dsup
      dsup=dinf
      dinf=t
         endif
      if(dmax.gt.dsup) dmax=dsup
      if(dmin.lt.dinf) dmin=dinf
      if(nc.gt.mc) nc=mc
      er=3./2.
      ri=(1/dmax)**er
      ro=(1/dmin)**er
      dr=(ro-ri)/(nc-1)
       do is=1,nc
      his(1,is)=(ri+dr*(is-1))**(2./er)
      his(2,is)=0
      his(3,is)=0
      his(4,is)=0
       enddo
      nshe=nc-1
      read(ilec,*) scale
      do 30 ir=1,mr
      ind=hkl(ir)
      fo=rr(ir,1)
      call unpac3(h,k,l,ind)
      call sympac(h,k,l,index,deja,exts)
         if(deja.or.exts) then
      if(kprt.ne.0) write(iecr,3001) h,k,l,fo
      go to 30
         endif
      index=ind
      call multes(h,k,l,mult,ires)
      phi=rr(ir,2)
         if(ires.ne.0) then
      cphi=cexp(unoi*phi)
      cphi=sign(1.,real(cphi*conjg(cc(ires-1))))*cc(ires-1)
      phi=aimag(clog(cphi))
         endif
      call pac4(h,k,l,mult,ind)
      call unpac4(ht,kt,lt,multt,ind)
      if(ht.ne.h.or.kt.ne.k.or.lt.ne.l.or.multt.ne.mult.or.ind.le.0)
     . go to 903
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
       do is=1,nshe
         if(sqh.ge.his(1,is).and.sqh.lt.his(1,is+1)) then
      his(2,is)=his(2,is)+fo**2
      his(3,is)=his(3,is)+mult
      nras=nras+1
         endif
       enddo
      i=i+1
      hkl(i)=ind
      rr(i,1)=fo/scale
      rr(i,2)=phi
      if(i.lt.nd) go to 30
         if(first) then
      write(udi) i,a,b,c,alpha,beta,gamma
      first=.false.
         endif
      write(udi) i,(hkl(j),j=1,nd),(rr(j,1),j=1,nd),(rr(j,2),j=1,nd)
      nra=nra+i
      i=0
30    continue
      open(unit=o1,file='HISTU',form='formatted',status='unknown')
       do is=1,nshe
      sqh=(sqrt(his(1,is+1))+sqrt(his(1,is)))/2
      spct=0
      if(his(3,is).ne.0) spct=log(his(2,is)/his(3,is))
      write(o1,'(f7.1,a,f7.1,3f10.5,i10)') sqrt(1/his(1,is)),' -',
     . sqrt(1/his(1,is+1)),spct,sqh,1/sqh,nint(his(3,is))
       enddo
         if(nra.ne.0) then
      if(i.ne.0) write(udi) i,(hkl(j),j=1,nd),(rr(j,1),j=1,nd),(rr(j,2),
     . j=1,nd)
         else
      write(udi) i,a,b,c,alpha,beta,gamma
      write(udi) i,(hkl(j),j=1,i),(rr(j,1),j=1,i),(rr(j,2),j=1,i)
         endif
      nra=nra+i
      demax=sqrt(1/sqhmin)
      demin=sqrt(1/sqhmax)
      sqhmin=(1/demax)**2
      sqhmax=(1/demin)**2
      call indexm(demin,hmax,kmax,lmax)
      hmin=0
      kmin=-kmax
      lmin=-lmax
      index=0
      nt=0
c pacote
      do 60 l=lmin,lmax
      do 50 k=kmin,kmax
      do 40 h=hmin,hmax
      call sympac(h,k,l,index,deja,exts)
      if(deja.or.exts) go to 40
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.lt.sqhmin.or.sqh.gt.sqhmax) go to 40
      call multes(h,k,l,mult,ires)
       do is=1,nshe
      if(sqh.ge.his(1,is).and.sqh.lt.his(1,is+1)) his(4,is)=his(4,is)+
     . mult
       enddo
      call pac3(h,k,l,index)
      nt=nt+1
40    continue
50    continue
60    continue
      pct=nra*100./nt
      if(kprt.ne.0) write(iecr,2030) nra,demax,demin,pct,
     . hlw,hup,klw,kup,llw,lup,fmax/scale
      write(iout,4010) title,pct,nra,demax,demin
      write(iout,'(a,a)') '      resolution         %    cumul%',
     . '    (extended to p1)'
      sum1=0
      sum2=0
       do is=1,nshe
      sum1=sum1+his(3,is)
      sum2=sum2+his(4,is)
      spct=0
      if(his(4,is).ne.0) spct=100*his(3,is)/his(4,is)
      cpct=0.
      if(sum2.ne.0) cpct=100*sum1/sum2
      write(iout,'(f7.1,a,f7.1,2f10.2)') sqrt(1/his(1,is)),' -',
     . sqrt(1/his(1,is+1)),spct,cpct
       enddo
      write(iout,'(a,f10.3,a,f10.3,a,i10)')
     . ' reflections in selected range ( ',dmax,' - ',dmin,' ) :',nras
      return
901   write(iecr,3010) nr
      write(iout,3010) nr
      stop
902   write(iecr,3020)
      write(iout,3020)
      stop
903   write(iecr,3030)
      write(iout,3030)
      stop
2010  format(/' ****** programme sorting ******'//72a1)
2020  format(' reflections read =',i10)
2030  format(' reflections written =',i10/
     . ' data resolution between',f10.3,' and',f10.3/
     . ' data completeness =',f10.3/
     . ' maximal indices in data'/' hmin, hmax =',2i5,
     . ', kmin, kmax =',2i5,', lmin, lmax =',2i5/' fob max =',e15.5)
4010  format('sorting :',72a1/
     . ' reflections (',f5.1,'% of total) :',i10/
     . ' resolution =',f10.3,' to',f10.3)
3001  format(/' >> warning << multiple reflection =',3i5,e15.5)
3010  format('stop >> sortndo << set nr >',i10)
3020  format('stop >> sortndo << no reflection selected')
3030  format('stop >> sortndo << data resolution exceeds packing limit')
      end
"ENDOF sortndo.f"
echo splits.f
cat >splits.f <<"ENDOF splits.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program splits
      implicit none
      integer bod,bodi,i,i0,i1,id,iecr,ilec,imol,indi,iout,it,j,kprt,n,
     & nc,nmol,nort,nt,tbod
      real a,al,al0,alpha,b,be,be0,beta,c,c0,dtor,ga,ga0,gamma,pi,pot,r,
     & r0,r1,r1n,rbid1,rf,rfn,rn1,ro,ron,rt,rtod,rx,t,tra,twopi,tx
      character card*80,cardd*80,cart*80,forme*40,formr*40,tcar*80,zn*1
      dimension c0(3,100),cardd(200),i0(100,100),pot(4),r(3,3),
     & r0(9,100),r1(9,100),r1n(9),rfn(3,3),rn1(9),ron(3,3),rt(3,3),
     & rx(3,3),t(3),tra(3),tx(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ortm/ ro(3,3),rf(3,3),nort
      data i0/10000*0/,c0/300*0./,r0/900*0./
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      kprt=0
      iout=9
      zn='#'
      formr='(2x,i2,       3f7.1,3f8.4,  1x,4f6.1   )'
      forme='(1x,a1,i2,    3f7.1,3f8.4,  1x,4f6.1   )'
      call abra(iout,'f','u',0)
      rewind(iout)
c logicalunit
      id=8
      call abra(id,'f','u',0)
      rewind(unit=id)
      read(id,*)
      read(id,*) a,b,c,alpha,beta,gamma
      call celda
      it=ilec
      ilec=id
      call lecsim
      ilec=it
      read(id,*) nort
      call ortho
         if(nort.ne.1) then
       do i=1,3
        do j=1,3
      ron(i,j)=ro(i,j)
      rfn(i,j)=rf(i,j)
        enddo
       enddo
      n=nort
      nort=1
      call ortho
      nort=n
      call pro2mx(r1n,ro,rfn)
      call pro2mx(rn1,ron,rf)
         endif
      nt=-100
      bodi=-100
10    read(ilec,'(a)',end=40) cart
      indi=index(cart,'>')
      if(indi.ge.1) nt=0
20    indi=index(cart,'#')
      if(indi.lt.1) go to 10
      cart(indi:indi)=' '
      tcar(1:80-indi)=cart(indi+1:80)
c lecturainterna
      read(tcar,*) bod
         if(nt.eq.0) then
      bodi=bod
         else
      i0(bodi,nt)=bod
         endif
      nt=nt+1
      tbod=bod+10
      call abra(tbod,'f','u',0)
      rewind(unit=tbod)
30    read(tbod,'(a)') card
      if(card(1:7).ne.' center') go to 30
      read(card,'(17x,3f9.2)') (c0(i,bod),i=1,3)
      read(tbod,'(17x,3f9.2)') al0,be0,ga0
      call rmxe(al0,be0,ga0,r0(1,bod))
      call rmxe(180-ga0,be0,180-al0,r1(1,bod))
      call cierre(tbod,'f')
      go to 20
40    i1=1
      call abra(i1,'f','u',0)
      rewind(unit=i1)
      read(i1,'(a)') card
      write(iout,'(a)') card
50    read(i1,*,end=90) nmol
      nc=0
      do 80 imol=1,nmol
      read(i1,fmt=formr) bodi,al,be,ga,tra,pot
      nt=1
      bod=i0(bodi,nt)
         if(bod.eq.0) then
      bod=bodi
      go to 70
         endif
      call rmxe(al,be,ga,r)
      call pro2mx(rx,r,r0(1,bodi))
         if(nort.ne.1) then
      call pro2mx(r,r1n,rx)
       do i=1,3
        do j=1,3
      rx(i,j)=r(i,j)
        enddo
       enddo
         endif
      call rmx2e(rx,al,be,ga)
       do i=1,3
      tx(i)=0.
        do j=1,3
      tx(i)=tx(i)+ro(i,j)*tra(j)
        enddo
       enddo
       do i=1,3
        do j=1,3
      tx(i)=tx(i)-rx(i,j)*c0(j,bodi)
        enddo
       enddo
60     do i=1,3
      t(i)=tx(i)
        do j=1,3
      t(i)=t(i)+rx(i,j)*c0(j,bod)
        enddo
       enddo
       do i=1,3
      tra(i)=0.
        do j=1,3
      tra(i)=tra(i)+rf(i,j)*t(j)
        enddo
       enddo
      call pro2mx(r,rx,r1(1,bod))
         if(nort.ne.1) then
      call pro2mx(rt,rn1,r)
       do j=1,3
        do i=1,3
      r(i,j)=rt(i,j)
        enddo
       enddo
         endif
      call rmx2e(r,al,be,ga)
70    nc=nc+1
      write(tcar,fmt=forme) zn,bod,al,be,ga,tra,pot
      cardd(nc)=tcar
      nt=nt+1
      bod=i0(bodi,nt)
      if(bod.ne.0) go to 60
80    continue
      write(iout,'(2i10)') nc,1
       do n=1,nc
      write(iout,'(a)') cardd(n)
       enddo
      go to 50
90    stop
      end
"ENDOF splits.f"
#=======================================================================
echo srfp.f
cat >srfp.f <<"ENDOF srfp.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine srfp(n,pmax,twogrp,factor,psym,sym,unsym)
      implicit none
      integer f,factor,iecr,ilec,iout,j,jj,kprt,m,n,nest,p,pmax,pp,psym,
     & ptwo,q,qq,r,sym,twogrp,unsym
      character cbid1*1
      dimension factor(*),pp(14),qq(7),sym(*),unsym(*)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      nest=14
      m=n
      psym=1
      f=2
      p=0
      q=0
10    if(m.le.1) go to 50
      do 20 j=f,pmax
      if(m.eq.(m/j)*j) go to 30
20    continue
      go to 901
30    if(2*p+q.ge.nest) go to 902
      f=j
      m=m/f
      if(m.eq.(m/f)*f) go to 40
      q=q+1
      qq(q)=f
      go to 10
40    m=m/f
      p=p+1
      pp(p)=f
      psym=psym*f
      go to 10
50    r=1
      if(q.eq.0) r=0
      if(p.lt.1) go to 70
      do 60 j=1,p
      jj=p+1-j
      sym(j)=pp(jj)
      factor(j)=pp(jj)
      jj=p+q+j
      factor(jj)=pp(j)
      jj=p+r+j
      sym(jj)=pp(j)
60    continue
70    if(q.lt.1) go to 90
      do 80 j=1,q
      jj=p+j
      unsym(j)=qq(j)
      factor(jj)=qq(j)
80    continue
      sym(p+1)=n/psym**2
90    jj=2*p+q
      factor(jj+1)=0
      ptwo=1
      j=0
100   j=j+1
      if(factor(j).eq.0) go to 120
      if(factor(j).ne.2) go to 100
      ptwo=ptwo*2
      factor(j)=1
      if(ptwo.ge.twogrp) go to 110
      if(factor(j+1).eq.2) go to 100
110   factor(j)=ptwo
      ptwo=1
      go to 100
120   if(p.eq.0) r=0
      jj=2*p+r
      sym(jj+1)=0
      if(q.le.1) q=0
      unsym(q+1)=0
      return
901   write(iecr,3010) pmax,n
      write(iout,3010) pmax,n
      stop
902   write(iecr,3020) nest,n
      write(iout,3020) nest,n
      stop
3010  format('stop >> srfp << largest factor exceeds',i5,', n =',i5)
3020  format('stop >> srfp << factor count exceeds',i5,', n =',i5)
      end
"ENDOF srfp.f"
#=======================================================================
echo stfndo.f
cat >stfndo.f <<"ENDOF stfndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine stfndo(i1,io1,o1,nd,mi,mr,mc,ii,rr,cc)
      implicit none
      integer i1,iecr,ii,ilec,io1,iout,kprt,mc,mi,mr,nd,o1,ufc,ump,ure
      real rr
      complex cc
      character cbid1*1
      external rz1,phkl1
      dimension cc(mc),ii(mi),rr(mr)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/tapes/ ump,ure,ufc
      ump=i1
      ure=io1
      ufc=o1
      write(iecr,2010)
      call datamf(ure,nd,mi,mr,mc,ii(1))
      call xffth(rz1,phkl1,ii(1),rr(1),cc(1))
      return
2010  format(/' ****** s/r stfndo ******')
      end
"ENDOF stfndo.f"
#=======================================================================
echo suprime.f
cat >suprime.f <<"ENDOF suprime.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine suprime(lun,bod,seuil)
      implicit none
      integer bod,flag,i,iecr,ilec,iout,ir,is,j,k,kprt,lun,nort,ns,nsol,
     & ord,tbod
      real add,al,ayc,be,dtor,dtx,dty,dtz,ga,pi,qa,qd,qq,qt,r0,r1,rf,ro,
     & rtod,seuil,ten,twopi,tx,ty,tz
      character card*80,forme*40,formr*40,zn*1
      parameter(ns=10000)
      dimension ayc(9,ns),flag(ns),ord(ns),qq(3,3),r0(3,3),r1(3,3),
     & ten(6)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ortm/ ro(3,3),rf(9),nort
      tbod=bod+10
      call abra(tbod,'f','u',0)
      rewind(unit=tbod)
       do i=1,8
      read(tbod,*)
       enddo
      read(tbod,'(17x,6f9.2)') (ten(i),i=1,6)
      call cierre(tbod,'f')
      qq(1,1)=ten(1)
      qq(1,2)=ten(4)
      qq(1,3)=ten(5)
      qq(2,1)=ten(4)
      qq(2,2)=ten(2)
      qq(2,3)=ten(6)
      qq(3,1)=ten(5)
      qq(3,2)=ten(6)
      qq(3,3)=ten(3)
      ir=0
10    read(lun,'(a)',end=20) card
      ir=ir+1
      if(ir.gt.ns) go to 901
      read(card,fmt=formr) bod,(ayc(i,ir),i=1,8)
      flag(ir)=1
      ayc(9,ir)=ro(1,1)+ro(2,2)+ro(3,3)
      ord(ir)=ir
      go to 10
20    nsol=ir
      do 40 ir=1,1
cjn   do 40 ir=1,nsol-1
cjn   if(flag(ir).eq.0) go to 40
      al=ayc(1,ir)
      be=ayc(2,ir)
      ga=ayc(3,ir)
      tx=ayc(4,ir)
      ty=ayc(5,ir)
      tz=ayc(6,ir)
      call rmxe(al,be,ga,r0)
      do 30 is=ir+1,nsol
cjn   if(flag(is).eq.0) go to 30
      dtx=tx-ayc(4,is)
      dty=ty-ayc(5,is)
      dtz=tz-ayc(6,is)
      qt=0.
       do i=1,3
      qt=qt+(ro(i,1)*dtx+ro(i,2)*dty+ro(i,3)*dtz)**2
       enddo
      qd=sqrt(abs(qt))
      al=ayc(1,is)
      be=ayc(2,is)
      ga=ayc(3,is)
      call rmxe(al,be,ga,r1)
      qa=0.
       do i=1,3
      qa=qa+qq(i,i)
        do j=1,3
      add=0.
         do k=1,3
      add=add+r0(i,k)*qq(k,j)
         enddo
      qa=qa-r1(i,j)*add
        enddo
       enddo
      qa=2.*qa
      qd=sqrt(abs(qt+qa))
         if(ayc(9,is)-qd.gt.seuil) then
      ayc(9,is)=qd
      ord(is)=ir
         endif
         if(ayc(9,ir)-qd.gt.seuil) then
      ayc(9,ir)=qd
      ord(ir)=is
         endif
cjn   if(qd.le.seuil) flag(is)=0
30    continue
40    continue
      rewind(unit=lun)
      do 50 ir=1,nsol
      write(lun,fmt=forme) zn,bod,(ayc(i,ir),i=1,9),ord(ir)
50    continue
      return
901   write(iecr,3010)
      stop
3010  format('stop >> suprime << increase ns')
      end
"ENDOF suprime.f"
#=======================================================================
echo symcar.f
cat >symcar.f <<"ENDOF symcar.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine symcar
      implicit none
      integer i,iecr,ifound,ilec,iout,ip,isl,it,j,k,kmax,kprt,m,mss,
     & mssa,neq,nfi,np,nts,num
      real a,t,tss,tssa,tts
      character cbid1*1,col*1,iblank*1,ich*1,icomma*1,ie*1,iminus*1,
     & inum*1,iplus*1,ipoint*1,is*1,islash*1,istar*1,ix*1,iy*1,iz*1
      dimension col(80),inum(10),mssa(3,3),num(10),tssa(3)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      data is,ie,ix,iy,iz,iplus,iminus,islash,ipoint,icomma,istar,
     & iblank/'s','e','x','y','z','+','-','/','.',',','*',' '/,
     & inum/'1','2','3','4','5','6','7','8','9','0'/,
     & num/1,2,3,4,5,6,7,8,9,0/
      kmax=80
      neq=0
      nts=0
10    read(ilec,'(80a1)') col
      k=0
20    nfi=1
      do 40 j=1,3
      tssa(j)=0.
      do 30 i=1,3
      mssa(i,j)=0
30    continue
40    continue
50    m=1
      t=0.
      isl=0
      ip=0
      np=0
      ifound=0
60    k=k+1
      if(k.gt.kmax) go to 190
      ich=col(k)
      if(ich.eq.iblank) go to 60
      if(ich.eq.icomma.or.ich.eq.istar) go to 190
         if(ich.eq.is.or.ich.eq.ie) then
      if(nfi.eq.1.and.ifound.eq.0) go to 220
      go to 901
         endif
      ifound=1
      if(ich.eq.ix) go to 110
      if(ich.eq.iy) go to 120
      if(ich.eq.iz) go to 130
      if(ich.eq.iplus) go to 150
      if(ich.eq.iminus) go to 160
      if(ich.eq.islash) go to 170
      if(ich.eq.ipoint) go to 180
      do 70 i=1,10
      if(ich.eq.inum(i)) go to 80
70    continue
      go to 901
80    a=num(i)
      if(isl.eq.1) go to 90
      if(ip.eq.1) go to 100
      t=a*m
      go to 60
90    t=t/a
      go to 60
100   np=np+1
      t=t+a/10**np
      go to 60
110   j=1
      go to 140
120   j=2
      go to 140
130   j=3
140   mssa(nfi,j)=m
      m=1
      go to 60
150   m=1
      go to 60
160   m=-1
      go to 60
170   isl=1
      go to 60
180   ip=1
      go to 60
190   tssa(nfi)=t
         if(ifound.eq.0.and.nfi.eq.1) then
      if(kmax.le.k) go to 10
      if(kmax.gt.k) go to 60
         endif
         if(ifound.eq.1.and.nfi.eq.3) then
      it=0
       do j=1,3
        do i=1,3
      it=it+abs(mssa(i,j))
        enddo
       enddo
            if(it.ne.0) then
      neq=neq+1
      if(neq.gt.48) go to 901
      do 210 j=1,3
      tss(j,neq)=tssa(j)
      do 200 i=1,3
      mss(i,j,neq)=mssa(i,j)
200   continue
210   continue
            else
      nts=nts+1
       do j=1,3
      tts(j,nts)=tssa(j)
       enddo
            endif
      if(kmax.le.k) go to 10
      if(kmax.gt.k) go to 20
         endif
         if(k.lt.kmax.and.ifound.eq.1.and.nfi.lt.3) then
      nfi=nfi+1
      go to 50
         endif
      go to 901
220   do 240 j=1,3
      if(mss(j,j,1).ne.1) go to 901
      do 230 i=1,3
         if(i.ne.j) then
      if(mss(i,j,1).ne.0) go to 901
         endif
230   continue
240   continue
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
3010  format('stop >> symcar << wrong or out of order symmetry card')
      end
"ENDOF symcar.f"
#=======================================================================
echo sympac.f
cat >sympac.f <<"ENDOF sympac.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine sympac(h,k,l,index,deja,exts)
      implicit none
      integer h,hh,iind,index,ir,it,k,kk,l,ll,mss,n,neq,nts
      real pr,tss,tts
      logical deja,exts
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      deja=.false.
      exts=.false.
       do it=1,nts
      pr=mod(h*tts(1,it)+k*tts(2,it)+l*tts(3,it),1.)
      ir=mod(12+nint(12*pr),12)
      if(ir.ne.0) exts=.true.
       enddo
      do 10 n=1,neq
      hh=h*mss(1,1,n)+k*mss(2,1,n)+l*mss(3,1,n)
      kk=h*mss(1,2,n)+k*mss(2,2,n)+l*mss(3,2,n)
      ll=h*mss(1,3,n)+k*mss(2,3,n)+l*mss(3,3,n)
         if(hh.eq.h.and.kk.eq.k.and.ll.eq.l) then
      pr=mod(h*tss(1,n)+k*tss(2,n)+l*tss(3,n),1.)
      ir=mod(12+nint(12*pr),12)
      if(ir.ne.0) exts=.true.
         endif
c pacote
         if(hh.lt.0.or.(hh.eq.0.and.(ll.gt.0.or.(ll.eq.0.and.kk.gt.0))))
     . then
      hh=-hh
      kk=-kk
      ll=-ll
         endif
      call pac3(hh,kk,ll,iind)
      if(iind.le.index) go to 20
10    continue
      return
20    deja=.true.
      return
      end
"ENDOF sympac.f"
#=======================================================================
echo tab2i.f
cat >tab2i.f <<"ENDOF tab2i.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program tab2i
      implicit none
      integer iecr,ilec,iout,kprt,mc
      complex cc
      character cbid1*1
      parameter(mc=10000000)
      dimension cc(mc)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      ilec=5
      iecr=6
      kprt=0
      iout=9
      call tab4i(mc,cc(1))
      stop
      end
"ENDOF tab2i.f"
#=======================================================================
echo tab4i.f
cat >tab4i.f <<"ENDOF tab4i.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tab4i(mc,cc)
      implicit none
      integer h,hmax,hsup,ibid1,ibid2,iecr,ilec,iout,k,kmax,kprt,ksup,l,
     & lmax,lsup,mc,mt,neq,nort,tab,tabo
      real a,a11,a21,a22,a31,a32,a33,alpha,b,beta,c,dmaxo,dmin,dmino,
     & dsq,dtor,gamma,pi,rbid1,rbid2,rbid3,rbid4,rf,ro,rtod,sqh,sqhmax,
     & sqhsup,to,twopi
      complex cc
      character cbid1*1
      dimension cc(mc)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/ortm/ ro(3,3),rf(3,3),nort
      common/reso/ rbid2,dmin,rbid3(4)
      common/simt/ rbid4(153),ibid1(432),neq,ibid2
      common/star/ a11,a21,a22,a31,a32,a33
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      read(ilec,*) dmaxo,dmino
         if(dmaxo.lt.dmino) then
      to=dmaxo
      dmaxo=dmino
      dmino=to
         endif
      tab=1
      call abra(tab,'u','u',0)
      rewind(unit=tab)
      read(tab) a,b,c,alpha,beta,gamma,nort,hmax,kmax,lmax,sqhmax
      call celda
      neq=1
      call setpak
      nort=1
      call ortho
      dsq=0.
       do h=-1,1
        do k=-1,1
         do l=-1,1
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.dsq) dsq=sqh
         enddo
        enddo
       enddo
      dmin=1/(sqrt(sqhmax)-sqrt(dsq))
      if(dmino.lt.dmin) dmino=dmin
      dmin=1/(1/dmino+sqrt(dsq))
      sqhsup=1/dmin**2
      call indexm(dmin,hsup,ksup,lsup)
      mt=(hmax+2)*(2*kmax+1)*(2*lmax+1)+
     . (2*hsup+1)*(2*ksup+1)*(2*lsup+1)
      if(mt.gt.mc) go to 901
      tabo=2
      call abra(tabo,'u','u',0)
      rewind(unit=tabo)
      write(tabo) a,b,c,alpha,beta,gamma,nort,hsup,ksup,lsup,sqhsup
      mt=1+(hmax+2)*(2*kmax+1)*(2*lmax+1)
      call lwtab4i(tab,hmax,kmax,lmax,cc(1),tabo,hsup,ksup,lsup,cc(mt))
      return
901   write(iecr,3010) mt
cjn   write(iout,3010) mt
      stop
3010  format('stop >> tab2i << set mc =',i10)
      end
"ENDOF tab4i.f"
#=======================================================================
echo tablndo.f
cat >tablndo.f <<"ENDOF tablndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tablndo(mi,mr,mc,ma,ii,rr,cc,aa)
      implicit none
      integer hmax,i,iecr,ii,ilec,ino,iout,ipr,kmax,kprt,kprtt,lmax,ma,
     & mc,mi,mr,mrr,mtab,mx,my,mz,nat,nd,nprt,nx,ny,nz,t1,t2,uat,ucd,
     & ump,ure,utb
      real bcrd,dmin,dtor,factor,pi,rbid1,rbid2,rr,rtod,twopi
      complex cc
      character aa*4,cbid1*1,option*10,title*1
      logical fijo
      dimension aa(ma),cc(mc),ii(mi),rr(mr),title(72)
      common/angkte/ pi,twopi,dtor,rtod
      common/grid/ hmax,kmax,lmax,nx,ny,nz
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/oprt/ kprtt(20)
      common/outab/ bcrd(17),nat,mtab
      common/reso/ rbid1,dmin,rbid2(4)
      common/tapes/ ump,ure,utb
c logicalunit
      t1=91
      t2=92
      uat=3
      read(ilec,*) nprt,(kprtt(ipr),ipr=1,nprt)
      read(ilec,*) ucd,ump,utb,iout
      call abra(utb,'u','u',0)
      rewind(unit=utb)
      call abra(iout,'f','u',0)
      rewind(iout)
      call abra(t1,'f','u',0)
      rewind(unit=t1)
      call abra(t2,'u','u',0)
      rewind(unit=t2)
      read(ilec,'(72a1)') title
      write(iecr,2010) title
      read(ilec,'(a)') option
      ino=index(option,'m')
         if(ino.ge.1) then
      call abra(ump,'u','u',0)
      rewind(unit=ump)
         endif
      kprt=kprtt(1)
         if(option(1:3).eq.'xyz') then
      call abra(uat,'f','u',0)
      rewind(unit=uat)
      call abra(ucd,'f','u',0)
      rewind(unit=ucd)
      if(ino.lt.1) ump=utb
      if(mr.lt.4*ma) go to 901
      fijo=.false.
      if(index(option,'f').ge.1) fijo=.true.
      if(index(option,'t').ge.1) t2=0
      call carndo(uat,ucd,t1,t2,ump,mi,mr,ma,ii,rr,aa,fijo)
         else if(option(1:3).eq.'map') then
      read(ump) mx,my,mz
      if(mr.lt.mx*my) go to 902
      call mapin(ump,mx,my,rr)
         else
      go to 903
         endif
         if(index(option,'t').ge.1) then
      bcrd(17)=dmin
      go to 10
         endif
      nd=100000
      mrr=min(1000000,mr)
      if(mr.lt.2*nd) go to 904
      kprt=kprtt(3)
      call stfndo(ump,t2,utb,nd,mi,mrr,mc,ii,rr,cc)
      if(2*(hmax+2)*(2*kmax+1)*(2*lmax+1).gt.mr) go to 905
      call tabndo(utb,utb,nd,hmax,kmax,lmax,ii,rr,cc)
10    factor=rtod*bcrd(17)*sqrt(2./45.)
      write(iout,4010) (title(i),i=1,71),option(1:3),bcrd,mtab,
     . factor/sqrt(bcrd(12)+bcrd(13)),factor/sqrt(bcrd(11)+bcrd(13)),
     . factor/sqrt(bcrd(11)+bcrd(12)),sqrt(4.*(bcrd(11)+bcrd(12)))
      return
901   write(iecr,3010) 4*ma
      write(iout,3010) 4*ma
      stop
902   write(iecr,3020) mx*my
      write(iout,3020) mx*my
      stop
903   write(iecr,3030) option
      write(iout,3030) option
      stop
904   write(iecr,3040) 2*nd,mc+nd
      write(iout,3040) 2*nd,mc+nd
      stop
905   write(iecr,3050) (hmax+2)*(2*kmax+1)*(2*lmax+1)+nd
      write(iout,3050) (hmax+2)*(2*kmax+1)*(2*lmax+1)+nd
      stop
2010  format(/' ****** programme tabling ******'//72a1)
4010  format('tabling: ',71a1/
     . ' the center of mass of the input ',a3/
     . ' [orthogonalized if necessary with nort=1 and (optionally)',
     . ' rotated]'/' has been translated to the origin'/
     . ' minimal box    :',3f9.2/
     . ' minimal radius :',f9.2/
     . ' center of mass :',3f9.2/
     . ' rotation       :',3f9.2/
     . ' inertia tensor :',6f9.2/
     . ' resolution limit for interpolation:',f9.3/
     . ' dimension of array (complex)      :',i10/
     . ' angular steps based on dmin/rmsd  :',3f9.2/
     . ' maximal rotational rmsd           :',f9.2)
3010  format('stop >> tablndo << set mr >',i10)
3020  format('stop >> tablndo << set mr >',i10)
3030  format('stop >> tablndo << wrong input option =',a10)
3040  format('stop >> tablndo << set mi =',i10,' and mc =',i10)
3050  format('stop >> tablndo << set mc =',i10)
      end
"ENDOF tablndo.f"
#=======================================================================
echo tabmod.f
cat >tabmod.f <<"ENDOF tabmod.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tabmod(i1,nd,hmax,kmax,lmax,dmin,hsup,ksup,lsup,sqhsup,
     & hklo,fo,ft)
      implicit none
      integer h,hklo,hmax,hsup,i,i1,iecr,ilec,iout,k,kmax,kprt,ksup,l,
     & lmax,lsup,m,mtab,nat,nd
      real a11,a21,a22,a31,a32,a33,dmin,dsq,dtmin,rbid1,sqh,sqhsup
      complex f,fo,ft
      character cbid1*1
      dimension fo(nd),ft(-1:hmax,-kmax:kmax,-lmax:lmax),hklo(nd)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/outab/ rbid1(16),dtmin,nat,mtab
      common/star/ a11,a21,a22,a31,a32,a33
      h=0
      hsup=0
      ksup=0
      lsup=0
      do 30 l=-lmax,lmax
      do 20 k=-kmax,kmax
      do 10 h=-1,hmax
      ft(h,k,l)=(0.,0.)
10    continue
20    continue
30    continue
      rewind(unit=i1)
40    read(i1,end=60) m,hklo,fo
      if(m.gt.nd) go to 901
      do 50 i=1,m
      call unpac3(h,k,l,hklo(i))
      if(abs(h).gt.hsup) hsup=abs(h)
      if(abs(k).gt.ksup) ksup=abs(k)
      if(abs(l).gt.lsup) lsup=abs(l)
      if(hsup.gt.hmax.or.ksup.gt.kmax.or.lsup.gt.lmax) go to 902
      f=fo(i)
      if(mod(h+k+l,2).ne.0) f=-f
      ft(h,k,l)=f
50    continue
      go to 40
c pacote
60    do 90 l=-lmax,lmax
      do 80 k=-kmax,kmax
      do 70 h=0,1
      ft(-h,-k,-l)=conjg(ft(h,k,l))
70    continue
80    continue
90    continue
      dsq=0.
      do 120 h=-1,1
      do 110 k=-1,1
      do 100 l=-1,1
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.dsq) dsq=sqh
100   continue
110   continue
120   continue
      sqhsup=1/dmin**2
      dtmin=1/(sqrt(sqhsup)-sqrt(dsq))
      mtab=(hsup+2)*(2*ksup+1)*(2*lsup+1)
      write(iecr,*) ' '
      write(iecr,*) ' h,k,l limits for array =',hsup,ksup,lsup
      write(iecr,*) ' resolution limit =',sqrt(1/sqhsup)
      write(iecr,*) ' resolution limit for interpolation =',dtmin
      write(iecr,*) ' dimension of array =',mtab
      return
901   write(iecr,3010) m,nd
      write(iout,3010) m,nd
      stop
902   write(iecr,3020) h,k,l
      write(iout,3020) h,k,l
      stop
3010  format('stop >> tabmod << m >> nd =',2i10)
3020  format('stop >> tabmod << h,k,l out of box =',3i5)
      end
"ENDOF tabmod.f"
#=======================================================================
echo tabndo.f
cat >tabndo.f <<"ENDOF tabndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tabndo(i1,o1,nr,hmax,kmax,lmax,ii,rr,cc)
      implicit none
      integer hmax,hsup,i1,iecr,ii,ilec,iout,kmax,kprt,ksup,lmax,lsup,
     & nd,nr,o1
      real dmin,rbid1,rbid2,rr,sqhsup
      complex cc
      character cbid1*1
      dimension cc(nr),ii(nr),rr(2*(hmax+2)*(2*kmax+1)*(2*lmax+1))
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      common/reso/ rbid1,dmin,rbid2(4)
      write(iecr,2010)
      rewind(unit=i1)
      read(i1) nd
      if(nd.ne.nr) go to 901
      call tabmod(i1,nd,hmax,kmax,lmax,dmin,hsup,ksup,lsup,sqhsup,
     . ii(1),cc(1),rr(1))
      call mintab(o1,hmax,kmax,lmax,hsup,ksup,lsup,sqhsup,rr(1),rr(1))
      return
901   write(iecr,3010) nr,nd
      write(iout,3010) nr,nd
      stop
2010  format(/' ****** s/r tabndo ******')
3010  format('stop >> tabndo << mismatch. nr, nd =',2i10)
      end
"ENDOF tabndo.f"
#=======================================================================
echo tql2.f
cat >tql2.f <<"ENDOF tql2.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tql2(nm,n,d,e,z,ierr)
      implicit none
      integer i,ierr,ii,j,k,l,l1,l2,m,mml,n,nm
      real c,c2,c3,d,dl1,e,el1,f,g,h,p,pythag,r,s,s2,tst1,tst2,z
      external pythag
      dimension d(n),e(n),z(nm,n)
cjn uninitialized values
      data c3,s2/0.,0./
      ierr=0
      if(n.eq.1) go to 1001
      do 100 i=2,n
      e(i-1)=e(i)
100   continue
      f=0.0e0
      tst1=0.0e0
      e(n)=0.0e0
      do 240 l=1,n
      j=0
      h=abs(d(l))+abs(e(l))
      if(tst1.lt.h) tst1=h
      do 110 m=l,n
      tst2=tst1+abs(e(m))
      if(tst2.eq.tst1) go to 120
110   continue
120   if(m.eq.l) go to 220
130   if(j.eq.30) go to 1000
      j=j+1
      l1=l+1
      l2=l1+1
      g=d(l)
      p=(d(l1)-g)/(2.0e0*e(l))
      r=pythag(p,1.0e0)
      d(l)=e(l)/(p+sign(r,p))
      d(l1)=e(l)*(p+sign(r,p))
      dl1=d(l1)
      h=g-d(l)
      if(l2.gt.n) go to 145
      do 140 i=l2,n
      d(i)=d(i)-h
140   continue
145   f=f+h
      p=d(m)
      c=1.0e0
      c2=c
      el1=e(l1)
      s=0.0e0
      mml=m-l
      do 200 ii=1,mml
      c3=c2
      c2=c
      s2=s
      i=m-ii
      g=c*e(i)
      h=c*p
      r=pythag(p,e(i))
      e(i+1)=s*r
      s=e(i)/r
      c=p/r
      p=c*d(i)-s*g
      d(i+1)=h+s*(c*g+s*d(i))
      do 180 k=1,n
      h=z(k,i+1)
      z(k,i+1)=s*z(k,i)+c*h
      z(k,i)=c*z(k,i)-s*h
180   continue
200   continue
      p=-s*s2*c3*el1*e(l)/dl1
      e(l)=s*p
      d(l)=c*p
      tst2=tst1+abs(e(l))
      if(tst2.gt.tst1) go to 130
220   d(l)=d(l)+f
240   continue
      do 300 ii=2,n
      i=ii-1
      k=i
      p=d(i)
      do 260 j=ii,n
      if(d(j).ge.p) go to 260
      k=j
      p=d(j)
260   continue
      if(k.eq.i) go to 300
      d(k)=d(i)
      d(i)=p
      do 280 j=1,n
      p=z(j,i)
      z(j,i)=z(j,k)
      z(j,k)=p
280   continue
300   continue
      go to 1001
1000  ierr=l
1001  return
      end
"ENDOF tql2.f"
#=======================================================================
echo tqlrat.f
cat >tqlrat.f <<"ENDOF tqlrat.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tqlrat(n,d,e2,ierr)
      implicit none
      integer i,ierr,ii,j,l,l1,m,mml,n
      real b,c,d,e2,epslon,f,g,h,p,pythag,r,s,t
      external epslon,pythag
      dimension d(n),e2(n)
cjn uninitialized values
      data b,c/0.,0./
      ierr=0
      if(n.eq.1) go to 1001
      do 100 i=2,n
      e2(i-1)=e2(i)
100   continue
      f=0.0e0
      t=0.0e0
      e2(n)=0.0e0
      do 290 l=1,n
      j=0
      h=abs(d(l))+sqrt(e2(l))
      if(t.gt.h) go to 105
      t=h
      b=epslon(t)
      c=b*b
105   do 110 m=l,n
      if(e2(m).le.c) go to 120
110   continue
120   if(m.eq.l) go to 210
130   if(j.eq.30) go to 1000
      j=j+1
      l1=l+1
      s=sqrt(e2(l))
      g=d(l)
      p=(d(l1)-g)/(2.0e0*s)
      r=pythag(p,1.0e0)
      d(l)=s/(p+sign(r,p))
      h=g-d(l)
      do 140 i=l1,n
      d(i)=d(i)-h
140   continue
      f=f+h
      g=d(m)
      if(g.eq.0.0e0) g=b
      h=g
      s=0.0e0
      mml=m-l
      do 200 ii=1,mml
      i=m-ii
      p=g*h
      r=p+e2(i)
      e2(i+1)=s*r
      s=e2(i)/r
      d(i+1)=h+s*(h+d(i))
      g=d(i)-e2(i)/g
      if(g.eq.0.0e0) g=b
      h=g*p/r
200   continue
      e2(l)=s*g
      d(l)=h
      if(h.eq.0.0e0) go to 210
      if(abs(e2(l)).le.abs(c/h)) go to 210
      e2(l)=h*e2(l)
      if(e2(l).ne.0.0e0) go to 130
210   p=d(l)+f
      if(l.eq.1) go to 250
      do 230 ii=2,l
      i=l+2-ii
      if(p.ge.d(i-1)) go to 270
      d(i)=d(i-1)
230   continue
250   i=1
270   d(i)=p
290   continue
      go to 1001
1000  ierr=l
1001  return
      end
"ENDOF tqlrat.f"
#=======================================================================
echo tred1.f
cat >tred1.f <<"ENDOF tred1.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tred1(nm,n,a,d,e,e2)
      implicit none
      integer i,ii,j,jp1,k,l,n,nm
      real a,d,e,e2,f,g,h,scale
      dimension a(nm,n),d(n),e(n),e2(n)
      do 100 i=1,n
      d(i)=a(n,i)
      a(n,i)=a(i,i)
100   continue
      do 300 ii=1,n
      i=n+1-ii
      l=i-1
      h=0.0e0
      scale=0.0e0
      if(l.lt.1) go to 130
      do 120 k=1,l
      scale=scale+abs(d(k))
120   continue
      if(scale.ne.0.0e0) go to 140
      do 125 j=1,l
      d(j)=a(l,j)
      a(l,j)=a(i,j)
      a(i,j)=0.0e0
125   continue
130   e(i)=0.0e0
      e2(i)=0.0e0
      go to 300
140   do 150 k=1,l
      d(k)=d(k)/scale
      h=h+d(k)*d(k)
150   continue
      e2(i)=scale*scale*h
      f=d(l)
      g=-sign(sqrt(h),f)
      e(i)=scale*g
      h=h-f*g
      d(l)=f-g
      if(l.eq.1) go to 285
      do 170 j=1,l
      e(j)=0.0e0
170   continue
      do 240 j=1,l
      f=d(j)
      g=e(j)+a(j,j)*f
      jp1=j+1
      if(l.lt.jp1) go to 220
      do 200 k=jp1,l
      g=g+a(k,j)*d(k)
      e(k)=e(k)+a(k,j)*f
200   continue
220   e(j)=g
240   continue
      f=0.0e0
      do 245 j=1,l
      e(j)=e(j)/h
      f=f+e(j)*d(j)
245   continue
      h=f/(h+h)
      do 250 j=1,l
      e(j)=e(j)-h*d(j)
250   continue
      do 280 j=1,l
      f=d(j)
      g=e(j)
      do 260 k=j,l
      a(k,j)=a(k,j)-f*e(k)-g*d(k)
260   continue
280   continue
285   do 290 j=1,l
      f=d(j)
      d(j)=a(l,j)
      a(l,j)=a(i,j)
      a(i,j)=f*scale
290   continue
300   continue
      return
      end
"ENDOF tred1.f"
#=======================================================================
echo tred2.f
cat >tred2.f <<"ENDOF tred2.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tred2(nm,n,a,d,e,z)
      implicit none
      integer i,ii,j,jp1,k,l,n,nm
      real a,d,e,f,g,h,hh,scale,z
      dimension a(nm,n),d(n),e(n),z(nm,n)
      do 100 i=1,n
      do 80 j=i,n
      z(j,i)=a(j,i)
80    continue
      d(i)=a(n,i)
100   continue
      if(n.eq.1) go to 510
      do 300 ii=2,n
      i=n+2-ii
      l=i-1
      h=0.0e0
      scale=0.0e0
      if(l.lt.2) go to 130
      do 120 k=1,l
      scale=scale+abs(d(k))
120   continue
      if(scale.ne.0.0e0) go to 140
130   e(i)=d(l)
      do 135 j=1,l
      d(j)=z(l,j)
      z(i,j)=0.0e0
      z(j,i)=0.0e0
135   continue
      go to 290
140   do 150 k=1,l
      d(k)=d(k)/scale
      h=h+d(k)*d(k)
150   continue
      f=d(l)
      g=-sign(sqrt(h),f)
      e(i)=scale*g
      h=h-f*g
      d(l)=f-g
      do 170 j=1,l
      e(j)=0.0e0
170   continue
      do 240 j=1,l
      f=d(j)
      z(j,i)=f
      g=e(j)+z(j,j)*f
      jp1=j+1
      if(l.lt.jp1) go to 220
      do 200 k=jp1,l
      g=g+z(k,j)*d(k)
      e(k)=e(k)+z(k,j)*f
200   continue
220   e(j)=g
240   continue
      f=0.0e0
      do 245 j=1,l
      e(j)=e(j)/h
      f=f+e(j)*d(j)
245   continue
      hh=f/(h+h)
      do 250 j=1,l
      e(j)=e(j)-hh*d(j)
250   continue
      do 280 j=1,l
      f=d(j)
      g=e(j)
      do 260 k=j,l
      z(k,j)=z(k,j)-f*e(k)-g*d(k)
260   continue
      d(j)=z(l,j)
      z(i,j)=0.0e0
280   continue
290   d(i)=h
300   continue
      do 500 i=2,n
      l=i-1
      z(n,l)=z(l,l)
      z(l,l)=1.0e0
      h=d(i)
      if(h.eq.0.0e0) go to 380
      do 330 k=1,l
      d(k)=z(k,i)/h
330   continue
      do 370 j=1,l
      g=0.0e0
      do 340 k=1,l
      g=g+z(k,i)*z(k,j)
340   continue
      do 360 k=1,l
      z(k,j)=z(k,j)-g*d(k)
360   continue
370   continue
380   do 400 k=1,l
      z(k,i)=0.0e0
400   continue
500   continue
510   do 520 i=1,n
      d(i)=z(n,i)
      z(n,i)=0.0e0
520   continue
      z(n,n)=1.0e0
      e(1)=0.0e0
      return
      end
"ENDOF tred2.f"
#=======================================================================
echo trip.f
cat >trip.f <<"ENDOF trip.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine trip(u,v,w,id)
      implicit none
      integer ia,ib,id,u,v,w
      dimension u(3),v(3),w(3)
      ia=u(1)*v(2)*w(3)+v(1)*w(2)*u(3)+v(3)*u(2)*w(1)
      ib=w(1)*v(2)*u(3)+u(2)*v(1)*w(3)+w(2)*v(3)*u(1)
      id=ia-ib
      return
      end
"ENDOF trip.f"
#=======================================================================
echo trmsq.f
cat >trmsq.f <<"ENDOF trmsq.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine trmsq(dtx,dty,dtz,ro,qt)
      implicit none
      integer i
      real dtx,dty,dtz,qt,ro
      dimension ro(3,3)
      qt=0.
       do i=1,3
      qt=qt+(ro(i,1)*dtx+ro(i,2)*dty+ro(i,3)*dtz)**2
       enddo
      return
      end
"ENDOF trmsq.f"
#=======================================================================
echo udi2i.f
cat >udi2i.f <<"ENDOF udi2i.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program udi2i
      implicit none
      integer iecr,ii,ilec,iout,kprt,md,nr
      real rr
      complex cc
      character cbid1*1
      parameter(md=100000,nr=10000000)
      dimension cc(nr),ii(md+3*nr),rr(2*md)
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      ilec=5
      iecr=6
      kprt=0
      iout=9
      call udi4i(md,nr,ii(1),ii(1+md),rr(1),cc(1))
      stop
      end
"ENDOF udi2i.f"
#=======================================================================
echo udi4i.f
cat >udi4i.f <<"ENDOF udi4i.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine udi4i(md,nr,jj,ii,rr,cc)
      implicit none
      integer i,iecr,ii,ilec,iout,j,jj,kprt,md,mss,n,nd,neq,nort,nr,nts,
     & udi,udo
      real a,alpha,b,beta,c,dmaxo,dmino,dtor,gamma,pi,rbid1,rbid2,rf,ro,
     & rr,rtod,to,tss,tts,twopi
      complex cc
      character forme*40,formr*40,zn*1
      dimension cc(nr),ii(3*nr),jj(md),rr(2*md)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      common/ortm/ ro(3,3),rf(3,3),nort
      common/reso/ dmaxo,dmino,rbid2(4)
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
       do n=1,48
        do i=1,3
      tss(i,n)=0.
         do j=1,3
      mss(i,j,n)=0
         enddo
        enddo
       enddo
      nts=0
       do i=1,3
        do n=1,3
      tts(i,n)=0.
        enddo
       enddo
      neq=1
       do i=1,3
      mss(i,i,1)=1
       enddo
      udi=1
      call abra(udi,'u','u',0)
      rewind(unit=udi)
      read(udi) nd,a,b,c,alpha,beta,gamma
      if(nd.gt.md) go to 901
      call celda
      call setpak
      nort=1
      call ortho
      read(ilec,*) dmaxo,dmino
         if(dmaxo.lt.dmino) then
      to=dmaxo
      dmaxo=dmino
      dmino=to
         endif
      udo=2
      call abra(udo,'u','u',0)
      rewind(unit=udo)
      call lwudi4i(udi,udo,nd,nr,jj(1),rr(1),rr(1+nd),ii(1),cc(1))
      return
901   write(iecr,3010) nd,md
cjn   write(iout,3010) nd,md
      stop
3010  format('stop >> udi2i << nd > md =',2i10)
      end
"ENDOF udi4i.f"
#=======================================================================
echo unpac3.f
cat >unpac3.f <<"ENDOF unpac3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine unpac3(ih,ik,il,ind3)
      implicit none
      integer hm,ih,ik,il,ind1,ind2,ind3,km,lm,maxint,nh,nk,nl
      common/paco3/ hm,km,lm,nh,nk,nl,maxint
      ind2=ind3/nh
      ind1=ind2/nk
      il=ind1-lm
      ik=ind2-ind1*nk-km
      ih=ind3-ind2*nh-hm
      return
      end
"ENDOF unpac3.f"
#=======================================================================
echo unpac4.f
cat >unpac4.f <<"ENDOF unpac4.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine unpac4(ih,ik,il,im,ind4)
      implicit none
      integer hm,ih,ik,il,im,ind1,ind2,ind3,ind4,km,lm,nh,nk,nl,nm
      common/paco/ hm,km,lm,nh,nk,nl,nm
      ind3=ind4/nm
      ind2=ind3/nh
      ind1=ind2/nk
      il=ind1-lm
      ik=ind2-ind1*nk-km
      ih=ind3-ind2*nh-hm
      im=ind4-ind3*nm
      return
      end
"ENDOF unpac4.f"
#=======================================================================
echo unpak3.f
cat >unpak3.f <<"ENDOF unpak3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine unpak3(i,j,k,ind3)
      implicit none
      integer i,ind1,ind2,ind3,j,k,m,n
      data m,n/2,5/
      ind2=ind3/n
      ind1=ind2/n
      k=ind1-m
      j=ind2-ind1*n-m
      i=ind3-ind2*n-m
      return
      end
"ENDOF unpak3.f"
#=======================================================================
echo uro.f
cat >uro.f <<"ENDOF uro.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program uro
      implicit none
      integer iecr,ii,ilec,iout,kprt,ma,mc,mi,mr
      real rr
      complex cc
      character aa*4,forme*40,formr*40,zn*1
      parameter(mi=9000000,mr=9000000,mc=9000000,ma=300000)
      dimension aa(ma),cc(mc),ii(mi),rr(mr)
      common/ioprg/ ilec,iecr,kprt,iout,formr,forme,zn
      ilec=5
      iecr=6
      kprt=0
      iout=9
      zn='#'
      formr='(2x,i2,       3f7.1,3f8.4,  1x,4f6.1   )'
      forme='(1x,a1,i2,    3f7.1,3f8.4,  1x,4f6.1   )'
c mi=nrt, mc=mt+nrt
      call amiga(mi,mr,mc,ma,ii,rr,cc,aa)
      stop
      end
"ENDOF uro.f"
#=======================================================================
echo v2d.f
cat >v2d.f <<"ENDOF v2d.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program v2d
      implicit none
      integer i1,length,lungo,mr,mx,my,mz,n,nlungo,o1,px,py,pz
      real a,alpha,b,beta,c,dx,dy,dz,gamma,ox,oy,oz,rr,scale
      character card*80,lun*500
      external length,lungo
      parameter(mr=1000000)
      dimension rr(mr)
      data i1,o1/1,2/,nlungo/500/
      write(6,'(a)') ' enter the input vtk-map filename'
      read(5,'(a)') lun
      write(6,'(a,a)') ' input vtk-map =',lun(1:lungo(lun,nlungo))
      open(unit=i1,file=lun,form='formatted',status='old')
      rewind(unit=i1)
10    read(i1,'(a)') card
      if(card(1:10).ne.'DIMENSIONS') go to 10
      read(card(11:80),*) mx,my,mz
      read(i1,'(a)') card
      read(card(8:80),*) dx,dy,dz
      read(i1,'(a)') card
      read(card(7:80),*) ox,oy,oz
      read(i1,'(a)') card
      read(i1,'(a)') card
      read(i1,'(a)') card
      a=mx*dx
      b=my*dy
      c=mz*dz
      alpha=90.
      beta=90.
      gamma=90.
       do n=1,80
      card(n:n)=' '
       enddo
      write(card,'(6f12.3)') a,b,c,alpha,beta,gamma
      read(card,*) a,b,c,alpha,beta,gamma
      write(6,'(a,6f10.3)') ' input cell =',a,b,c,alpha,beta,gamma
      write(6,'(a,3f10.5/a,3i5)') ' input spacings =',dx,dy,dz,
     . ' extent =',mx,my,mz
      px=mx
      py=my
      pz=mz
      call control(px)
      call control(py)
      call control(pz)
         if(px.ne.mx.or.py.ne.my.or.pz.ne.mz) then
      write(6,'(/a)') ' STOP >> v2d << extent incompatible with FFT'
      stop
         endif
         if(mx*my.gt.mr) then
      write(6,'(/a,i10)') ' STOP >> v2d << set mr =',mx*my
      stop
         endif
      write(6,'(a)') ' enter the output dim3-map filename'
      read(5,'(a)') lun
      write(6,'(a,a)') ' output dim3-map =',lun(1:lungo(lun,nlungo))
      open(unit=o1,file=lun,form='unformatted',status='unknown')
      write(o1) mx,my,mz,a,b,c,alpha,beta,gamma
      scale=1.
      call leesc(i1,o1,mx,my,mz,rr(1),scale)
      write(6,'(6f10.3,a)') a,b,c,alpha,beta,gamma,'     CELL'
      stop
      end
"ENDOF v2d.f"
#=======================================================================
echo v2dm.f
cat >v2dm.f <<"ENDOF v2dm.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program v2dm
      implicit none
      integer i1,ixl,ixu,iyl,iyu,izl,izu,mr,mx,my,mz,o1
      real alpha,beta,dx,dy,dz,gamma,ox,oy,oz,rr,scale,xl,xu,yl,yu,zl,zu
      character card*80,lun*500
      parameter(mr=1000000)
      dimension rr(mr)
      data i1,o1/1,2/
      write(6,'(a)') ' enter the input vtk-map filename'
      read(5,'(a)') lun
      open(unit=i1,file=lun,form='formatted',status='old')
      rewind(unit=i1)
10    read(i1,'(a)') card
      if(card(1:10).ne.'DIMENSIONS') go to 10
      read(card(11:80),*) mx,my,mz
      read(i1,'(a)') card
      read(card(8:80),*) dx,dy,dz
      read(i1,'(a)') card
      read(card(7:80),*) ox,oy,oz
      read(i1,'(a)') card
      read(i1,'(a)') card
      read(i1,'(a)') card
      write(6,'(a,3f10.5/a,3i5)') ' input spacings =',dx,dy,dz,
     . ' extent =',mx,my,mz
         if(mx*my.gt.mr) then
      write(6,'(/a,i10)') ' STOP >> v2dm << set mr =',mx*my
      stop
         endif
      ixl=nint(ox/dx)
      iyl=nint(oy/dy)
      izl=nint(oz/dz)
      ixu=ixl+(mx-1)
      iyu=iyl+(my-1)
      izu=izl+(mz-1)
      xl=ixl*dx
      yl=iyl*dy
      zl=izl*dz
      xu=ixu*dx
      yu=iyu*dy
      zu=izu*dz
      alpha=90.
      beta=90.
      gamma=90.
      write(6,2010) xl,yl,zl,xu,yu,zu
      write(6,'(a)') ' enter the output uro-map filename'
      read(5,'(a)') lun
      open(unit=o1,file=lun,form='unformatted',status='unknown')
      rewind(o1)
      write(o1) mx,my,mz,xl,yl,zl,xu,yu,zu,alpha,beta,gamma
      scale=1.
      call leesc(i1,o1,mx,my,mz,rr(1),scale)
      close(unit=i1)
      close(unit=o1)
      stop
2010  format(' lower and upper limits of box =',2(/3(5x,f10.2)))
      end
"ENDOF v2dm.f"
#=======================================================================
echo v2v.f
cat >v2v.f <<"ENDOF v2v.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program v2v
      implicit none
      integer i1,length,lungo,mr,mx,my,mz,n,nlungo,nx,ny,nz,o1,px,py,pz,
     & xl,xlow,xu,xup,yl,ylow,yu,yup,zl,zlow,zu,zup
      real a,alpha,b,beta,c,dx,dy,dz,gamma,ox,oy,oz,rr,ss
      character card*80,lun*500
      external length,lungo
      parameter(mr=1000000)
      dimension rr(mr),ss(mr)
      data i1,o1/1,2/,nlungo/500/
      write(6,'(/a)') ' *************** V2V ***************'
      write(6,'(a)') ' enter the input vtk-map filename'
      read(5,'(a)') lun
      write(6,'(a,a)') ' input vtk-map: ',lun(1:lungo(lun,nlungo))
      open(unit=i1,file=lun,form='formatted',status='old')
      rewind(unit=i1)
10    read(i1,'(a)') card
      if(card(1:10).ne.'DIMENSIONS') go to 10
      read(card(11:80),*) mx,my,mz
      read(i1,'(a)') card
      read(card(8:80),*) dx,dy,dz
      read(i1,'(a)') card
      read(card(7:80),*) ox,oy,oz
      read(i1,'(a)') card
      read(i1,'(a)') card
      read(i1,'(a)') card
      xlow=nint(ox/dx)
      ylow=nint(oy/dy)
      zlow=nint(oz/dz)
      xup=xlow+mx-1
      yup=ylow+my-1
      zup=zlow+mz-1
      a=mx*dx
      b=my*dy
      c=mz*dz
      alpha=90.
      beta=90.
      gamma=90.
       do n=1,80
      card(n:n)=' '
       enddo
      write(card,'(6f12.3)') a,b,c,alpha,beta,gamma
      read(card,*) a,b,c,alpha,beta,gamma
      write(6,'(a,6f10.3)') ' input cell =',a,b,c,alpha,beta,gamma
      write(6,'(a,3f10.5/a,3i5)') ' input spacings =',dx,dy,dz,
     . ' extent =',mx,my,mz
      write(6,'(a,6i5)') ' input indices [x],[y],[z] =',
     . xlow,xup,ylow,yup,zlow,zup
      write(6,'(a)') ' enter output indices'
      read(5,*) xl,xu,yl,yu,zl,zu
      nx=xu-xl+1
      ny=yu-yl+1
      nz=zu-zl+1
      px=nx
      py=ny
      pz=nz
      call control(px)
      call control(py)
      call control(pz)
         if(px.ne.nx.or.py.ne.ny.or.pz.ne.nz) then
      write(6,'(/a)') ' STOP >> v2v << extent incompatible with FFT'
      stop
         endif
      a=nx*dx
      b=ny*dy
      c=nz*dz
      alpha=90.
      beta=90.
      gamma=90.
      write(card,'(6f12.3)') a,b,c,alpha,beta,gamma
      read(card,*) a,b,c,alpha,beta,gamma
      write(6,'(a,6f10.3)') ' output cell =',a,b,c,alpha,beta,gamma
      write(6,'(a,3f10.5/a,3i5)') ' output spacings =',dx,dy,dz,
     . ' extent =',nx,ny,nz
      write(6,'(a,6i5)') ' output indices [x],[y],[z] =',
     . xl,xu,yl,yu,zl,zu
      ox=xl*dx
      oy=yl*dy
      oz=zl*dz
         if(mx*my.gt.mr) then
      write(6,'(/a,i10)') ' STOP >> v2v << set mr =',mx*my
      stop
         endif
      write(6,'(a)') ' enter the output vtk-map filename'
      read(5,'(a)') lun
      write(6,'(a,a)') ' output vtk-map =',lun(1:lungo(lun,nlungo))
      open(unit=o1,file=lun,form='formatted',status='unknown')
      rewind(unit=o1)
      write(card,'(a)') '# vtk DataFile Version 2.0'
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'Converted from ezd to vtk , suits Ten Eyck FFT'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'ASCII'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'DATASET STRUCTURED_POINTS'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a,3i10)') 'DIMENSIONS',nx,ny,nz
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a,3f15.5)') 'SPACING',dx,dy,dz
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a,3f15.3)') 'ORIGIN',ox,oy,oz
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a,i15)') 'POINT_DATA',nx*ny*nz
      call compact(card)
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'SCALARS scalars float'
      write(o1,'(a)') card(1:length(card))
      write(card,'(a)') 'LOOKUP_TABLE default'
      write(o1,'(a)') card(1:length(card))
      call shrinkv(i1,o1,xlow,xup,ylow,yup,zlow,zup,xl,xu,yl,yu,zl,zu,
     . rr(1),ss(1))
      stop
      end
"ENDOF v2v.f"
#=======================================================================
echo xffth.f
cat >xffth.f <<"ENDOF xffth.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine xffth(rxyz,phkl,ii,rr,cc)
      implicit none
      integer dim,hlw,hmax,hs,hst,hup,ii,klw,kmax,kup,llw,lmax,lup,my,
     & mz,nh,nk,nra,nwds,nwdsm,nx,nx2,nxyz,ny,nz,ph,pz,pzt,td,xlw,xup,
     & ylw,yup,zlw,zs,zup
      real ktes,rbid1,rr,twopi
      complex cc
      double precision dang
      logical skip
      external rxyz,phkl
      dimension cc(*),dim(5),ii(*),rr(*)
      common/dfft/ hlw,hup,klw,kup,llw,lup,nra,nxyz
      common/dfftd/ ph,pz,td,nwds,nwdsm
      common/dfftx/ rbid1(6),xlw,ylw,zlw,xup,yup,zup
      common/fftkte/ twopi,ktes(7)
      common/grid/ hmax,kmax,lmax,nx,ny,nz
      dang=atan2(1.d0,1.d0)
      twopi=dang*8.d0
      ktes(1)=-0.5d0
      ktes(2)=cos(dang*2.d0/3.d0)
      ktes(3)=cos(dang*8.d0/5.d0)
      ktes(4)=cos(dang*2.d0/5.d0)
      ktes(5)=-cos(dang*4.d0/5.d0)
      ktes(6)=cos(dang*6.d0/5.d0)
      ktes(7)=cos(dang)
      nx2=nx/2
      nh=hup-hlw+1
      nk=kup-klw+1
      my=yup-ylw+1
      mz=zup-zlw+1
      hs=0
      zs=zlw
      pzt=pz
      skip=.true.
         if(ph.lt.nh.or.pz.lt.mz) then
      skip=.false.
      call abra(td,'d','s',nwds)
         endif
10    if(zs+pzt.gt.zup+1) pzt=zup+1-zs
      call rxyz(nx,my,pzt,zs,rr(1))
      dim(1)=nx*my*pzt
      dim(2)=2
      dim(3)=dim(1)
      dim(4)=dim(1)
      dim(5)=nx
      call realft(nx,dim,rr(1),rr(2))
      call xytohy(nx2,my,pzt,nh,ny,rr(1),rr(1),rr(1))
      dim(1)=2*nh*ny*pzt
      dim(2)=2*nh
      dim(3)=2*nh*ny
      dim(4)=dim(2)
      dim(5)=2
      call cmplft(ny,dim,rr(1),rr(2))
      call ytok(nh,ny,pzt,nk,rr(1),rr(1))
      if(.not.skip) call hout(td,nh,nk,pzt,ph,zs,rr(1))
      zs=zs+pzt
      if(zs.lt.zup+1) go to 10
20    if(hs+ph.gt.nh) ph=nh-hs
      hst=hs+hlw
      if(.not.skip) call zin(td,ph,nk,mz,pz,hs,nh,rr(1))
      call ztoz(ph,nk,mz,nz,rr(1),rr(1))
      dim(1)=2*ph*nk*nz
      dim(2)=2*ph*nk
      dim(3)=2*ph*nk*nz
      dim(4)=dim(2)
      dim(5)=2
      call cmplft(nz,dim,rr(1),rr(2))
      call phkl(nra,ph,nk,nz,hst,ii(1),ii(1+nra),rr(1),cc(1))
      hs=hs+ph
      if(hs.lt.nh) go to 20
      if(.not.skip) call cierre(td,'d')
      return
      end
"ENDOF xffth.f"
#=======================================================================
echo xytohy.f
cat >xytohy.f <<"ENDOF xytohy.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine xytohy(nx2,my,nz,nh,ny,ww,vv,uu)
      implicit none
      integer ih,iy,iz,my,nh,nx2,ny,nz,xlw,xup,ylw,yup,zlw,zup
      real rbid1
      complex uu,vv,ww
      dimension uu(nh,ny,nz),vv(nh,my,nz),ww(nx2,my,nz)
      common/dfftx/ rbid1(6),xlw,ylw,zlw,xup,yup,zup
      do 30 iz=1,nz
      do 20 iy=1,my
      do 10 ih=1,nh
      vv(ih,iy,iz)=ww(ih,iy,iz)
10    continue
20    continue
30    continue
      do 60 iz=nz,1,-1
      do 50 iy=my,1,-1
      do 40 ih=nh,1,-1
      uu(ih,ylw+iy,iz)=vv(ih,iy,iz)
40    continue
50    continue
60    continue
      do 100 iz=1,nz
      do 90 ih=1,nh
      do 70 iy=1,ylw
      uu(ih,iy,iz)=(0.,0.)
70    continue
      do 80 iy=ylw+my+1,ny
      uu(ih,iy,iz)=(0.,0.)
80    continue
90    continue
100   continue
      return
      end
"ENDOF xytohy.f"
#=======================================================================
echo ytok.f
cat >ytok.f <<"ENDOF ytok.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine ytok(nh,ny,nz,nk,ww,vv)
      implicit none
      integer hlw,hup,ih,ik,iz,klw,kup,llw,lup,nh,nk,nra,nxyz,ny,nz
      complex vv,ww
      dimension vv(nh,nk,nz),ww(nh,ny,nz)
      common/dfft/ hlw,hup,klw,kup,llw,lup,nra,nxyz
      do 50 iz=1,nz
      do 20 ik=1,kup+1
      do 10 ih=1,nh
      vv(ih,ik,iz)=ww(ih,ik,iz)
10    continue
20    continue
      do 40 ik=klw+1,0
      do 30 ih=1,nh
      vv(ih,nk+ik,iz)=ww(ih,ny+ik,iz)
30    continue
40    continue
50    continue
      return
      end
"ENDOF ytok.f"
#=======================================================================
echo zero.f
cat >zero.f <<"ENDOF zero.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine zero(funtio,flev,xl,xu,x)
      implicit none
      integer iecr,ilec,iout,j,kprt,nit
      real fl,flev,fs,fu,x,xl,xs,xu
      character cbid1*1
      external funtio
      common/ioprg/ ilec,iecr,kprt,iout,cbid1(81)
      nit=100
      call funtio(xl,fl)
      fl=fl-flev
      call funtio(xu,fu)
      fu=fu-flev
      if(fl*fu.gt.0.) go to 901
      do 10 j=1,nit
      xs=(xl+xu)/2.
      call funtio(xs,fs)
      fs=fs-flev
         if(fs*fl.gt.0.) then
      xl=xs
      fl=fs
         else
      xu=xs
      fu=fs
         endif
10    continue
      x=(xl+xu)/2.
      return
901   write(iecr,3010)
      write(iout,3010)
      stop
3010  format('stop >> zero << equal signs for regula falsi')
      end
"ENDOF zero.f"
#=======================================================================
echo zin.f
cat >zin.f <<"ENDOF zin.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine zin(td,ph,nk,nz,pz,hs,nh,ww)
      implicit none
      integer hrec,hs,ihk,irec,iz,nh,nk,nz,ph,pht,pz,td,zf,zs
      complex ww
      dimension ww(ph*nk,nz)
      save hrec,pht
         if(hs.eq.0) then
      hrec=(nh-1)/ph+1
      pht=ph
         endif
      zf=0
      irec=hs/pht+1
10    zs=zf+1
      zf=zf+pz
      if(zf.gt.nz) zf=nz
      read(td,rec=irec) ((ww(ihk,iz),ihk=1,ph*nk),iz=zs,zf)
      irec=irec+hrec
      if(zf.lt.nz) go to 10
      return
      end
"ENDOF zin.f"
#=======================================================================
echo ztoz.f
cat >ztoz.f <<"ENDOF ztoz.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine ztoz(nh,nk,mz,nz,ww,vv)
      implicit none
      integer ih,ik,iz,mz,nh,nk,nz,xlw,xup,ylw,yup,zlw,zup
      real rbid1
      complex vv,ww
      dimension vv(nh,nk,nz),ww(nh,nk,mz)
      common/dfftx/ rbid1(6),xlw,ylw,zlw,xup,yup,zup
      do 30 iz=mz,1,-1
      do 20 ik=nk,1,-1
      do 10 ih=nh,1,-1
      vv(ih,ik,zlw+iz)=ww(ih,ik,iz)
10    continue
20    continue
30    continue
      do 70 ik=1,nk
      do 60 ih=1,nh
      do 40 iz=1,zlw
      vv(ih,ik,iz)=(0.,0.)
40    continue
      do 50 iz=zlw+mz+1,nz
      vv(ih,ik,iz)=(0.,0.)
50    continue
60    continue
70    continue
      return
      end
"ENDOF ztoz.f"
"ENDOF uro.for"
#=======================================================================
echo stfing.for
cat >stfing.for <<"ENDOF stfing.for"
# to recover individual items, csh this file
#=======================================================================
echo abra.f
cat >abra.f <<"ENDOF abra.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine abra(lu,ft,ss,nwds)
      implicit none
      integer i,ibid1,iecr,ilec,ios,kprt,lgth,lsiz,lu,lungo,mul,n,
     & nlungo,nwds,nwdsm
      real idat,odat
      character ft*1,fu*500,ss*1,st*7,tcar*80
      logical first,primo
      external lungo
      dimension idat(15),odat(15)
      common/dfftd/ ibid1(3),nwdsm
      common/ioprg/ ilec,iecr,kprt
      data first/.true./,nlungo/500/
      save fu,lgth,mul,primo
         if(first) then
      primo=.true.
       do n=1,nlungo
      fu(n:n)=' '
       enddo
      call getenv('UROF',fu)
      lgth=lungo(fu,nlungo)+1
      fu(lgth:lgth)='/'
      first=.false.
         endif
         if(ss.eq.'n') then
      st='new    '
         else if(ss.eq.'o') then
      st='old    '
         else if(ss.eq.'u') then
      st='unknown'
         else if(ss.eq.'s') then
      st='scratch'
         endif
         if(lu.lt.10) then
      write(tcar,'(a,i1,2x)') 'fort.',lu
         else if(lu.lt.100) then
      write(tcar,'(a,i2,1x)') 'fort.',lu
         else
      write(tcar,'(a,i3)') 'fort.',lu
         endif
      fu(lgth+1:lgth+8)=tcar(1:8)
         if(ft.eq.'f') then
      open(unit=lu,file=fu,form='formatted',status=st)
         else if(ft.eq.'u') then
      open(unit=lu,file=fu,form='unformatted',status=st)
         else if(ft.eq.'d') then
            if(primo) then
      nwdsm=1000000
       do i=1,15
      idat(i)=1000./i
      odat(i)=0.
       enddo
      do 20 mul=1,8
      lsiz=mul*15
      open(unit=lu,access='direct',recl=lsiz,status=st,iostat=ios)
      write(lu,rec=1,err=10) idat
      read(lu,rec=1,err=10) odat
       do i=1,15
      if(idat(i).ne.odat(i)) go to 10
       enddo
      go to 30
10    close(unit=lu,status='delete')
20    continue
      go to 901
30    close(unit=lu,status='delete')
      primo=.false.
            endif
      if(nwds.gt.0)
     . open(unit=lu,access='direct',recl=mul*nwds,status=st,iostat=ios)
         endif
      return
901   write(iecr,3010)
      stop
3010  format('stop >> abra << cannot determine d-a record length')
      end
"ENDOF abra.f"
#=======================================================================
echo celda.f
cat >celda.f <<"ENDOF celda.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine celda
      implicit none
      integer iecr,ilec,kprt
      real a,a11,a21,a22,a31,a32,a33,alpha,ast,b,beta,bst,c,ca,cast,cb,
     & cbst,cg,cgst,cst,dtor,gamma,pi,r,rtod,sa,sast,sb,sbst,sg,sgst,
     & twopi,vol
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,ca,cb,cg,sa,sb,sg,ast,bst,cst,
     & cast,cbst,cgst,sast,sbst,sgst,vol
      common/ioprg/ ilec,iecr,kprt
      common/star/ a11,a21,a22,a31,a32,a33
      r=alpha*dtor
      ca=cos(r)
      sa=sin(r)
      r=beta*dtor
      cb=cos(r)
      sb=sin(r)
      r=gamma*dtor
      cg=cos(r)
      sg=sin(r)
      vol=a*b*c*sqrt(1.+2.*ca*cb*cg-ca*ca-cb*cb-cg*cg)
      cast=(cb*cg-ca)/(sb*sg)
      cbst=(cg*ca-cb)/(sg*sa)
      cgst=(ca*cb-cg)/(sa*sb)
      sast=sqrt(1.-cast*cast)
      sbst=sqrt(1.-cbst*cbst)
      sgst=sqrt(1.-cgst*cgst)
      ast=1/(a*sb*sgst)
      bst=1/(b*sg*sast)
      cst=1/(c*sa*sbst)
      a11=ast*sbst*sg
      a21=-ast*sbst*cg
      a22=bst*sast
      a31=ast*cbst
      a32=bst*cast
      a33=cst
      if(kprt.ne.0) write(iecr,2010) a,b,c,alpha,beta,gamma,vol
      return
2010  format(/' cell parameters =',6f10.3/' volume =',e15.5)
      end
"ENDOF celda.f"
#=======================================================================
echo cmplft.f
cat >cmplft.f <<"ENDOF cmplft.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine cmplft(n,dim,x,y)
      implicit none
      integer dim,factor,n,pmax,psym,sym,twogrp,unsym
      real x,y
      dimension dim(*),factor(15),sym(15),unsym(15),x(*),y(*)
      pmax=19
      twogrp=8
      if(n.le.1) return
      call srfp(n,pmax,twogrp,factor,psym,sym,unsym)
      call mdftkd(x,y,n,dim,factor)
      call diprp(x,y,n,dim,psym,sym,unsym)
      return
      end
"ENDOF cmplft.f"
#=======================================================================
echo contrg.f
cat >contrg.f <<"ENDOF contrg.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine contrg(na,ia)
      implicit none
      integer i,ia,iba,ibid1,inta,j,maxs,mcd,mdiv,mi,mini,mp1,n,na,nba,
     & ndiv,neq,nts,p1
      real tss,tts
      parameter(mp1=266,maxs=1000)
      dimension iba(5),inta(24),p1(mp1)
      common/simt/ tss(3,48),tts(3,3),ibid1(432),neq,nts
      data p1/
     &  46,  58,  62,  74,  82,  86,  92,  94, 106, 116, 118, 122,
     & 124, 134, 138, 142, 146, 148, 158, 164, 166, 172, 174, 178,
     & 184, 186, 188, 194, 202, 206, 212, 214, 218, 222, 226, 230,
     & 232, 236, 244, 246, 248, 254, 258, 262, 268, 274, 276, 278,
     & 282, 284, 290, 292, 296, 298, 302, 310, 314, 316, 318, 322,
     & 326, 328, 332, 334, 344, 346, 348, 354, 356, 358, 362, 366,
     & 368, 370, 372, 376, 382, 386, 388, 394, 398, 402, 404, 406,
     & 410, 412, 414, 422, 424, 426, 428, 430, 434, 436, 438, 444,
     & 446, 452, 454, 458, 460, 464, 466, 470, 472, 474, 478, 482,
     & 488, 492, 496, 498, 502, 506, 508, 514, 516, 518, 522, 524,
     & 526, 530, 534, 536, 538, 542, 548, 552, 554, 556, 558, 562,
     & 564, 566, 568, 574, 580, 582, 584, 586, 590, 592, 596, 598,
     & 602, 604, 606, 610, 614, 618, 620, 622, 626, 628, 632, 634,
     & 636, 638, 642, 644, 652, 654, 656, 658, 662, 664, 666, 668,
     & 670, 674, 678, 682, 688, 690, 692, 694, 696, 698, 706, 708,
     & 710, 712, 716, 718, 724, 730, 732, 734, 736, 738, 740, 742,
     & 744, 746, 752, 754, 758, 762, 764, 766, 772, 774, 776, 778,
     & 782, 786, 788, 790, 794, 796, 804, 806, 808, 812, 814, 820,
     & 822, 824, 826, 828, 830, 834, 844, 846, 848, 852, 854, 856,
     & 860, 868, 870, 872, 874, 876, 888, 890, 892, 894, 902, 904,
     & 906, 908, 916, 920, 928, 930, 932, 938, 940, 942, 944, 946,
     & 948, 954, 956, 962, 964, 966, 970, 976, 978, 984, 986, 992,
     & 994, 996/,
     & iba/6,4,3,2,1/,nba/5/
      mi=0
      do 20 n=1,neq
      mini=nint(12.*mod(tss(ia,n)+1.,1.))
         if(mini.ne.0) then
            if(mi.eq.0) then
      mi=mi+1
      inta(mi)=mini
            endif
      do 10 i=1,mi
      if(inta(i).eq.mini) go to 20
10    continue
      mi=mi+1
      inta(mi)=mini
         endif
20    continue
      mcd=1
      if(mi.eq.0) go to 50
      do 40 j=1,nba
      mcd=iba(j)
      do 30 i=1,mi
      if((inta(i)/mcd)*mcd.ne.inta(i)) go to 40
30    continue
      mcd=12/mcd
      go to 50
40    continue
50    if((mcd/2)*2.ne.mcd) mcd=mcd*2
      ndiv=max(mcd,2)
      mdiv=0
60       if(na.gt.maxs) then
      na=na/ndiv
      mdiv=mdiv+1
      go to 60
         endif
      na=((na+mcd-1)/mcd)*mcd
      do 70 i=1,mp1
         if(na.eq.p1(i)) then
      na=na+mcd
      go to 60
         endif
70    continue
      if(mdiv.ne.0) na=na*ndiv**mdiv
      return
      end
"ENDOF contrg.f"
#=======================================================================
echo datamf.f
cat >datamf.f <<"ENDOF datamf.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine datamf(i1,i2,nd,mi,mr,mc,ii)
      implicit none
      integer hmax,i1,i2,iecr,ii,ilec,kmax,kprt,lmax,mc,mi,mr,nd,ng,nx,
     & ny,nz
      real a,aa,al,alpha,b,bb,be,beta,c,cc,demax,demin,ga,gamma,rbid1,
     & rbid2,rbid3
      dimension ii(*)
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/grid/ hmax,kmax,lmax,nx,ny,nz
      common/ioprg/ ilec,iecr,kprt
      common/reso/ rbid2(2),demax,demin,rbid3
      rewind(i1)
      read(i1) nx,ny,nz,aa,bb,cc,al,be,ga
      if(aa.ne.a.or.bb.ne.b.or.cc.ne.c.or.al.ne.alpha.or.be.ne.beta.
     . or.ga.ne.gamma) go to 901
      call genref(i2,nd,ii(1))
      ng=mi-nd
      if(ng.eq.0) go to 902
      call reffo(i2,ng,nd,ii(1),ii(1+ng))
      call indexm(demin,hmax,kmax,lmax)
      call dimfs(nd,mi,mr,mc)
      if(kprt.ne.0) write(iecr,2010) nx,ny,nz,demin,hmax,kmax,lmax
      return
901   write(iecr,3010)
      stop
902   write(iecr,3020)
      stop
2010  format(/' z-section map'/
     . ' divisions of unit cell edges =',3i10/
     . ' data resolution =',f10.3/
     . ' maximal indices according to data resolution =',3i5)
3010  format('stop >> datamf << incompatible cells')
3020  format('stop >> datamf << insufficient memory for reffo')
      end
"ENDOF datamf.f"
#=======================================================================
echo stfing.f
cat >stfing.f <<"ENDOF stfing.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program stfing
      implicit none
      integer iecr,ii,ilec,kprt,mc,mi,mr,nd
      real rr
      complex cc
      parameter(mi=9000000,mr=9000000,mc=9000000)
      dimension cc(mc),ii(mi),rr(mr)
      common/ioprg/ ilec,iecr,kprt
      ilec=5
      iecr=6
      kprt=1
      nd=1000
      call stfndo(nd,mi,mr,mc,ii,rr,cc)
      stop
      end
"ENDOF stfing.f"
#=======================================================================
echo dimfs.f
cat >dimfs.f <<"ENDOF dimfs.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine dimfs(nd,mi,mr,mc)
      implicit none
      integer hlw,hmax,hup,iecr,ilec,klw,kmax,kprt,kup,llw,lmax,lup,
     & maxd,mc,mcc,mi,mic,mr,mrc,nd,nk,nra,nwdsm,nx,nxyz,ny,nz,ph,pz,td
      common/dfft/ hlw,hup,klw,kup,llw,lup,nra,nxyz
      common/dfftd/ ph,pz,td,nwdsm
      common/grid/ hmax,kmax,lmax,nx,ny,nz
      common/ioprg/ ilec,iecr,kprt
      if(nx.lt.2*(hmax+1).or.ny.lt.2*(kmax+1).or.nz.lt.2*(lmax+1))
     . go to 901
      maxd=nx
      call contrg(nx,1)
      if(maxd.ne.nx) stop ' nx incompatible with Ten Eyck FFT'
      maxd=ny
      call contrg(ny,2)
      if(maxd.ne.ny) stop ' ny incompatible with Ten Eyck FFT'
      maxd=nz
      call contrg(nz,3)
      if(maxd.ne.nz) stop ' nz incompatible with Ten Eyck FFT'
      nxyz=nx*ny*nz
      nk=kup-klw+1
      call diraxh(mr)
      mic=nra+2*nd
      mrc=max(2*ph*nk*nz,nx*ny*pz)
      mcc=nra
      if(kprt.ne.0) write(iecr,2010) mic,mrc,mcc
      if(mic.gt.mi.or.mrc.gt.mr.or.mcc.gt.mc) go to 902
      return
901   write(iecr,3010)
      stop
902   write(iecr,3020)
      stop
2010  format(/' dimensions for stfing'/
     . ' (integer)          mi =',i10/
     . ' (real)             mr =',i10/
     . ' (complex)          mc =',i10)
3010  format('stop >> dimfs << incompatible res.')
3020  format('stop >> dimfs << insufficient memory for stfing')
      end
"ENDOF dimfs.f"
#=======================================================================
echo diprp.f
cat >diprp.f <<"ENDOF diprp.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine diprp(x,y,np,dim,psym,sym,unsym)
      implicit none
      integer a,al,b,bl,bs,c,cl,cs,d,d1,d2,d3,d4,d5,del,dim,dk,dl,ds,e,
     & el,es,f,fl,fs,g,gl,gs,h,hl,hs,i,i0,i1,i2,il,is,itest,j,jj,jl,js,
     & k,kk,kl,ks,l,lk,ll,ls,m,ml,mods,modulo,ms,mul,n,nest,nl,np,ns,p,
     & psym,punsym,q,s,sym,u,unsym
      real t,x,y
      logical onemod
      dimension dim(*),modulo(14),s(14),sym(*),u(14),unsym(*),x(*),y(*)
      equivalence (al,u(1)),(bl,u(2)),(cl,u(3)),(dl,u(4)),(el,u(5)),
     & (fl,u(6)),(gl,u(7)),(hl,u(8)),(il,u(9)),(jl,u(10)),(kl,u(11)),
     & (ll,u(12)),(ml,u(13)),(nl,u(14)),(bs,s(2)),(cs,s(3)),(ds,s(4)),
     & (es,s(5)),(fs,s(6)),(gs,s(7)),(hs,s(8)),(is,s(9)),(js,s(10)),
     & (ks,s(11)),(ls,s(12)),(ms,s(13)),(ns,s(14))
cjn uninitialized values
      data mods/0/
      nest=14
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      if(sym(1).eq.0) go to 200
      do 10 j=1,nest
      u(j)=1
      s(j)=1
10    continue
      n=np
      do 20 j=1,nest
      if(sym(j).eq.0) go to 30
      jj=nest+1-j
      u(jj)=n
      s(jj)=n/sym(j)
      n=n/sym(j)
20    continue
30    jj=0
      do 190 a=1,al
      do 180 b=a,bl,bs
      do 170 c=b,cl,cs
      do 160 d=c,dl,ds
      do 150 e=d,el,es
      do 140 f=e,fl,fs
      do 130 g=f,gl,gs
      do 120 h=g,hl,hs
      do 110 i=h,il,is
      do 100 j=i,jl,js
      do 90 k=j,kl,ks
      do 80 l=k,ll,ls
      do 70 m=l,ml,ms
      do 60 n=m,nl,ns
      jj=jj+1
      if(jj.ge.n) go to 60
      del=(n-jj)*d2
      i0=(jj-1)*d2+1
      do 50 i1=i0,d1,d3
      i2=i1+d4
      do 40 p=i1,i2,d5
      q=p+del
      t=x(p)
      x(p)=x(q)
      x(q)=t
      t=y(p)
      y(p)=y(q)
      y(q)=t
40    continue
50    continue
60    continue
70    continue
80    continue
90    continue
100   continue
110   continue
120   continue
130   continue
140   continue
150   continue
160   continue
170   continue
180   continue
190   continue
200   if(unsym(1).eq.0) go to 350
      punsym=np/psym**2
      mul=punsym/unsym(1)
      itest=(unsym(1)*unsym(2)-1)*mul*psym
      lk=mul
      dk=mul
      do 210 k=2,nest
      if(unsym(k).eq.0) go to 220
      lk=lk*unsym(k-1)
      dk=dk/unsym(k)
      u(k)=(lk-dk)*psym
      mods=k
210   continue
220   onemod=mods.lt.3
      if(onemod) go to 240
      do 230 j=3,mods
      jj=mods+3-j
      modulo(jj)=u(j)
230   continue
240   modulo(2)=u(2)
      jl=(punsym-3)*psym
      ms=punsym*psym
      do 340 j=psym,jl,psym
      k=j
250   k=k*mul
      if(onemod) go to 270
      do 260 i=3,mods
      k=k-(k/modulo(i))*modulo(i)
260   continue
270   if(k.ge.itest) go to 280
      k=k-(k/modulo(2))*modulo(2)
      go to 290
280   k=k-(k/modulo(2))*modulo(2)+modulo(2)
290   if(k.lt.j) go to 250
      if(k.eq.j) go to 340
      del=(k-j)*d2
      do 330 l=1,psym
      do 320 m=l,np,ms
      i0=(m+j-1)*d2+1
      do 310 i1=i0,d1,d3
      i2=i1+d4
      do 300 jj=i1,i2,d5
      kk=jj+del
      t=x(jj)
      x(jj)=x(kk)
      x(kk)=t
      t=y(jj)
      y(jj)=y(kk)
      y(kk)=t
300   continue
310   continue
320   continue
330   continue
340   continue
350   return
      end
"ENDOF diprp.f"
#=======================================================================
echo diraxh.f
cat >diraxh.f <<"ENDOF diraxh.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine diraxh(mr)
      implicit none
      integer hlw,hup,ibid1,ibid2,iecr,ilec,klw,kprt,kup,maxr,minr,mr,
     & nh,nk,nrec,nwds,nwdsm,nx,nxyz,ny,nz,ph,pz,td
      common/dfft/ hlw,hup,klw,kup,ibid1(3),nxyz
      common/dfftd/ ph,pz,td,nwdsm
      common/grid/ ibid2(3),nx,ny,nz
      common/ioprg/ ilec,iecr,kprt
      nh=hup-hlw+1
      nk=kup-klw+1
      td=90
      nwds=0
      call abra(td,'d','s',nwds)
         if(mr.ge.nxyz) then
      ph=nh
      pz=nz
      return
         endif
      minr=max(2*nk*nz,nx*ny)
      if(mr.lt.minr) go to 901
      maxr=sqrt(real(nwdsm))*sqrt(real(nxyz))
         if(mr.gt.maxr) then
      ph=min(maxr/(2*nk*nz),nh)
      pz=min(maxr/(nx*ny),nz)
         else
      ph=min(mr/(2*nk*nz),nh)
      pz=min(mr/(nx*ny),nz)
         endif
      nwds=2*ph*nk*pz
      nrec=((nh-1)/ph+1)*((nz-1)/pz+1)
      if(kprt.ne.0) write(iecr,2010) ph,pz,nwds,nrec
      return
901   write(iecr,3010) minr
      stop
2010  format(/' direct access. pages(ph,pz) =',2i5,
     . ', words =',i10,', recds =',i5)
3010  format('stop >> diraxh << insufficient memory. smallest mr =',i10)
      end
"ENDOF diraxh.f"
#=======================================================================
echo gendath.f
cat >gendath.f <<"ENDOF gendath.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine gendath(o1,nra,nd,hkl,hklo,imo,mfo,phfo,fc)
      implicit none
      integer h,hkl,hklo,i,iecr,ifom,ilec,imo,ix1,ix2,k,kprt,krep,l,nd,
     & nra,ntot,o1
      real a,a11,a21,a22,a31,a32,a33,alpha,b,beta,bfac,c,dtor,fooo,
     & gamma,mf,mfo,phfo,phi,pi,rbid1,rtod,sqh,twopi,vol,zn
      complex fc
      character forme*80
      dimension fc(nra),hkl(nra),hklo(nd),imo(nd),mfo(nd),phfo(nd)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(15),vol
      common/fozo/ fooo,zn,bfac,krep
      common/ioprg/ ilec,iecr,kprt
      common/star/ a11,a21,a22,a31,a32,a33
      imo(1)=hklo(1)
      phfo(1)=mfo(1)
      ifom=100
      ntot=0
      rewind(o1)
      write(o1,'(6f10.3,a)') a,b,c,alpha,beta,gamma,' CELL'
       do i=1,80
      forme(i:i)=' '
       enddo
      forme(1:12)='(3i5,3f20.5)'
      write(o1,'(a,a)') 'FORMAT ',forme
      write(o1,'(a)') 'PHASE'
      do 10 i=1,nra
      mf=abs(fc(i))
         if(mf.gt.0.) then
      phi=aimag(clog(fc(i)))
         else
      phi=0.
         endif
      call unpac5(h,k,l,ix2,ix1,hkl(i))
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      mf=mf*vol*exp(-bfac*sqh/4.)
      phi=phi*rtod
      write(o1,forme) h,k,l,mf,phi,sqrt(sqh)
      ntot=ntot+1
10    continue
      if(kprt.ne.0) write(iecr,2010) ntot,bfac
      return
2010  format(/' gendat type hkl.',i10,' coefficients written'/
     . ' fo = f*exp(-b*hsq/4)*vol. b =',f10.3)
      end
"ENDOF gendath.f"
#=======================================================================
echo genref.f
cat >genref.f <<"ENDOF genref.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine genref(o1,nd,hklo)
      implicit none
      integer h,hklo,hmax,hmin,i,ind,index,ires,j,k,kmax,kmin,l,lmax,
     & lmin,mult,nd,ntot,o1
      real a11,a21,a22,a31,a32,a33,drmin,rbid1,rbid2,sqh,sqhmax
      logical deja,exts
      dimension hklo(nd)
      common/reso/ rbid1,drmin,rbid2(3)
      common/star/ a11,a21,a22,a31,a32,a33
      sqhmax=(1/drmin)**2
      call indexm(drmin,hmax,kmax,lmax)
      hmin=0
      kmin=-kmax
      lmin=-lmax
      index=0
      j=0
      ntot=0
      rewind(o1)
      do 20 l=lmin,lmax
      do 20 k=kmin,kmax
      do 10 h=hmin,hmax
      call sympac(h,k,l,index,deja,exts)
      if(deja.or.exts) go to 10
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.sqhmax) go to 10
      call pac3(h,k,l,index)
      call multes(h,k,l,mult,ires)
      call pac5(h,k,l,mult,ires,ind)
      j=j+1
      hklo(j)=ind
         if(j.eq.nd) then
      write(o1) j,hklo
      ntot=ntot+j
      j=0
         endif
10    continue
20    continue
         if(ntot.ne.0) then
      if(j.ne.0) write(o1) j,hklo
         else
      write(o1) j,(hklo(i),i=1,j)
      nd=j
         endif
      return
      end
"ENDOF genref.f"
#=======================================================================
echo hout.f
cat >hout.f <<"ENDOF hout.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine hout(td,nh,nk,pz,ph,zs,ww)
      implicit none
      integer hf,hs,ih,ikz,irec,nh,nk,ph,pz,td,zs
      complex ww
      dimension ww(nh,nk*pz)
      save irec
      if(zs.eq.0) irec=0
      hf=0
10    hs=hf+1
      hf=hf+ph
      if(hf.gt.nh) hf=nh
      irec=irec+1
      write(td,rec=irec) ((ww(ih,ikz),ih=hs,hf),ikz=1,nk*pz)
      if(hf.lt.nh) go to 10
      return
      end
"ENDOF hout.f"
#=======================================================================
echo indexm.f
cat >indexm.f <<"ENDOF indexm.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine indexm(dmin,hmax,kmax,lmax)
      implicit none
      integer hmax,kmax,lmax
      real a,b,c,dmin,fuzz,rbid1
      common/cell/ a,b,c,rbid1(19)
      data fuzz/1.0001/
      hmax=fuzz*a/dmin
      kmax=fuzz*b/dmin
      lmax=fuzz*c/dmin
      return
      end
"ENDOF indexm.f"
#=======================================================================
echo lecsim.f
cat >lecsim.f <<"ENDOF lecsim.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lecsim
      implicit none
      integer i,iecr,ilec,j,kprt,mss,n,neq,nts
      real tss,tts
      common/ioprg/ ilec,iecr,kprt
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      call symcar
      if(kprt.ne.0) write(iecr,2010) neq,nts
      do 10 n=1,neq
      if(kprt.ne.0) write(iecr,2020) ((mss(i,j,n),j=1,3),tss(i,n),i=1,3)
10    continue
      do 20 n=1,nts
      if(kprt.ne.0) write(iecr,2030) (tts(i,n),i=1,3)
20    continue
      return
2010  format(/' space group.',i5,' equivalent positions and',i5,
     . ' centring translations')
2020  format(3(/3i5,f10.6))
2030  format(/3f10.6)
      end
"ENDOF lecsim.f"
#=======================================================================
echo lungo.f
cat >lungo.f <<"ENDOF lungo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function lungo(card,nfield)
      implicit none
      integer i,lungo,nfield
      character card*1
      dimension card(nfield)
       do i=nfield,1,-1
      if(card(i).ne.' ') go to 10
       enddo
10    lungo=i
      return
      end
"ENDOF lungo.f"
#=======================================================================
echo mdftkd.f
cat >mdftkd.f <<"ENDOF mdftkd.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine mdftkd(x,y,n,dim,factor)
      implicit none
      integer dim,f,factor,iecr,ilec,kprt,m,n,p,r,s
      real x,y
      dimension dim(*),factor(*),x(*),y(*)
      common/ioprg/ ilec,iecr,kprt
      s=dim(2)
      f=0
      m=n
10    f=f+1
      p=factor(f)
      if(p.eq.0) go to 20
      m=m/p
      r=m*s
         if(p.eq.1) then
      go to 10
         else if(p.eq.2) then
      call r2cftk(x(1),y(1),x(r+1),y(r+1),n,m,dim)
         else if(p.eq.3) then
      call r3cftk(n,m,x(1),y(1),x(r+1),y(r+1),x(2*r+1),y(2*r+1),dim)
         else if(p.eq.4) then
      call r4cftk(n,m,x(1),y(1),x(r+1),y(r+1),x(2*r+1),y(2*r+1),
     . x(3*r+1),y(3*r+1),dim)
         else if(p.eq.5) then
      call r5cftk(n,m,x(1),y(1),x(r+1),y(r+1),x(2*r+1),y(2*r+1),
     . x(3*r+1),y(3*r+1),x(4*r+1),y(4*r+1),dim)
         else if(p.eq.8) then
      call r8cftk(n,m,x(1),y(1),x(r+1),y(r+1),x(2*r+1),y(2*r+1),
     . x(3*r+1),y(3*r+1),x(4*r+1),y(4*r+1),x(5*r+1),y(5*r+1),
     . x(6*r+1),y(6*r+1),x(7*r+1),y(7*r+1),dim)
         else if(p.eq.7.or.p.le.19) then
      call rpcftk(x,y,n,m,dim,r,p)
         else
      go to 901
         endif
      go to 10
20    return
901   write(iecr,3010)
      stop
3010  format('stop >> mdftkd << transfer error')
      end
"ENDOF mdftkd.f"
#=======================================================================
echo multes.f
cat >multes.f <<"ENDOF multes.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine multes(h,k,l,mult,ires)
      implicit none
      integer h,hh,hkl,iecr,iind,ilec,ind,indo,ires,k,kk,kprt,l,ll,m,
     & mss,mult,n,neq,nts
      real pr,tss,tts
      logical first,primo
      dimension hkl(48)
      common/ioprg/ ilec,iecr,kprt
      common/simt/ tss(3,48),tts(9),mss(3,3,48),neq,nts
      data first/.true./
      save indo,primo
         if(first) then
      call pac3(0,0,0,indo)
      first=.false.
      primo=.true.
         endif
      if(h.lt.0) go to 901
      call pac3(h,k,l,ind)
         if(ind.eq.indo) then
      mult=1
      ires=1
      go to 40
         endif
      mult=0
      ires=0
      do 30 n=1,neq
      hh=h*mss(1,1,n)+k*mss(2,1,n)+l*mss(3,1,n)
      kk=h*mss(1,2,n)+k*mss(2,2,n)+l*mss(3,2,n)
      ll=h*mss(1,3,n)+k*mss(2,3,n)+l*mss(3,3,n)
         if(hh.eq.-h.and.kk.eq.-k.and.ll.eq.-l) then
      pr=mod(h*tss(1,n)+k*tss(2,n)+l*tss(3,n),1.)
      ires=1+mod(12+nint(12*pr),12)
         endif
c pacote
         if(hh.lt.0.or.(hh.eq.0.and.(ll.gt.0.or.(ll.eq.0.and.kk.gt.0))))
     . then
      hh=-hh
      kk=-kk
      ll=-ll
         endif
      call pac3(hh,kk,ll,iind)
         if(primo.and.iind.lt.ind) then
      if(kprt.ne.0) write(iecr,3001)
      primo=.false.
         endif
      if(n.eq.1) go to 20
      do 10 m=1,mult
      if(hkl(m).eq.iind) go to 30
10    continue
20    mult=mult+1
      hkl(mult)=iind
30    continue
      mult=mult*2
40    return
901   write(iecr,3010)
      stop
3001  format(/' >> warning << data is not optimally sorted')
3010  format('stop >> multes << reflection out of order')
      end
"ENDOF multes.f"
#=======================================================================
echo pac3.f
cat >pac3.f <<"ENDOF pac3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pac3(ih,ik,il,ind)
      implicit none
      integer hm,iecr,ih,ik,il,ilec,ind,km,kprt,lm,nh,nk,nl,nm,nr
      common/ioprg/ ilec,iecr,kprt
      common/paco/ hm,km,lm,nh,nk,nl,nm,nr
      if(ih+hm.lt.0.or.ih+hm.ge.nh.or.ik+km.lt.0.or.ik+km.ge.nk.or.
     . il+lm.lt.0.or.il+lm.ge.nl) go to 901
      ind=((il+lm)*nk+ik+km)*nh+ih+hm
      return
901   write(iecr,3010) ih,ik,il
      stop
3010  format('stop >> pac3 << maximal indices exceeded =',3i5)
      end
"ENDOF pac3.f"
#=======================================================================
echo pac5.f
cat >pac5.f <<"ENDOF pac5.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pac5(ih,ik,il,im,ir,ind)
      implicit none
      integer hm,iecr,ih,ik,il,ilec,im,ind,ir,km,kprt,lm,nh,nk,nl,nm,nr
      common/ioprg/ ilec,iecr,kprt
      common/paco/ hm,km,lm,nh,nk,nl,nm,nr
      if(ih+hm.lt.0.or.ih+hm.ge.nh.or.ik+km.lt.0.or.ik+km.ge.nk.or.
     . il+lm.lt.0.or.il+lm.ge.nl.or.im.lt.0.or.im.ge.nm) go to 901
      ind=((((il+lm)*nk+ik+km)*nh+ih+hm)*nm+im)*nr+ir
      return
901   write(iecr,3010) ih,ik,il,im,ir
      stop
3010  format('stop >> pac5 << maximal indices exceeded =',5i5)
      end
"ENDOF pac5.f"
#=======================================================================
echo phkl1.f
cat >phkl1.f <<"ENDOF phkl1.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine phkl1(nra,ph,nk,nz,hs,hkl,ww,fc)
      implicit none
      integer h,hf,hh,hkl,hs,i,ibid1,ires,ix2,k,kk,l,ll,nk,nra,nxyz,nz,
     & ph
      real scale
      complex c,cs,f,fc,ww
      dimension c(12),cs(12),fc(nra),hkl(nra),ww(ph,nk,nz)
      common/dfft/ ibid1(7),nxyz
      data c/
     & ( 1.       , 0.)       ,( 0.96592583, 0.25881905),
     & ( 0.8660254, 0.5)      ,( 0.70710678, 0.70710678),
     & ( 0.5      , 0.8660254),( 0.25881905, 0.96592583),
     & ( 0.       , 1.)       ,(-0.25881905, 0.96592583),
     & (-0.5      , 0.8660254),(-0.70710678, 0.70710678),
     & (-0.8660254, 0.5)      ,(-0.96592583, 0.25881905)/,
     & cs/
     & ( 1.       , 0.)       ,( 0.96592583,-0.25881905),
     & ( 0.8660254,-0.5)      ,( 0.70710678,-0.70710678),
     & ( 0.5      ,-0.8660254),( 0.25881905,-0.96592583),
     & ( 0.       ,-1.)       ,(-0.25881905,-0.96592583),
     & (-0.5      ,-0.8660254),(-0.70710678,-0.70710678),
     & (-0.8660254,-0.5)      ,(-0.96592583,-0.25881905)/
      scale=1./nxyz
      hf=hs+ph-1
      do 10 i=1,nra
      call unpac5(h,k,l,ix2,ires,hkl(i))
      if(h.lt.hs.or.h.gt.hf) go to 10
      hh=h-hs+1
      kk=k+1
      if(kk.le.0) kk=kk+nk
      ll=l+1
      if(ll.le.0) ll=ll+nz
      f=conjg(ww(hh,kk,ll))*scale
      if(ires.ne.0) f=real(f*cs(ires))*c(ires)
      fc(i)=f
10    continue
      return
      end
"ENDOF phkl1.f"
#=======================================================================
echo r2cftk.f
cat >r2cftk.f <<"ENDOF r2cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r2cftk(x0,y0,x1,y1,n,m,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,i,i0,i1,i2,imax,j,m,m1,m2,mm2,ms2,
     & n,ns
      real angle,c,is,iu,ktes,rs,ru,s,twopi,x0,x1,y0,y1
      logical fold,zero
      dimension dim(*),x0(*),x1(*),y0(*),y1(*)
      common/fftkte/ twopi,ktes(7)
cjn uninitialized values
      data c,s/0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      ms2=m/2+1
      imax=ms2
      if(2*ms2.lt.m+2) imax=imax+1
      m2=m*2
      mm2=m2*d2
      m1=-1
      do 70 i=1,ms2
      fold=i.gt.1.and.i.lt.imax
      del=(i-1)*d2+1
      m1=m1+1
      angle=m1*twopi/m2
      zero=angle.eq.0.
      if(zero) go to 20
      c=cos(angle)
      s=sin(angle)
      go to 20
10    fold=.false.
      del=(m+1-i)*d2+1
      c=-c
20    do 60 i0=del,ns,mm2
      do 50 i1=i0,d1,d3
      i2=i1+d4
      do 40 j=i1,i2,d5
      rs=x0(j)+x1(j)
      is=y0(j)+y1(j)
      ru=x0(j)-x1(j)
      iu=y0(j)-y1(j)
      x0(j)=rs
      y0(j)=is
      if(zero) go to 30
      x1(j)=ru*c+iu*s
      y1(j)=iu*c-ru*s
      go to 40
30    x1(j)=ru
      y1(j)=iu
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r2cftk.f"
#=======================================================================
echo r3cftk.f
cat >r3cftk.f <<"ENDOF r3cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r3cftk(n,m,x0,y0,x1,y1,x2,y2,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,j,k,k1,kk,l,m,m3,mm3,mover2,n,ns
      real a,angle,b,c1,c2,fjm1,fm3,i0,i1,i2,ia,ib,is,ktes,r0,r1,r2,ra,
     & rb,rs,s1,s2,t,twopi,x0,x1,x2,y0,y1,y2
      logical fold,zero
      dimension dim(*),x0(*),x1(*),x2(*),y0(*),y1(*),y2(*)
      common/fftkte/ twopi,a,b,ktes(5)
cjn uninitialized values
      data c1,c2,s1,s2/0.,0.,0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      m3=m*3
      fm3=m3
      mm3=d2*m3
      mover2=m/2+1
      fjm1=-1.
      do 70 j=1,mover2
      fold=j.gt.1.and.2*j.lt.m+2
      del=(j-1)*d2+1
      fjm1=fjm1+1.
      angle=twopi*fjm1/fm3
      zero=angle.eq.0.
      if(zero) go to 20
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      go to 20
10    fold=.false.
      del=(m+1-j)*d2+1
      t=c1*a+s1*b
      s1=c1*b-s1*a
      c1=t
      t=c2*a-s2*b
      s2=-c2*b-s2*a
      c2=t
20    do 60 kk=del,ns,mm3
      do 50 l=kk,d1,d3
      k1=l+d4
      do 40 k=l,k1,d5
      r0=x0(k)
      i0=y0(k)
      rs=x1(k)+x2(k)
      is=y1(k)+y2(k)
      x0(k)=r0+rs
      y0(k)=i0+is
      ra=r0+rs*a
      ia=i0+is*a
      rb=(x1(k)-x2(k))*b
      ib=(y1(k)-y2(k))*b
      if(zero) go to 30
      r1=ra+ib
      i1=ia-rb
      r2=ra-ib
      i2=ia+rb
      x1(k)=r1*c1+i1*s1
      y1(k)=i1*c1-r1*s1
      x2(k)=r2*c2+i2*s2
      y2(k)=i2*c2-r2*s2
      go to 40
30    x1(k)=ra+ib
      y1(k)=ia-rb
      x2(k)=ra-ib
      y2(k)=ia+rb
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r3cftk.f"
#=======================================================================
echo r4cftk.f
cat >r4cftk.f <<"ENDOF r4cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r4cftk(n,m,x0,y0,x1,y1,x2,y2,x3,y3,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,j,k,k1,kk,l,m,m4,mm4,mover2,n,ns
      real angle,c1,c2,c3,fjm1,fm4,i1,i2,i3,is0,is1,iu0,iu1,ktes,r1,r2,
     & r3,rs0,rs1,ru0,ru1,s1,s2,s3,t,twopi,x0,x1,x2,x3,y0,y1,y2,y3
      logical fold,zero
      dimension dim(*),x0(*),x1(*),x2(*),x3(*),y0(*),y1(*),y2(*),y3(*)
      common/fftkte/ twopi,ktes(7)
cjn uninitialized values
      data c1,c2,c3,s1,s2,s3/0.,0.,0.,0.,0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      m4=m*4
      fm4=m4
      mm4=d2*m4
      mover2=m/2+1
      fjm1=-1.
      do 70 j=1,mover2
      fold=j.gt.1.and.2*j.lt.m+2
      del=(j-1)*d2+1
      fjm1=fjm1+1.
      angle=twopi*fjm1/fm4
      zero=angle.eq.0.
      if(zero) go to 20
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      c3=c2*c1-s2*s1
      s3=s2*c1+c2*s1
      go to 20
10    fold=.false.
      del=(m+1-j)*d2+1
      t=c1
      c1=s1
      s1=t
      c2=-c2
      t=c3
      c3=-s3
      s3=-t
20    do 60 kk=del,ns,mm4
      do 50 l=kk,d1,d3
      k1=l+d4
      do 40 k=l,k1,d5
      rs0=x0(k)+x2(k)
      is0=y0(k)+y2(k)
      ru0=x0(k)-x2(k)
      iu0=y0(k)-y2(k)
      rs1=x1(k)+x3(k)
      is1=y1(k)+y3(k)
      ru1=x1(k)-x3(k)
      iu1=y1(k)-y3(k)
      x0(k)=rs0+rs1
      y0(k)=is0+is1
      if(zero) go to 30
      r1=ru0+iu1
      i1=iu0-ru1
      r2=rs0-rs1
      i2=is0-is1
      r3=ru0-iu1
      i3=iu0+ru1
      x2(k)=r1*c1+i1*s1
      y2(k)=i1*c1-r1*s1
      x1(k)=r2*c2+i2*s2
      y1(k)=i2*c2-r2*s2
      x3(k)=r3*c3+i3*s3
      y3(k)=i3*c3-r3*s3
      go to 40
30    x2(k)=ru0+iu1
      y2(k)=iu0-ru1
      x1(k)=rs0-rs1
      y1(k)=is0-is1
      x3(k)=ru0-iu1
      y3(k)=iu0+ru1
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r4cftk.f"
#=======================================================================
echo r5cftk.f
cat >r5cftk.f <<"ENDOF r5cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r5cftk(n,m,x0,y0,x1,y1,x2,y2,x3,y3,x4,y4,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,j,k,k1,kk,l,m,m5,mm5,mover2,n,ns
      real a1,a2,angle,b1,b2,c1,c2,c3,c4,e,fjm1,fm5,i0,i1,i2,i3,i4,ia1,
     & ia2,ib1,ib2,is1,is2,iu1,iu2,ktes,r0,r1,r2,r3,r4,ra1,ra2,rb1,rb2,
     & rs1,rs2,ru1,ru2,s1,s2,s3,s4,t,twopi,x0,x1,x2,x3,x4,y0,y1,y2,y3,y4
      logical fold,zero
      dimension dim(*),x0(*),x1(*),x2(*),x3(*),x4(*),y0(*),y1(*),y2(*),
     & y3(*),y4(*)
      common/fftkte/ twopi,ktes(2),a1,b1,a2,b2,e
cjn uninitialized values
      data c1,c2,c3,c4,s1,s2,s3,s4/0.,0.,0.,0.,0.,0.,0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      m5=m*5
      fm5=m5
      mm5=d2*m5
      mover2=m/2+1
      fjm1=-1.
      do 70 j=1,mover2
      fold=j.gt.1.and.2*j.lt.m+2
      del=(j-1)*d2+1
      fjm1=fjm1+1.
      angle=twopi*fjm1/fm5
      zero=angle.eq.0.
      if(zero) go to 20
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      c3=c2*c1-s2*s1
      s3=s2*c1+c2*s1
      c4=c2*c2-s2*s2
      s4=s2*c2+c2*s2
      go to 20
10    fold=.false.
      del=(m+1-j)*d2+1
      t=c1*a1+s1*b1
      s1=c1*b1-s1*a1
      c1=t
      t=c2*a2+s2*b2
      s2=c2*b2-s2*a2
      c2=t
      t=c3*a2-s3*b2
      s3=-c3*b2-s3*a2
      c3=t
      t=c4*a1-s4*b1
      s4=-c4*b1-s4*a1
      c4=t
20    do 60 kk=del,ns,mm5
      do 50 l=kk,d1,d3
      k1=l+d4
      do 40 k=l,k1,d5
      r0=x0(k)
      i0=y0(k)
      rs1=x1(k)+x4(k)
      is1=y1(k)+y4(k)
      ru1=x1(k)-x4(k)
      iu1=y1(k)-y4(k)
      rs2=x2(k)+x3(k)
      is2=y2(k)+y3(k)
      ru2=x2(k)-x3(k)
      iu2=y2(k)-y3(k)
      x0(k)=r0+rs1+rs2
      y0(k)=i0+is1+is2
      ra1=r0+rs1*a1+rs2*a2
      ia1=i0+is1*a1+is2*a2
      ra2=r0+rs1*a2+rs2*a1
      ia2=i0+is1*a2+is2*a1
      rb1=ru1*b1+ru2*b2
      ib1=iu1*b1+iu2*b2
      rb2=ru1*b2-ru2*b1
      ib2=iu1*b2-iu2*b1
      if(zero) go to 30
      r1=ra1+ib1
      i1=ia1-rb1
      r2=ra2+ib2
      i2=ia2-rb2
      r3=ra2-ib2
      i3=ia2+rb2
      r4=ra1-ib1
      i4=ia1+rb1
      x1(k)=r1*c1+i1*s1
      y1(k)=i1*c1-r1*s1
      x2(k)=r2*c2+i2*s2
      y2(k)=i2*c2-r2*s2
      x3(k)=r3*c3+i3*s3
      y3(k)=i3*c3-r3*s3
      x4(k)=r4*c4+i4*s4
      y4(k)=i4*c4-r4*s4
      go to 40
30    x1(k)=ra1+ib1
      y1(k)=ia1-rb1
      x2(k)=ra2+ib2
      y2(k)=ia2-rb2
      x3(k)=ra2-ib2
      y3(k)=ia2+rb2
      x4(k)=ra1-ib1
      y4(k)=ia1+rb1
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r5cftk.f"
#=======================================================================
echo r8cftk.f
cat >r8cftk.f <<"ENDOF r8cftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine r8cftk(n,m,x0,y0,x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6,
     & x7,y7,dim)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,j,k,k1,kk,l,m,m8,mm8,mover2,n,ns
      real angle,c1,c2,c3,c4,c5,c6,c7,e,fjm1,fm8,i1,i2,i3,i4,i5,i6,i7,
     & is0,is1,is2,is3,iss0,iss1,isu0,isu1,iu0,iu1,iu2,iu3,ius0,ius1,
     & iuu0,iuu1,ktes,r1,r2,r3,r4,r5,r6,r7,rs0,rs1,rs2,rs3,rss0,rss1,
     & rsu0,rsu1,ru0,ru1,ru2,ru3,rus0,rus1,ruu0,ruu1,s1,s2,s3,s4,s5,s6,
     & s7,t,twopi,x0,x1,x2,x3,x4,x5,x6,x7,y0,y1,y2,y3,y4,y5,y6,y7
      logical fold,zero
      dimension dim(*),x0(*),x1(*),x2(*),x3(*),x4(*),x5(*),x6(*),x7(*),
     & y0(*),y1(*),y2(*),y3(*),y4(*),y5(*),y6(*),y7(*)
      common/fftkte/ twopi,ktes(6),e
cjn uninitialized values
      data c1,c2,c3,c4,c5,c6,c7,s1,s2,s3,s4,s5,s6,s7
     & /0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0./
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      m8=m*8
      fm8=m8
      mm8=d2*m8
      mover2=m/2+1
      fjm1=-1.
      do 70 j=1,mover2
      fold=j.gt.1.and.2*j.lt.m+2
      del=(j-1)*d2+1
      fjm1=fjm1+1.
      angle=twopi*fjm1/fm8
      zero=angle.eq.0.
      if(zero) go to 20
      c1=cos(angle)
      s1=sin(angle)
      c2=c1*c1-s1*s1
      s2=s1*c1+c1*s1
      c3=c2*c1-s2*s1
      s3=s2*c1+c2*s1
      c4=c2*c2-s2*s2
      s4=s2*c2+c2*s2
      c5=c4*c1-s4*s1
      s5=s4*c1+c4*s1
      c6=c4*c2-s4*s2
      s6=s4*c2+c4*s2
      c7=c4*c3-s4*s3
      s7=s4*c3+c4*s3
      go to 20
10    fold=.false.
      del=(m+1-j)*d2+1
      t=(c1+s1)*e
      s1=(c1-s1)*e
      c1=t
      t=s2
      s2=c2
      c2=t
      t=(-c3+s3)*e
      s3=(c3+s3)*e
      c3=t
      c4=-c4
      t=-(c5+s5)*e
      s5=(-c5+s5)*e
      c5=t
      t=-s6
      s6=-c6
      c6=t
      t=(c7-s7)*e
      s7=-(c7+s7)*e
      c7=t
20    do 60 kk=del,ns,mm8
      do 50 l=kk,d1,d3
      k1=l+d4
      do 40 k=l,k1,d5
      rs0=x0(k)+x4(k)
      is0=y0(k)+y4(k)
      ru0=x0(k)-x4(k)
      iu0=y0(k)-y4(k)
      rs1=x1(k)+x5(k)
      is1=y1(k)+y5(k)
      ru1=x1(k)-x5(k)
      iu1=y1(k)-y5(k)
      rs2=x2(k)+x6(k)
      is2=y2(k)+y6(k)
      ru2=x2(k)-x6(k)
      iu2=y2(k)-y6(k)
      rs3=x3(k)+x7(k)
      is3=y3(k)+y7(k)
      ru3=x3(k)-x7(k)
      iu3=y3(k)-y7(k)
      rss0=rs0+rs2
      iss0=is0+is2
      rsu0=rs0-rs2
      isu0=is0-is2
      rss1=rs1+rs3
      iss1=is1+is3
      rsu1=rs1-rs3
      isu1=is1-is3
      rus0=ru0-iu2
      ius0=iu0+ru2
      ruu0=ru0+iu2
      iuu0=iu0-ru2
      rus1=ru1-iu3
      ius1=iu1+ru3
      ruu1=ru1+iu3
      iuu1=iu1-ru3
      t=(rus1+ius1)*e
      ius1=(ius1-rus1)*e
      rus1=t
      t=(ruu1+iuu1)*e
      iuu1=(iuu1-ruu1)*e
      ruu1=t
      x0(k)=rss0+rss1
      y0(k)=iss0+iss1
      if(zero) go to 30
      r1=ruu0+ruu1
      i1=iuu0+iuu1
      r2=rsu0+isu1
      i2=isu0-rsu1
      r3=rus0+ius1
      i3=ius0-rus1
      r4=rss0-rss1
      i4=iss0-iss1
      r5=ruu0-ruu1
      i5=iuu0-iuu1
      r6=rsu0-isu1
      i6=isu0+rsu1
      r7=rus0-ius1
      i7=ius0+rus1
      x4(k)=r1*c1+i1*s1
      y4(k)=i1*c1-r1*s1
      x2(k)=r2*c2+i2*s2
      y2(k)=i2*c2-r2*s2
      x6(k)=r3*c3+i3*s3
      y6(k)=i3*c3-r3*s3
      x1(k)=r4*c4+i4*s4
      y1(k)=i4*c4-r4*s4
      x5(k)=r5*c5+i5*s5
      y5(k)=i5*c5-r5*s5
      x3(k)=r6*c6+i6*s6
      y3(k)=i6*c6-r6*s6
      x7(k)=r7*c7+i7*s7
      y7(k)=i7*c7-r7*s7
      go to 40
30    x4(k)=ruu0+ruu1
      y4(k)=iuu0+iuu1
      x2(k)=rsu0+isu1
      y2(k)=isu0-rsu1
      x6(k)=rus0+ius1
      y6(k)=ius0-rus1
      x1(k)=rss0-rss1
      y1(k)=iss0-iss1
      x5(k)=ruu0-ruu1
      y5(k)=iuu0-iuu1
      x3(k)=rsu0-isu1
      y3(k)=isu0+rsu1
      x7(k)=rus0-ius1
      y7(k)=ius0+rus1
40    continue
50    continue
60    continue
      if(fold) go to 10
70    continue
      return
      end
"ENDOF r8cftk.f"
#=======================================================================
echo realft.f
cat >realft.f <<"ENDOF realft.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine realft(n,dim,even,odd)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,i,i0,i1,i2,j,k,n,ns2,ns4
      real a,angle,b,c,co,d,e,even,f,ktes,odd,si,twopi
      dimension dim(*),even(*),odd(*)
      common/fftkte/ twopi,ktes(7)
      ns2=n/2
      call cmplft(ns2,dim,even,odd)
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns4=ns2/2
      if(ns4.lt.1) go to 40
      do 30 i=1,ns4
      del=(ns2-2*i)*d2
      angle=i*twopi/n
      co=cos(angle)
      si=sin(angle)
      i0=i*d2+1
      do 20 i1=i0,d1,d3
      i2=i1+d4
      do 10 j=i1,i2,d5
      k=j+del
      a=(even(k)+even(j))/2.
      b=(even(k)-even(j))/2.
      c=(odd(k)+odd(j))/2.
      d=(odd(k)-odd(j))/2.
      e=b*co-c*si
      f=b*si+c*co
      even(j)=a+f
      even(k)=a-f
      odd(j)=e-d
      odd(k)=e+d
10    continue
20    continue
30    continue
40    if(ns2.lt.1) return
      do 60 i1=1,d1,d3
      i2=i1+d4
      do 50 j=i1,i2,d5
      even(j)=even(j)+odd(j)
      odd(j)=0.
50    continue
60    continue
      return
      end
"ENDOF realft.f"
#=======================================================================
echo reffo.f
cat >reffo.f <<"ENDOF reffo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine reffo(i1,ng,nd,hkl,hklo)
      implicit none
      integer h,hkl,hklo,hlw,hmax,hrmax,hup,i,i1,iecr,ilec,ix1,k,klw,
     & kmax,kprt,krmax,kup,l,llw,lmax,lrmax,lup,m,mult,nd,ng,nra,nrt,
     & ntot,nx,nxyz,ny,nz
      real a11,a21,a22,a31,a32,a33,demax,demin,drmax,drmin,rbid1,sqh,
     & sqhmax,sqhsup
      dimension hkl(ng),hklo(nd)
      common/dfft/ hlw,hup,klw,kup,llw,lup,nra,nxyz
      common/grid/ hmax,kmax,lmax,nx,ny,nz
      common/ioprg/ ilec,iecr,kprt
      common/reso/ drmax,drmin,demax,demin,rbid1
      common/star/ a11,a21,a22,a31,a32,a33
      call indexm(drmin,hrmax,krmax,lrmax)
      hlw=0
      hup=0
      klw=0
      kup=0
      llw=0
      lup=0
      nra=0
      ntot=0
      nrt=0
      sqhmax=(1/drmin)**2
      sqhsup=0.
      rewind(i1)
10    read(i1,end=30) m,hklo
      if(m.gt.nd) go to 901
      ntot=ntot+m
      do 20 i=1,m
      call unpac5(h,k,l,mult,ix1,hklo(i))
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.sqhmax) go to 20
      nrt=nrt+mult
      if(h.lt.hlw) hlw=h
      if(h.gt.hup) hup=h
      if(k.lt.klw) klw=k
      if(k.gt.kup) kup=k
      if(l.lt.llw) llw=l
      if(l.gt.lup) lup=l
      if(sqh.gt.sqhsup) sqhsup=sqh
      nra=nra+1
      if(nra.gt.ng) go to 902
      hkl(nra)=hklo(i)
20    continue
      go to 10
30    if(nra.eq.0) go to 903
      nrt=nrt/2+mod(nrt,2)
      demin=sqrt(1/sqhsup)
      if(kprt.ne.0) write(iecr,2010) nra,ntot,nrt
      if(kprt.ne.0) write(iecr,2020) drmin,hrmax,krmax,lrmax
      if(kprt.ne.0) write(iecr,2030) demin,hlw,hup,klw,kup,llw,lup
      return
901   write(iecr,3010) m,nd
      stop
902   write(iecr,3020) ng
      stop
903   write(iecr,3030)
      stop
2010  format(/i10,' coefficients used out of',i10,' on the input file'/
     . ' number of reflections when extended to p1:',i10)
2020  format(' requested resolution =',f10.3/
     . ' maximal indices according to requested resolution =',3i5)
2030  format(' data resolution =',f10.3/' maximal indices in data'/
     . ' hmin, hmax =',2i5,', kmin, kmax =',2i5,', lmin, lmax =',2i5)
3010  format('stop >> reffo << incompatible dims. m, nd =',2i10)
3020  format('stop >> reffo << nb. of reflections exceeds',i10)
3030  format('stop >> reffo << no reflection selected')
      end
"ENDOF reffo.f"
#=======================================================================
echo rpcftk.f
cat >rpcftk.f <<"ENDOF rpcftk.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rpcftk(x,y,n,m,dim,r,p)
      implicit none
      integer d1,d2,d3,d4,d5,del,dim,i,i0,i1,i2,imax,j,m,m1,mmp,mp,ms2,
     & n,ns,p,pm,pp,q,r,u,v
      real a,aa,angle,b,bb,c,ia,ib,is,iu,ktes,ra,rb,rs,ru,s,t,twopi,x,
     & xt,y,yt
      logical fold,zero
      dimension a(18),aa(9,9),b(18),bb(9,9),c(18),dim(*),ia(9),ib(9),
     & ra(9),rb(9),s(18),x(r,*),y(r,*)
      common/fftkte/ twopi,ktes(7)
      d1=dim(1)
      d2=dim(2)
      d3=dim(3)
      d4=dim(4)-1
      d5=dim(5)
      ns=n*d2
      ms2=m/2+1
      imax=ms2
      if(2*ms2.lt.m+2) imax=imax+1
      mp=m*p
      mmp=mp*d2
      pp=p/2
      pm=p-1
      m1=0
      do 10 u=1,pp
      m1=m1+1
      angle=m1*twopi/p
      q=p-u
      a(u)=cos(angle)
      b(u)=sin(angle)
      a(q)=a(u)
      b(q)=-b(u)
10    continue
      do 30 u=1,pp
      do 20 v=1,pp
      q=u*v-((u*v)/p)*p
      aa(v,u)=a(q)
      bb(v,u)=b(q)
20    continue
30    continue
      m1=-1
      do 160 i=1,ms2
      fold=i.gt.1.and.i.lt.imax
      del=(i-1)*d2+1
      m1=m1+1
      angle=m1*twopi/mp
      zero=angle.eq.0.
      if(zero) go to 70
      c(1)=cos(angle)
      s(1)=sin(angle)
      do 40 u=2,pm
      c(u)=c(u-1)*c(1)-s(u-1)*s(1)
      s(u)=s(u-1)*c(1)+c(u-1)*s(1)
40    continue
      go to 70
50    fold=.false.
      del=(m+1-i)*d2+1
      do 60 u=1,pm
      t=c(u)*a(u)+s(u)*b(u)
      s(u)=-s(u)*a(u)+c(u)*b(u)
      c(u)=t
60    continue
70    do 150 i0=del,ns,mmp
      do 140 i1=i0,d1,d3
      i2=i1+d4
      do 130 j=i1,i2,d5
      xt=x(j,1)
      yt=y(j,1)
      rs=x(j,2)+x(j,p)
      is=y(j,2)+y(j,p)
      ru=x(j,2)-x(j,p)
      iu=y(j,2)-y(j,p)
      do 80 u=1,pp
      ra(u)=xt+rs*aa(u,1)
      ia(u)=yt+is*aa(u,1)
      rb(u)=ru*bb(u,1)
      ib(u)=iu*bb(u,1)
80    continue
      xt=xt+rs
      yt=yt+is
      do 100 u=2,pp
      q=p-u
      rs=x(j,u+1)+x(j,q+1)
      is=y(j,u+1)+y(j,q+1)
      ru=x(j,u+1)-x(j,q+1)
      iu=y(j,u+1)-y(j,q+1)
      xt=xt+rs
      yt=yt+is
      do 90 v=1,pp
      ra(v)=ra(v)+rs*aa(v,u)
      ia(v)=ia(v)+is*aa(v,u)
      rb(v)=rb(v)+ru*bb(v,u)
      ib(v)=ib(v)+iu*bb(v,u)
90    continue
100   continue
      x(j,1)=xt
      y(j,1)=yt
      do 120 u=1,pp
      q=p-u
      if(zero) go to 110
      xt=ra(u)+ib(u)
      yt=ia(u)-rb(u)
      x(j,u+1)=xt*c(u)+yt*s(u)
      y(j,u+1)=yt*c(u)-xt*s(u)
      xt=ra(u)-ib(u)
      yt=ia(u)+rb(u)
      x(j,q+1)=xt*c(q)+yt*s(q)
      y(j,q+1)=yt*c(q)-xt*s(q)
      go to 120
110   x(j,u+1)=ra(u)+ib(u)
      y(j,u+1)=ia(u)-rb(u)
      x(j,q+1)=ra(u)-ib(u)
      y(j,q+1)=ia(u)+rb(u)
120   continue
130   continue
140   continue
150   continue
      if(fold) go to 50
160   continue
      return
      end
"ENDOF rpcftk.f"
#=======================================================================
echo rz1.f
cat >rz1.f <<"ENDOF rz1.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rz1(nx,ny,pz,zs,rr)
      implicit none
      integer i1,ij,k,nx,ny,nz,o1,pz,zs
      real a,alpha,b,beta,c,gamma,rbid1,rr
      dimension rr(nx*ny,pz)
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/tapes/ i1,o1
         if(zs.eq.0) then
      rewind(i1)
      read(i1) nx,ny,nz,a,b,c,alpha,beta,gamma
         endif
      do 10 k=1,pz
10    read(i1) (rr(ij,k),ij=1,nx*ny)
      return
      end
"ENDOF rz1.f"
#=======================================================================
echo setpak.f
cat >setpak.f <<"ENDOF setpak.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine setpak
      implicit none
      integer hm,ibid1,id,iecr,ilec,km,kprt,lm,maxint,neq,nh,nk,nl,nm,
     & nr,nts
      real a,b,c,rbid1,rbid2,xlam
      common/cell/ a,b,c,rbid1(19)
      common/ioprg/ ilec,iecr,kprt
      common/paco/ hm,km,lm,nh,nk,nl,nm,nr
      common/simt/ rbid2(153),ibid1(432),neq,nts
      maxint=(2**30)+(2**30-1)
      id=maxint/((2*neq+1)*13)
      xlam=(id/(a*b*c))**(1./3)
      hm=xlam*a/2-1
      km=xlam*b/2-1
      lm=xlam*c/2-1
      nh=xlam*a
      nk=xlam*b
      nl=xlam*c
      nm=2*neq+1
      nr=13
      write(iecr,2010) 2/xlam
      return
2010  format(/' setpak. maximal resolution allowed =',f10.6)
      end
"ENDOF setpak.f"
#=======================================================================
echo srfp.f
cat >srfp.f <<"ENDOF srfp.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine srfp(n,pmax,twogrp,factor,psym,sym,unsym)
      implicit none
      integer f,factor,iecr,ilec,j,jj,kprt,m,n,nest,p,pmax,pp,psym,ptwo,
     & q,qq,r,sym,twogrp,unsym
      dimension factor(*),pp(14),qq(7),sym(*),unsym(*)
      common/ioprg/ ilec,iecr,kprt
      nest=14
      m=n
      psym=1
      f=2
      p=0
      q=0
10    if(m.le.1) go to 50
      do 20 j=f,pmax
      if(m.eq.(m/j)*j) go to 30
20    continue
      go to 901
30    if(2*p+q.ge.nest) go to 902
      f=j
      m=m/f
      if(m.eq.(m/f)*f) go to 40
      q=q+1
      qq(q)=f
      go to 10
40    m=m/f
      p=p+1
      pp(p)=f
      psym=psym*f
      go to 10
50    r=1
      if(q.eq.0) r=0
      if(p.lt.1) go to 70
      do 60 j=1,p
      jj=p+1-j
      sym(j)=pp(jj)
      factor(j)=pp(jj)
      jj=p+q+j
      factor(jj)=pp(j)
      jj=p+r+j
      sym(jj)=pp(j)
60    continue
70    if(q.lt.1) go to 90
      do 80 j=1,q
      jj=p+j
      unsym(j)=qq(j)
      factor(jj)=qq(j)
80    continue
      sym(p+1)=n/psym**2
90    jj=2*p+q
      factor(jj+1)=0
      ptwo=1
      j=0
100   j=j+1
      if(factor(j).eq.0) go to 120
      if(factor(j).ne.2) go to 100
      ptwo=ptwo*2
      factor(j)=1
      if(ptwo.ge.twogrp) go to 110
      if(factor(j+1).eq.2) go to 100
110   factor(j)=ptwo
      ptwo=1
      go to 100
120   if(p.eq.0) r=0
      jj=2*p+r
      sym(jj+1)=0
      if(q.le.1) q=0
      unsym(q+1)=0
      return
901   write(iecr,3010) pmax,n
      stop
902   write(iecr,3020) nest,n
      stop
3010  format('stop >> srfp << largest factor exceeds',i5,', n =',i5)
3020  format('stop >> srfp << factor count exceeds',i5,', n =',i5)
      end
"ENDOF srfp.f"
#=======================================================================
echo stfndo.f
cat >stfndo.f <<"ENDOF stfndo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine stfndo(nd,mi,mr,mc,ii,rr,cc)
      implicit none
      integer ibid1,iecr,ii,ilec,j2,j3,k2,kprt,krep,mc,mi,mr,nd,nra,
     & nxyz,ufc,ump,ure
      real a,alpha,b,beta,bfac,c,drmax,drmin,dtor,fooo,gamma,pi,rbid1,
     & rbid2,rr,rtod,twopi,zn
      complex cc
      character card*80,tipo*3,title*1
      external rz1,phkl1
      dimension cc(mc),ii(mi),rr(mr),title(80)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/dfft/ ibid1(6),nra,nxyz
      common/fozo/ fooo,zn,bfac,krep
      common/ioprg/ ilec,iecr,kprt
      common/reso/ drmax,drmin,rbid2(3)
      common/tapes/ ump,ufc
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      read(ilec,'(a)') card
      ump=1
      ufc=2
      ure=3
      call abra(ump,'u','u',0)
      read(ilec,'(80a1)') title
      write(iecr,2010) title
      read(ilec,*) a,b,c,alpha,beta,gamma
      call celda
      call lecsim
      call setpak
      read(ilec,*) drmax,drmin
      read(ilec,*) bfac
      read(ilec,'(a)') tipo
      call abra(ure,'u','u',0)
      call datamf(ump,ure,nd,mi,mr,mc,ii(1))
      call xffth(rz1,phkl1,ii(1),rr(1),cc(1))
      j2=1+nra
      j3=1+nra+nd
      k2=1+nd
         if(tipo.eq.'hkl') then
      call abra(ufc,'f','u',0)
      call gendath(ufc,nra,nd,ii(1),ii(j2),ii(j3),rr(1),rr(k2),cc(1))
         endif
      return
2010  format(/' ****** programme stfing ******'/
     . ' ****** written by don jorge navaza ******'/80a1)
      end
"ENDOF stfndo.f"
#=======================================================================
echo symcar.f
cat >symcar.f <<"ENDOF symcar.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine symcar
      implicit none
      integer i,iecr,ifound,ilec,ip,isl,it,j,k,kmax,kprt,m,mss,mssa,neq,
     & nfi,np,nts,num
      real a,t,tss,tssa,tts
      character col*1,iblank*1,ich*1,icomma*1,ie*1,iminus*1,inum*1,
     & iplus*1,ipoint*1,is*1,islash*1,istar*1,ix*1,iy*1,iz*1
      dimension col(80),inum(10),mssa(3,3),num(10),tssa(3)
      common/ioprg/ ilec,iecr,kprt
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      data is,ie,ix,iy,iz,iplus,iminus,islash,ipoint,icomma,istar,
     & iblank/'s','e','x','y','z','+','-','/','.',',','*',' '/,
     & inum/'1','2','3','4','5','6','7','8','9','0'/,
     & num/1,2,3,4,5,6,7,8,9,0/
      kmax=80
      neq=0
      nts=0
10    read(ilec,'(80a1)') col
      k=0
20    nfi=1
      do 40 j=1,3
      tssa(j)=0.
      do 30 i=1,3
      mssa(i,j)=0
30    continue
40    continue
50    m=1
      t=0.
      isl=0
      ip=0
      np=0
      ifound=0
60    k=k+1
      if(k.gt.kmax) go to 190
      ich=col(k)
      if(ich.eq.iblank) go to 60
      if(ich.eq.icomma.or.ich.eq.istar) go to 190
         if(ich.eq.is.or.ich.eq.ie) then
      if(nfi.eq.1.and.ifound.eq.0) go to 220
      go to 901
         endif
      ifound=1
      if(ich.eq.ix) go to 110
      if(ich.eq.iy) go to 120
      if(ich.eq.iz) go to 130
      if(ich.eq.iplus) go to 150
      if(ich.eq.iminus) go to 160
      if(ich.eq.islash) go to 170
      if(ich.eq.ipoint) go to 180
      do 70 i=1,10
      if(ich.eq.inum(i)) go to 80
70    continue
      go to 901
80    a=num(i)
      if(isl.eq.1) go to 90
      if(ip.eq.1) go to 100
      t=a*m
      go to 60
90    t=t/a
      go to 60
100   np=np+1
      t=t+a/10**np
      go to 60
110   j=1
      go to 140
120   j=2
      go to 140
130   j=3
140   mssa(nfi,j)=m
      m=1
      go to 60
150   m=1
      go to 60
160   m=-1
      go to 60
170   isl=1
      go to 60
180   ip=1
      go to 60
190   tssa(nfi)=t
         if(ifound.eq.0.and.nfi.eq.1) then
      if(kmax.le.k) go to 10
      if(kmax.gt.k) go to 60
         endif
         if(ifound.eq.1.and.nfi.eq.3) then
      it=0
       do j=1,3
        do i=1,3
      it=it+abs(mssa(i,j))
        enddo
       enddo
            if(it.ne.0) then
      neq=neq+1
      if(neq.gt.48) go to 901
      do 210 j=1,3
      tss(j,neq)=tssa(j)
      do 200 i=1,3
      mss(i,j,neq)=mssa(i,j)
200   continue
210   continue
            else
      nts=nts+1
       do j=1,3
      tts(j,nts)=tssa(j)
       enddo
            endif
      if(kmax.le.k) go to 10
      if(kmax.gt.k) go to 20
         endif
         if(k.lt.kmax.and.ifound.eq.1.and.nfi.lt.3) then
      nfi=nfi+1
      go to 50
         endif
      go to 901
220   do 240 j=1,3
      if(mss(j,j,1).ne.1) go to 901
      do 230 i=1,3
         if(i.ne.j) then
      if(mss(i,j,1).ne.0) go to 901
         endif
230   continue
240   continue
      return
901   write(iecr,3010)
      stop
3010  format('stop >> symcar << wrong or out of order symmetry card')
      end
"ENDOF symcar.f"
#=======================================================================
echo sympac.f
cat >sympac.f <<"ENDOF sympac.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine sympac(h,k,l,index,deja,exts)
      implicit none
      integer h,hh,iind,index,ir,it,k,kk,l,ll,mss,n,neq,nts
      real pr,tss,tts
      logical deja,exts
      common/simt/ tss(3,48),tts(3,3),mss(3,3,48),neq,nts
      deja=.false.
      exts=.false.
       do it=1,nts
      pr=mod(h*tts(1,it)+k*tts(2,it)+l*tts(3,it),1.)
      ir=mod(12+nint(12*pr),12)
      if(ir.ne.0) exts=.true.
       enddo
      do 10 n=1,neq
      hh=h*mss(1,1,n)+k*mss(2,1,n)+l*mss(3,1,n)
      kk=h*mss(1,2,n)+k*mss(2,2,n)+l*mss(3,2,n)
      ll=h*mss(1,3,n)+k*mss(2,3,n)+l*mss(3,3,n)
         if(hh.eq.h.and.kk.eq.k.and.ll.eq.l) then
      pr=mod(h*tss(1,n)+k*tss(2,n)+l*tss(3,n),1.)
      ir=mod(12+nint(12*pr),12)
      if(ir.ne.0) exts=.true.
         endif
c pacote
         if(hh.lt.0.or.(hh.eq.0.and.(ll.gt.0.or.(ll.eq.0.and.kk.gt.0))))
     . then
      hh=-hh
      kk=-kk
      ll=-ll
         endif
      call pac3(hh,kk,ll,iind)
      if(iind.le.index) go to 20
10    continue
      return
20    deja=.true.
      return
      end
"ENDOF sympac.f"
#=======================================================================
echo unpac5.f
cat >unpac5.f <<"ENDOF unpac5.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine unpac5(ih,ik,il,im,ir,ind5)
      implicit none
      integer hm,ih,ik,il,im,ind1,ind2,ind3,ind4,ind5,ir,km,lm,nh,nk,nl,
     & nm,nr
      common/paco/ hm,km,lm,nh,nk,nl,nm,nr
      ind4=ind5/nr
      ind3=ind4/nm
      ind2=ind3/nh
      ind1=ind2/nk
      il=ind1-lm
      ik=ind2-ind1*nk-km
      ih=ind3-ind2*nh-hm
      im=ind4-ind3*nm
      ir=ind5-ind4*nr
      return
      end
"ENDOF unpac5.f"
#=======================================================================
echo xffth.f
cat >xffth.f <<"ENDOF xffth.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine xffth(rxyz,phkl,ii,rr,cc)
      implicit none
      integer dim,hlw,hmax,hs,hst,hup,ii,klw,kmax,kup,llw,lmax,lup,nh,
     & nk,nra,nwds,nwdsm,nx,nx2,nxyz,ny,nz,ph,pz,pzt,td,zs
      real ktes,rr,twopi
      double precision dang
      complex cc
      logical skip
      external rxyz,phkl
      dimension cc(*),dim(5),ii(*),rr(*)
      common/dfft/ hlw,hup,klw,kup,llw,lup,nra,nxyz
      common/dfftd/ ph,pz,td,nwdsm
      common/fftkte/ twopi,ktes(7)
      common/grid/ hmax,kmax,lmax,nx,ny,nz
      dang=atan2(1.d0,1.d0)
      twopi=dang*8.d0
      ktes(1)=-0.5d0
      ktes(2)=cos(dang*2.d0/3.d0)
      ktes(3)=cos(dang*8.d0/5.d0)
      ktes(4)=cos(dang*2.d0/5.d0)
      ktes(5)=-cos(dang*4.d0/5.d0)
      ktes(6)=cos(dang*6.d0/5.d0)
      ktes(7)=cos(dang)
      nx2=nx/2
      nh=hup-hlw+1
      nk=kup-klw+1
      hs=0
      zs=0
      pzt=pz
      skip=.true.
         if(ph.lt.nh.or.pz.lt.nz) then
      skip=.false.
      nwds=2*ph*nk*pz
      call abra(td,'d','u',nwds)
         endif
10    if(zs+pzt.gt.nz) pzt=nz-zs
      call rxyz(nx,ny,pzt,zs,rr(1))
      dim(1)=nx*ny*pzt
      dim(2)=2
      dim(3)=dim(1)
      dim(4)=dim(1)
      dim(5)=nx
      call realft(nx,dim,rr(1),rr(2))
      call xtoh(nx2,ny,pzt,nh,rr(1),rr(1))
      dim(1)=2*nh*ny*pzt
      dim(2)=2*nh
      dim(3)=2*nh*ny
      dim(4)=dim(2)
      dim(5)=2
      call cmplft(ny,dim,rr(1),rr(2))
      call ytok(nh,ny,pzt,nk,rr(1),rr(1))
      if(.not.skip) call hout(td,nh,nk,pzt,ph,zs,rr(1))
      zs=zs+pzt
      if(zs.lt.nz) go to 10
20    if(hs+ph.gt.nh) ph=nh-hs
      hst=hs+hlw
      if(.not.skip) call zin(td,ph,nk,nz,pz,hs,nh,rr(1))
      dim(1)=2*ph*nk*nz
      dim(2)=2*ph*nk
      dim(3)=2*ph*nk*nz
      dim(4)=dim(2)
      dim(5)=2
      call cmplft(nz,dim,rr(1),rr(2))
      call phkl(nra,ph,nk,nz,hst,ii(1),rr(1),cc(1))
      hs=hs+ph
      if(hs.lt.nh) go to 20
      close(unit=td)
      return
      end
"ENDOF xffth.f"
#=======================================================================
echo xtoh.f
cat >xtoh.f <<"ENDOF xtoh.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine xtoh(nx2,ny,nz,nh,ww,vv)
      implicit none
      integer ih,iy,iz,nh,nx2,ny,nz
      complex vv,ww
      dimension vv(nh,ny,nz),ww(nx2,ny,nz)
      do 10 iz=1,nz
      do 10 iy=1,ny
      do 10 ih=1,nh
      vv(ih,iy,iz)=ww(ih,iy,iz)
10    continue
      return
      end
"ENDOF xtoh.f"
#=======================================================================
echo ytok.f
cat >ytok.f <<"ENDOF ytok.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine ytok(nh,ny,nz,nk,ww,vv)
      implicit none
      integer hlw,hup,ih,ik,iz,klw,kup,llw,lup,nh,nk,nra,nxyz,ny,nz
      complex vv,ww
      dimension vv(nh,nk,nz),ww(nh,ny,nz)
      common/dfft/ hlw,hup,klw,kup,llw,lup,nra,nxyz
      do 50 iz=1,nz
      do 20 ik=1,kup+1
      do 10 ih=1,nh
      vv(ih,ik,iz)=ww(ih,ik,iz)
10    continue
20    continue
      do 40 ik=klw+1,0
      do 30 ih=1,nh
      vv(ih,nk+ik,iz)=ww(ih,ny+ik,iz)
30    continue
40    continue
50    continue
      return
      end
"ENDOF ytok.f"
#=======================================================================
echo zin.f
cat >zin.f <<"ENDOF zin.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine zin(td,ph,nk,nz,pz,hs,nh,ww)
      implicit none
      integer hrec,hs,ihk,irec,iz,nh,nk,nz,ph,pht,pz,td,zf,zs
      complex ww
      dimension ww(ph*nk,nz)
      save hrec,pht
         if(hs.eq.0) then
      hrec=(nh-1)/ph+1
      pht=ph
         endif
      zf=0
      irec=hs/pht+1
10    zs=zf+1
      zf=zf+pz
      if(zf.gt.nz) zf=nz
      read(td,rec=irec) ((ww(ihk,iz),ihk=1,ph*nk),iz=zs,zf)
      irec=irec+hrec
      if(zf.lt.nz) go to 10
      return
      end
"ENDOF zin.f"
"ENDOF stfing.for"
#=======================================================================
echo util.for
cat >util.for <<"ENDOF util.for"
# to recover individual items, csh this file
#=======================================================================
echo cn.f
cat >cn.f <<"ENDOF cn.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine cn
      implicit none
      integer N,S,i,iecr,ilec,j,length,o1
      double precision dtor,pi,rtod,twopi
      character axe*1,card*80
      external length
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      data o1/1/
      write(iecr,'(a)') ' enter n-fold order and axe [X|Y|Z]'
      read(ilec,*) N,axe
      open(unit=o1,file='SYM',form='formatted',status='unknown')
       do i=1,80
      card(i:i)=' '
       enddo
      card(65:65)='#'
      S=0
      do 10 j=0,N-1
      card(66:70)='     '
         if(axe.eq.'Z') then
      write(card(1:60),'(6f10.3)') j*360.d0/N,0.,0.,0.,0.,0.
         else if(axe.eq.'Y') then
      write(card(1:60),'(6f10.3)') 0.,j*360.d0/N,0.,0.,0.,0.
         else if(axe.eq.'X') then
      write(card(1:60),'(6f10.3)') -90.,j*360.d0/N,90.,0.,0.,0.
         endif
      S=S+1
         if(S.lt.10) then
      write(card(66:66),'(i1)') S
         else if(S.lt.100) then
      write(card(66:67),'(i2)') S
         else
      write(card(66:68),'(i3)') S
         endif
      write(o1,'(a)') card(1:length(card))
10    continue
      return
      end
"ENDOF cn.f"
#=======================================================================
echo compact.f
cat >compact.f <<"ENDOF compact.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine compact(card)
      implicit none
      integer i,j,length
      character card*80
      logical blanco,white
      external length
      blanco=card(1:1).eq.' '
      j=0
      do 10 i=1,length(card)
      white=card(i:i).eq.' '
      if(white.and.blanco) go to 10
         if(white) then
      blanco=.true.
         else
      blanco=.false.
         endif
      j=j+1
      card(j:j)=card(i:i)
10    continue
       do i=j+1,length(card)
      card(i:i)=' '
       enddo
      return
      end
"ENDOF compact.f"
#=======================================================================
echo compakt.f
cat >compakt.f <<"ENDOF compakt.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine compakt(card,nfield)
      implicit none
      integer i,j,lungo,nfield
      character card*1
      logical blanco,white
      external lungo
      dimension card(nfield)
      blanco=card(1).eq.' '
      j=0
       do i=1,lungo(card,nfield)
      white=card(i).eq.' '
         if((.not.white).or.(.not.blanco)) then
            if(white) then
      blanco=.true.
            else
      blanco=.false.
            endif
      j=j+1
      card(j)=card(i)
         endif
       enddo
       do i=j+1,lungo(card,nfield)
      card(i)=' '
       enddo
      return
      end
"ENDOF compakt.f"
#=======================================================================
echo det3.f
cat >det3.f <<"ENDOF det3.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine det3(r,d)
      implicit none
      double precision a,b,d,r
      dimension r(3,3)
      a=r(1,1)*r(2,2)*r(3,3)+r(1,2)*r(2,3)*r(3,1)+r(3,2)*r(2,1)*r(1,3)
      b=r(1,3)*r(2,2)*r(3,1)+r(2,1)*r(1,2)*r(3,3)+r(2,3)*r(3,2)*r(1,1)
      d=a-b
      return
      end
"ENDOF det3.f"
#=======================================================================
echo dn.f
cat >dn.f <<"ENDOF dn.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine dn
      implicit none
      integer N,S,i,iecr,ilec,j,length,o1
      double precision alpha,beta,dang,dtor,gamma,pi,rotx,rtod,twopi,u
      character card*80
      external length
      dimension rotx(3,3),u(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      data o1/1/
      write(iecr,'(a)') ' enter order of n-fold symmetry'
      read(ilec,*) N
      open(unit=o1,file='SYM',form='formatted',status='unknown')
       do i=1,80
      card(i:i)=' '
       enddo
      card(65:65)='#'
      S=0
      do 10 j=0,N-1
      card(66:70)='     '
      write(card(1:60),'(6f10.3)') j*360.d0/N,0.,0.,0.,0.,0.
      S=S+1
         if(S.lt.10) then
      write(card(66:66),'(i1)') S
         else if(S.lt.100) then
      write(card(66:67),'(i2)') S
         else
      write(card(66:68),'(i3)') S
         endif
      write(o1,'(a)') card(1:length(card))
10    continue
      do 20 j=0,N-1
      dang=j*pi/N
      u(1)=cos(dang)
      u(2)=sin(dang)
      u(3)=0.d0
      call rmxp(pi,u,rotx)
      call rmx2e(rotx,alpha,beta,gamma)
      alpha=alpha*rtod
      beta=beta*rtod
      gamma=gamma*rtod
      card(66:70)='     '
      write(card(1:60),'(6f10.3)') alpha,beta,gamma,0.,0.,0.
      S=S+1
         if(S.lt.10) then
      write(card(66:66),'(i1)') S
         else if(S.lt.100) then
      write(card(66:67),'(i2)') S
         else
      write(card(66:68),'(i3)') S
         endif
      write(o1,'(a)') card(1:length(card))
20    continue
      return
      end
"ENDOF dn.f"
#=======================================================================
echo epslon.f
cat >epslon.f <<"ENDOF epslon.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function epslon(x)
      implicit none
      double precision a,b,c,eps,epslon,x
      a=4.0d0/3.0d0
10    b=a-1.0d0
      c=b+b+b
      eps=abs(c-1.0d0)
      if(eps.eq.0.0d0) go to 10
      epslon=eps*abs(x)
      return
      end
"ENDOF epslon.f"
#=======================================================================
echo euler.f
cat >euler.f <<"ENDOF euler.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
cjn eje 5 || Z , 2 || Y , 3 NX
      subroutine euler(angles,ns)
      implicit none
      integer alpha,beta,gamma,i,ns
      double precision angles,pio5,val
      dimension alpha(60),angles(3,60),beta(60),gamma(60),val(4)
      data alpha/
     & 0,0,0,1,5,5,9,9,3,7,1,3,7,0,0,2,4,6,8,0,2,8,0,4,6,1,3,7,9,3,
     & 5,5,7,9,1,0,4,6,0,2,6,4,8,8,2,3,7,1,9,5,2,8,4,6,0,0,0,0,0,0/
      data beta/
     & 1,1,1,2,2,2,2,2,2,2,2,2,2,1,1,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,
     & 2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,3,3,3,3,3,4,4,4,4,4/
      data gamma/
     & 0,2,8,0,4,6,0,2,6,4,8,8,2,4,6,1,3,7,9,3,5,5,7,9,1,2,4,6,8,0,
     & 2,8,0,4,6,1,5,5,9,9,3,7,1,3,7,2,8,4,6,0,3,7,1,9,5,0,2,8,4,6/
      val(1)=0.d0
      val(2)=acos(1.d0/sqrt(5.d0))
      val(3)=atan2(1.d0,1.d0)*4.d0-acos(1.d0/sqrt(5.d0))
      val(4)=atan2(1.d0,1.d0)*4.d0
      pio5=atan2(1.d0,1.d0)*4.d0/5.d0
       do i=1,ns
      angles(1,i)=alpha(i)*pio5
      angles(2,i)=val(beta(i))
      angles(3,i)=gamma(i)*pio5
       enddo
      return
      end
"ENDOF euler.f"
#=======================================================================
echo eulero.f
cat >eulero.f <<"ENDOF eulero.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
cjn eje 4 || Z , 4 || Y , 4 || X
      subroutine eulero(angles,ns)
      implicit none
      integer alpha,beta,gamma,i,ns
      double precision angles,pio2
      dimension alpha(24),angles(3,24),beta(24),gamma(24)
      data alpha/0,1,2,3,0,0,2,3,2,1,0,1,3,2,3,0,2,1,1,3,0,2,3,1/
      data beta /0,0,0,0,1,2,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2/
      data gamma/0,0,0,0,0,0,2,1,0,3,1,2,0,3,2,3,1,0,1,3,2,0,0,0/
      pio2=atan2(1.d0,1.d0)*2.d0
       do i=1,ns
      angles(1,i)=alpha(i)*pio2
      angles(2,i)=beta(i)*pio2
      angles(3,i)=gamma(i)*pio2
       enddo
      return
      end
"ENDOF eulero.f"
#=======================================================================
echo eulert.f
cat >eulert.f <<"ENDOF eulert.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
cjn eje 2 || Z , 2 || Y , 2 || X
      subroutine eulert(angles,ns)
      implicit none
      integer alpha,beta,gamma,i,ns
      double precision angles,pio2
      dimension alpha(12),angles(3,12),beta(12),gamma(12)
      data alpha/0,2,0,2,1,3,0,2,1,3,0,2/
      data beta /0,0,2,2,1,1,1,1,1,1,1,1/
      data gamma/0,0,0,0,0,0,1,1,2,2,3,3/
      pio2=atan2(1.d0,1.d0)*2.d0
       do i=1,ns
      angles(1,i)=alpha(i)*pio2
      angles(2,i)=beta(i)*pio2
      angles(3,i)=gamma(i)*pio2
       enddo
      return
      end
"ENDOF eulert.f"
#=======================================================================
echo helix.f
cat >helix.f <<"ENDOF helix.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine helix
      implicit none
      integer A,B,C,D,M,N,S,T,U,i,iecr,ilec,j,k,length,o1
      double precision det,dtor,norme,pi,rtod,scale,twopi,u1,u2,w1,w2,x
      character card*80
      dimension u1(2),u2(2),x(2)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      data o1/1/
1     write(iecr,'(a)') ' enter the helix parameters (c,T,U) + N:'
      read(ilec,*) scale,T,U,N
      u1(1)=T/real(U)
      u1(2)=1/real(U)
      i=abs(U/T)
      u2(1)=i*u1(1)-sign(1,T)
      u2(2)=i*u1(2)
      det=u1(1)*u2(2)-u1(2)*u2(1)
         if(det.eq.0.0) then
      write(iecr,'(/20x,a)') ' >>> incorrect base vectors <<<'
      go to 1
         else if(det.lt.0.0) then
      write(iecr,'(20x,a)') ' >>> vectors permuted <<<'
      w1=u1(1)
      w2=u1(2)
      u1(1)=u2(1)
      u1(2)=u2(2)
      u2(1)=w1
      u2(2)=w2
         endif
      write(iecr,'(a)') ' base vectors ='
      write(iecr,'(a,f15.5,a,f15.5,a/a,f15.5,a,f15.5,a)')
     . ' u1 , u2 :',u1(1)*360,' degrees , ',u1(2)*scale, ' Angstroms',
     . ' v1 , v2 :',u2(1)*360,' degrees , ',u2(2)*scale, ' Angstroms'
      det=u1(1)*u2(2)-u1(2)*u2(1)
      A=nint(u2(2)/det)
      B=nint(-u1(2)/det)
      write(iecr,'(a/a/a,f10.5/a,f10.5/a,i5,a,i5)')
     . ' COEFFS that produce an ANGULAR repeat =',
     . ' >>> ZERO CHECK <<<',
     . ' A * u1 + B * v1 - 1 =',A*u1(1)+B*u2(1)-1,
     . ' A * u2 + B * v2     =',A*u1(2)+B*u2(2),
     . ' A =',A,' , B =',B
         if(B.eq.0) then
      write(iecr,'(/20x,a)') ' >>> null B <<<'
      go to 1
         endif
c------
      i=A
      j=B
2        if(mod(i,j).ne.0) then
      k=mod(i,j)
      i=j
      j=k
      go to 2
         endif
      M=j
c------
       do i=1,A,sign(1,A)
         if(mod(M+B*i,A).eq.0) then
      C=i
      D=(M+B*C)/A
         endif
       enddo
      k=nint(1.e9)
      norme=1.e10
       do i=-50,50
      w1=u1(1)*(C+A*i)+u2(1)*(D+B*i)
         if(abs(w1).le.norme) then
      k=i
      norme=abs(w1)
         endif
       enddo
      C=C+A*k
      D=D+B*k
         if(C*u1(2)+D*u2(2).lt.0.0) then
      C=-C
      D=-D
      M=-M
         endif
c------
      write(iecr,'(a,i5)') ' GREATEST common divisor: M =',M
      x(1)=C*u1(1)+D*u2(1)
      x(2)=C*u1(2)+D*u2(2)
      write(iecr,'(a/a,f15.5,a/a,f15.5,a/a,i5,a,i5)')
     . ' ELEMENTARY helix =',
     . ' x1 = C * u1 + D * v1 =',x(1)*360,' degrees',
     . ' x2 = C * u2 + D * v2 =',x(2)*scale,' Angstroms',
     . ' C =',C,' , D =',D
      write(iecr,'(a/a,i5)') ' >>> ZERO CHECK <<<',
     . ' A * D - B * C - M =',A*D-B*C-M
      write(iecr,'(a,2f15.5)') ' ELEMENTARY helix =',x(1)*360,x(2)*scale
      open(unit=o1,file='SYM',form='formatted',status='unknown')
       do i=1,80
      card(i:i)=' '
       enddo
      card(65:65)='#'
      S=0
      do 10 i=0,2*U
      w1=i*x(1)
      w2=i*x(2)
      w1=mod(1.d0+mod(w1,1.d0),1.d0)
      w2=mod(w2,1.d0)
      if(mod(i,U).eq.0.and.i.ne.0) go to 10
      if(i.gt.U) w2=w2-1.d0
      card(66:70)='     '
      write(card(1:60),'(6f10.3)') w1*360,0.,0.,0.,0.,w2*scale
      S=S+1
         if(S.lt.10) then
      write(card(66:66),'(i1)') S
         else if(S.lt.100) then
      write(card(66:67),'(i2)') S
         else if(S.lt.1000) then
      write(card(66:68),'(i3)') S
         else
      write(card(66:69),'(i4)') S
         endif
      write(o1,'(a)') card(1:length(card))
10    continue
      return
      end
"ENDOF helix.f"
#=======================================================================
echo icosim.f
cat >icosim.f <<"ENDOF icosim.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine icosim(card,ns,angles,rv)
      implicit none
      integer iecr,ilec,ns
      double precision ang2,ang3,angles,dtor,pi,pio2,rtod,rv,twopi,zero
      character card*80
      dimension angles(3,ns),rv(9)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      call euler(angles,ns)
      zero=0.d0
      pio2=pi/2.d0
      ang2=acos(1.d0/sqrt(5.d0))/2.d0
      ang3=acos(sin(pi*3.d0/5.d0)*(1.d0+sqrt(5.d0))/sqrt(15.d0))
      write(iecr,'(6(/a))') ' enter option =',
     . ' 5Z2Y.1|2 5Z2X.1|2 5Y2Z.1|2 5Y2X.1|2 5X2Z.1|2 5X2Y.1|2',
     . ' 3Z2Y.1|2 3Z2X.1|2 3Y2Z.1|2 3Y2X.1|2 3X2Z.1|2 3X2Y.1|2',
     . ' 2Z2Y.1|2',
     . ' (ROTA BTV = 3Z2X.1 ; SFV TBE = 5Y2Z.1 ; IBDV = 2Z2Y.1)',
     . ' or rotation: [p ang cos/x/y/z/] or [e alpha/beta/gamma]'
      read(ilec,'(a)') card
         if(card(1:6).eq.'5Z2Y.1') then
      call rmxe(zero,zero,zero,rv)
         else if(card(1:6).eq.'5Z2Y.2') then
      call rmxe(pi,pi,zero,rv)
         else if(card(1:6).eq.'5Z2X.1') then
      call rmxe(pio2,zero,zero,rv)
         else if(card(1:6).eq.'5Z2X.2') then
      call rmxe(-pio2,zero,zero,rv)
         else if(card(1:6).eq.'5Y2Z.1') then
      call rmxe(pio2,pio2,pio2,rv)
         else if(card(1:6).eq.'5Y2Z.2') then
      call rmxe(pio2,pio2,-pio2,rv)
         else if(card(1:6).eq.'5Y2X.1') then
      call rmxe(pio2,pio2,pi,rv)
         else if(card(1:6).eq.'5Y2X.2') then
      call rmxe(pio2,pio2,zero,rv)
         else if(card(1:6).eq.'5X2Z.1') then
      call rmxe(zero,pio2,pio2,rv)
         else if(card(1:6).eq.'5X2Z.2') then
      call rmxe(zero,pio2,-pio2,rv)
         else if(card(1:6).eq.'5X2Y.1') then
      call rmxe(zero,pio2,pi,rv)
         else if(card(1:6).eq.'5X2Y.2') then
      call rmxe(zero,pio2,zero,rv)
         else if(card(1:6).eq.'3Z2Y.1') then
      call rmxe(pi,ang3,pi,rv)
         else if(card(1:6).eq.'3Z2Y.2') then
      call rmxe(zero,ang3,pi,rv)
         else if(card(1:6).eq.'3Z2X.1') then
      call rmxe(pio2,ang3,pi,rv)
         else if(card(1:6).eq.'3Z2X.2') then
      call rmxe(-pio2,ang3,pi,rv)
         else if(card(1:6).eq.'3Y2Z.1') then
      call rmxe(pio2-ang3,pio2,pio2,rv)
         else if(card(1:6).eq.'3Y2Z.2') then
      call rmxe(-pio2+ang3,pio2,-pio2,rv)
         else if(card(1:6).eq.'3Y2X.1') then
      call rmxe(pio2,pio2+ang3,pi,rv)
         else if(card(1:6).eq.'3Y2X.2') then
      call rmxe(pio2,pio2-ang3,zero,rv)
         else if(card(1:6).eq.'3X2Z.1') then
      call rmxe(pi-ang3,pio2,pio2,rv)
         else if(card(1:6).eq.'3X2Z.2') then
      call rmxe(ang3,pio2,-pio2,rv)
         else if(card(1:6).eq.'3X2Y.1') then
      call rmxe(pi,pio2-ang3,zero,rv)
         else if(card(1:6).eq.'3X2Y.2') then
      call rmxe(zero,pio2-ang3,zero,rv)
         else if(card(1:6).eq.'2Z2Y.1') then
      call rmxe(zero,ang2,zero,rv)
         else if(card(1:6).eq.'2Z2Y.2') then
      call rmxe(pi,pio2-ang2,pi,rv)
         else
      card(1:6)='setang'
         endif
      return
      end
"ENDOF icosim.f"
#=======================================================================
echo length.f
cat >length.f <<"ENDOF length.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function length(card)
      implicit none
      integer i,length
      character card*80
       do i=80,1,-1
      if(card(i:i).ne.' ') go to 10
       enddo
10    length=i
      return
      end
"ENDOF length.f"
#=======================================================================
echo lungo.f
cat >lungo.f <<"ENDOF lungo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function lungo(card,nfield)
      implicit none
      integer i,lungo,nfield
      character card*1
      dimension card(nfield)
       do i=nfield,1,-1
      if(card(i).ne.' ') go to 10
       enddo
10    lungo=i
      return
      end
"ENDOF lungo.f"
#=======================================================================
echo octsim.f
cat >octsim.f <<"ENDOF octsim.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine octsim(card,ns,angles,rv)
      implicit none
      integer iecr,ilec,ns
      double precision ang2,angles,dtor,pi,pio2,pio3,pio4,rtod,rv,twopi,
     & zero
      character card*80
      dimension angles(3,ns),rv(9)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      call eulero(angles,ns)
      zero=0.d0
      pio2=pi/2.d0
      pio3=pi/3.d0
      pio4=pi/4.d0
      ang2=acos(1.d0/sqrt(3.d0))
      write(iecr,'(4(/a))') ' enter option =',
     . ' 4Z4Y 4Z2Y 4Y2Z 4X2Z 3Z2Y.1|2 3Z2X.1|2 3Y2Z.1|2 3Y2X.1|2',
     . ' 3X2Z.1|2 3X2Y.1|2',
     . ' or rotation: [p ang cos/x/y/z/] or [e alpha/beta/gamma]'
      read(ilec,'(a)') card
         if(card(1:4).eq.'4Z4Y') then
      call rmxe(zero,zero,zero,rv)
         else if(card(1:4).eq.'4Z2Y') then
      call rmxe(zero,zero,pio4,rv)
         else if(card(1:4).eq.'4Y2Z') then
      call rmxe(zero,pio4,zero,rv)
         else if(card(1:4).eq.'4X2Z') then
      call rmxe(-pio2,pio4,zero,rv)
         else if(card(1:6).eq.'3Z2Y.1') then
      call rmxe(zero,ang2,3*pio4,rv)
         else if(card(1:6).eq.'3Z2Y.2') then
      call rmxe(pio3,ang2,3*pio4,rv)
         else if(card(1:6).eq.'3Z2X.1') then
      call rmxe(pio2,ang2,3*pio4,rv)
         else if(card(1:6).eq.'3Z2X.2') then
      call rmxe(-pio2,ang2,3*pio4,rv)
         else if(card(1:6).eq.'3Y2Z.1') then
      call rmxe(pio2-ang2,pio2,pio4,rv)
         else if(card(1:6).eq.'3Y2Z.2') then
      call rmxe(ang2,3*pio4,pio2,rv)
         else if(card(1:6).eq.'3Y2X.1') then
      call rmxe(pio2,pio2-ang2,-pio4,rv)
         else if(card(1:6).eq.'3Y2X.2') then
      call rmxe(pio2,pio2+ang2,3*pio4,rv)
         else if(card(1:6).eq.'3X2Z.1') then
      call rmxe(ang2,pio2,5*pio4,rv)
         else if(card(1:6).eq.'3X2Z.2') then
      call rmxe(pio2-ang2,pio4,-pio2,rv)
         else if(card(1:6).eq.'3X2Y.1') then
      call rmxe(zero,pio2-ang2,-pio4,rv)
         else if(card(1:6).eq.'3X2Y.2') then
      call rmxe(zero,pio2+ang2,3*pio4,rv)
         else
      card(1:6)='setang'
         endif
      return
      end
"ENDOF octsim.f"
#=======================================================================
echo p1.f
cat >p1.f <<"ENDOF p1.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine p1
      implicit none
      integer i,length,o1
      character card*80
      external length
      data o1/1/
      open(unit=o1,file='SYM',form='formatted',status='unknown')
       do i=1,80
      card(i:i)=' '
       enddo
      card(65:65)='#'
      write(card(1:60),'(6f10.3)') 0.,0.,0.,0.,0.,0.
      write(card(66:66),'(i1)') 1
      write(o1,'(a)') card(1:length(card))
      return
      end
"ENDOF p1.f"
#=======================================================================
echo platon.f
cat >platon.f <<"ENDOF platon.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine platon(sym)
      implicit none
      integer S,iecr,ilec,ine,inp,is,length,ms,n,ns,o1
      double precision alpha,ang,angles,beta,dtor,gamma,pi,rn,rtod,rv,
     & twopi,un,uv,xhi
      character card*80,sym*3
      external length
      parameter(ms=60)
      dimension angles(3,ms),rn(3,3),rv(9),un(3),uv(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      data o1/1/
c========================
         if(sym.eq.'ico') then
      ns=60
      call icosim(card,ns,angles,rv)
         else if(sym.eq.'oct') then
      ns=24
      call octsim(card,ns,angles,rv)
         else if(sym.eq.'tet') then
      ns=12
      call tetsim(card,ns,angles,rv)
         endif
c========================
         if(card(1:6).eq.'setang') then
      write(iecr,'(2a)') ' enter rotation: [p ang cos/x/y/z/] or',
     . ' [e alpha/beta/gamma]'
      ine=index(card,'e')
      inp=index(card,'p')
            if(ine.ge.1) then
      card(ine:ine)=' '
      read(card,*) alpha,beta,gamma
      alpha=alpha*dtor
      beta=beta*dtor
      gamma=gamma*dtor
      call rmxe(alpha,beta,gamma,rv)
            else if(inp.ge.1) then
      card(inp:inp)=' '
      read(card,*) ang,uv
      ang=ang*dtor
      call rmxp(ang,uv,rv)
            endif
         endif
      call rmx2e(rv,alpha,beta,gamma)
      alpha=alpha*rtod
      beta=beta*rtod
      gamma=gamma*rtod
      write(iecr,'(2a,3f12.6)') card(1:6),' rotation =',alpha,beta,gamma
      open(unit=o1,file='SYM',form='formatted',status='unknown')
       do n=1,80
      card(n:n)=' '
       enddo
      card(65:65)='#'
      S=0
      do 10 is=1,ns
      alpha=angles(1,is)
      beta=angles(2,is)
      gamma=angles(3,is)
      call rmxe(alpha,beta,gamma,rn)
      call rmx2p(rn,xhi,un)
      call promv(uv,rv,un)
      call rmxp(xhi,uv,rn)
      call rmx2e(rn,alpha,beta,gamma)
      alpha=alpha*rtod
      beta=beta*rtod
      gamma=gamma*rtod
      card(66:70)='     '
      write(card(1:60),'(6f10.3)') alpha,beta,gamma,0.,0.,0.
      S=S+1
         if(S.lt.10) then
      write(card(66:66),'(i1)') S
         else
      write(card(66:67),'(i2)') S
         endif
      write(o1,'(a)') card(1:length(card))
10    continue
      return
      end
"ENDOF platon.f"
#=======================================================================
echo promv.f
cat >promv.f <<"ENDOF promv.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine promv(uo,r1,u1)
      implicit none
      integer i,j
      double precision add,r1,u1,uo
      dimension r1(3,3),u1(3),uo(3)
       do i=1,3
      add=0.d0
        do j=1,3
      add=add+r1(i,j)*u1(j)
        enddo
      uo(i)=add
       enddo
      return
      end
"ENDOF promv.f"
#=======================================================================
echo pythag.f
cat >pythag.f <<"ENDOF pythag.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function pythag(a,b)
      implicit none
      double precision a,b,p,pythag,r,s,t,u
      p=max(abs(a),abs(b))
      if(p.eq.0.0d0) go to 20
      r=(min(abs(a),abs(b))/p)**2
10    continue
      t=4.0d0+r
      if(t.eq.4.0d0) go to 20
      s=r/t
      u=1.0d0+2.0d0*s
      p=u*p
      r=(s/u)**2*r
      go to 10
20    pythag=p
      return
      end
"ENDOF pythag.f"
#=======================================================================
echo refer.f
cat >refer.f <<"ENDOF refer.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program refer
      implicit none
      integer i,i1,iecr,ierr,ilec,ind,j,lungo,nat,nlungo,o1
      double precision al,be,cm,det,dtor,ga,pi,rot,rota,rr,rtod,t,t1,t2,
     & t3,tin,twopi,val,ver,xi,xo
      character atnam*4,card*80,forml*20,lun*4000
      external lungo
      dimension cm(3),rot(3,3),rota(3,3),rr(6),tin(3,3),val(3),ver(3),
     & xi(3),xo(3)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      data nlungo/4000/
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      i1=1
      o1=2
      forml=' (12x,a4,14x,3f8.3) '
1     write(iecr,'(a)') ' enter the input and the output pdb filenames'
      read(ilec,'(a)',end=50) lun
      call compakt(lun,nlungo)
      if(lungo(lun,nlungo).le.0) go to 50
      ind=index(lun,' ')-1
      open(unit=i1,file=lun(1:ind),form='formatted',status='old')
      rewind(unit=i1)
       do i=1,ind
      lun(i:i)=' '
       enddo
      call compakt(lun,nlungo)
      ind=index(lun,' ')-1
      open(unit=o1,file=lun(1:ind),form='formatted',status='unknown')
      rewind(unit=o1)
       do i=1,3
      cm(i)=0.
        do j=1,3
      tin(i,j)=0.
        enddo
       enddo
      nat=0
10    read(i1,'(a)',end=20) card
      if(card(1:4).ne.'ATOM') go to 10
      read(card,fmt=forml) atnam,xi
      if(atnam(2:2).eq.'H'.or.atnam(2:2).eq.'D'.or.atnam(2:2).eq.'E'.or.
     . atnam(2:2).eq.'X'.or.atnam(1:1).eq.'H') go to 10
         if(nat.eq.0) then
       do i=1,3
      xo(i)=xi(i)
       enddo
         endif
      nat=nat+1
       do i=1,3
      cm(i)=cm(i)+xi(i)
        do j=1,3
      tin(i,j)=tin(i,j)+xi(i)*xi(j)
        enddo
       enddo
      go to 10
20    continue
       do i=1,3
      cm(i)=cm(i)/nat
       enddo
       do i=1,3
        do j=1,3
      tin(i,j)=tin(i,j)/nat-cm(i)*cm(j)
        enddo
       enddo
      write(iecr,'(a,3f15.5)') ' center-of-mass =',cm
      write(iecr,'(a,3(/3f10.2))') ' inertia tensor =',
     . ((tin(i,j),j=1,3),i=1,3)
c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      call rs(3,3,tin,val(1),rota,rr(1),rr(4),1,ierr)
      t=val(1)
      val(1)=val(3)
      val(3)=t
      call det3(rota,det)
      t=-sign(1.d0,det)
       do i=1,3
      ver(i)=0.
        do j=1,3
      ver(i)=ver(i)+(xo(j)-cm(j))*rota(j,i)
        enddo
       enddo
      t1=sign(1.d0,ver(1))
      t2=sign(1.d0,ver(2))
      t3=sign(1.d0,ver(3))
      t1=t*t2*t3
       do i=1,3
      rot(i,1)=rota(i,3)*t3
      rot(i,2)=rota(i,2)*t2
      rot(i,3)=rota(i,1)*t1
       enddo
      call rmx2e(rot,al,be,ga)
      call rmxe(pi-ga,be,pi-al,rota)
      al=al*rtod
      be=be*rtod
      ga=ga*rtod
      write(iecr,'(a,3f10.3)') ' euler; alpha,beta,gamma =',al,be,ga
      write(iecr,'(a,i10,a,3f10.3)')
     . ' center of mass of the',nat,' input atoms =',cm
      write(iecr,'(a,3e15.5)') ' inertia moments of input coords. =',val
c ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      write(o1,'(a,6f10.3)') 'ROTTRA',al,be,ga,cm
      rewind(unit=i1)
30    read(i1,'(a)',end=40) card
         if(card(1:4).ne.'ATOM') then
      if(card(1:6).ne.'ROTTRA') write(o1,'(a)') card
      go to 30
         endif
      read(card,fmt=forml) atnam,xi
       do i=1,3
      xo(i)=0.
        do j=1,3
      xo(i)=xo(i)+rota(i,j)*(xi(j)-cm(j))
        enddo
       enddo
      write(card(31:54),'(3f8.3)') xo
      write(o1,'(a)') card
      go to 30
40    close(unit=i1)
      close(unit=o1)
      go to 1
50    stop
      end
"ENDOF refer.f"
#=======================================================================
echo rmx2e.f
cat >rmx2e.f <<"ENDOF rmx2e.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmx2e(rotx,alpha,beta,gamma)
      implicit none
      double precision alpha,ang,beta,cang,dtor,fuzz,gamma,pi,rotx,rtod,
     & sang,twopi
      dimension rotx(3,3)
      common/angkte/ pi,twopi,dtor,rtod
      data fuzz/0.001/
      cang=sqrt(min(max(2.d0-(rotx(1,3)**2+rotx(2,3)**2+rotx(3,1)**2+
     . rotx(3,2)**2+rotx(3,3)**2),0.d0),1.d0))
      ang=acos(sign(cang,rotx(3,3)))
      sang=sin(ang)
         if(sang.gt.fuzz) then
      alpha=atan2(rotx(2,3),rotx(1,3))
      gamma=atan2(rotx(3,2),-rotx(3,1))
         else
      alpha=atan2(-rotx(1,2),rotx(1,1)*rotx(3,3))
      gamma=0.d0
         endif
      alpha=mod(twopi+alpha,twopi)
      beta=ang
      gamma=mod(twopi+gamma,twopi)
      return
      end
"ENDOF rmx2e.f"
#=======================================================================
echo rmx2p.f
cat >rmx2p.f <<"ENDOF rmx2p.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmx2p(rotx,ang,un)
      implicit none
      integer i
      double precision ang,cang,fuzz,rotx,sang,scale,un
      dimension rotx(3,3),un(3)
      data fuzz/0.001/
      cang=min(max((rotx(1,1)+rotx(2,2)+rotx(3,3)-1.d0)/2.d0,-1.d0),
     . 1.d0)
      ang=acos(cang)
      sang=sin(ang)
         if(sang.gt.fuzz) then
      scale=2*sang
      un(1)=(rotx(3,2)-rotx(2,3))/scale
      un(2)=(rotx(1,3)-rotx(3,1))/scale
      un(3)=(rotx(2,1)-rotx(1,2))/scale
         else
            if(cang.gt.0.) then
      un(1)=0.d0
      un(2)=0.d0
      un(3)=1.d0
            else
       do i=1,3
      un(i)=sqrt(max((rotx(i,i)+1)/2,0.d0))
       enddo
               if(un(3).gt.fuzz) then
      un(1)=sign(un(1),rotx(1,3))
      un(2)=sign(un(2),rotx(2,3))
               else if(un(2).gt.fuzz) then
      un(1)=sign(un(1),rotx(1,2))
               endif
            endif
         endif
      return
      end
"ENDOF rmx2p.f"
#=======================================================================
echo rmxe.f
cat >rmxe.f <<"ENDOF rmxe.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmxe(alpha,beta,gamma,rotx)
      implicit none
      double precision alpha,beta,cosa,cosb,cosg,gamma,rotx,sina,sinb,
     & sing
      dimension rotx(3,3)
      cosa=cos(alpha)
      cosb=cos(beta)
      cosg=cos(gamma)
      sina=sin(alpha)
      sinb=sin(beta)
      sing=sin(gamma)
      rotx(1,1)= cosa*cosb*cosg-sina*sing
      rotx(1,2)=-cosa*cosb*sing-sina*cosg
      rotx(1,3)= cosa*sinb
      rotx(2,1)= sina*cosb*cosg+cosa*sing
      rotx(2,2)=-sina*cosb*sing+cosa*cosg
      rotx(2,3)= sina*sinb
      rotx(3,1)=     -sinb*cosg
      rotx(3,2)=      sinb*sing
      rotx(3,3)=      cosb
      return
      end
"ENDOF rmxe.f"
#=======================================================================
echo rmxp.f
cat >rmxp.f <<"ENDOF rmxp.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmxp(ang,un,rotx)
      implicit none
      integer eijk,i,j,k
      double precision ang,cang,rotx,sang,un
      dimension eijk(3,3,3),rotx(3,3),un(3)
      data eijk/
     & 0,0,0,0,0,-1,0,1,0,0,0,1,0,0,0,-1,0,0,0,-1,0,1,0,0,0,0,0/
      cang=cos(ang)
      sang=sin(ang)
       do j=1,3
        do i=1,3
      rotx(i,j)=(1.d0-cang)*un(i)*un(j)
      if(i.eq.j) rotx(i,j)=rotx(i,j)+cang
         do k=1,3
         if(eijk(i,k,j).eq.1) then
      rotx(i,j)=rotx(i,j)+sang*un(k)
         else if(eijk(i,k,j).eq.-1) then
      rotx(i,j)=rotx(i,j)-sang*un(k)
         endif
         enddo
        enddo
       enddo
      return
      end
"ENDOF rmxp.f"
#=======================================================================
echo rs.f
cat >rs.f <<"ENDOF rs.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rs(nm,n,a,w,z,fv1,fv2,matz,ierr)
      implicit none
      integer ierr,matz,n,nm
      double precision a,fv1,fv2,w,z
      dimension a(nm,n),fv1(n),fv2(n),w(n),z(nm,n)
      if(n.le.nm) go to 10
      ierr=10*n
      go to 50
10    if(matz.ne.0) go to 20
      call tred1(nm,n,a,w,fv1,fv2)
      call tqlrat(n,w,fv2,ierr)
      go to 50
20    call tred2(nm,n,a,w,fv1,z)
      call tql2(nm,n,w,fv1,z,ierr)
50    return
      end
"ENDOF rs.f"
#=======================================================================
echo symmetry.f
cat >symmetry.f <<"ENDOF symmetry.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program symmetry
      implicit none
      integer iecr,ilec
      double precision dtor,pi,rtod,twopi
      character card*80,sym*3
      external length
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      ilec=5
      iecr=6
      write(iecr,'(a)') ' enter symmetry: ico oct tet hel cn dn p1'
      read(ilec,'(a)') card
      call compact(card)
      sym=card(1:3)
         if(sym.eq.'ico'.or.sym.eq.'oct'.or.sym.eq.'tet') then
      call platon(sym)
         else if(sym.eq.'hel') then
      write(iecr,'(a)') ' enter parameterization: ctu ele'
      read(ilec,'(a)') card
            if(card(1:3).eq.'ctu') then
      call helix
            else
      call tubes
            endif
         else if(sym(1:2).eq.'cn') then
      call cn
         else if(sym(1:2).eq.'dn') then
      call dn
         else
      write(iecr,'(a)') ' symmetry set to P1'
      call p1
         endif
      stop
      end
"ENDOF symmetry.f"
#=======================================================================
echo tetsim.f
cat >tetsim.f <<"ENDOF tetsim.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tetsim(card,ns,angles,rv)
      implicit none
      integer iecr,ilec,ns
      double precision angles,dtor,pi,rtod,rv,twopi,zero
      character card*80
      dimension angles(3,ns),rv(9)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      call eulert(angles,ns)
      zero=0.d0
      write(iecr,'(3(/a))') ' enter option =',
     . ' 2Z2Y2X',
     . ' or rotation: [p ang cos/x/y/z/] or [e alpha/beta/gamma]'
      read(ilec,'(a)') card
         if(card(1:6).eq.'2Z2Y2X') then
      call rmxe(zero,zero,zero,rv)
         else
      card(1:6)='setang'
         endif
      return
      end
"ENDOF tetsim.f"
#=======================================================================
echo tql2.f
cat >tql2.f <<"ENDOF tql2.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tql2(nm,n,d,e,z,ierr)
      implicit none
      integer i,ierr,ii,j,k,l,l1,l2,m,mml,n,nm
      double precision c,c2,c3,d,dl1,e,el1,f,g,h,p,pythag,r,s,s2,tst1,
     & tst2,z
      external pythag
      dimension d(n),e(n),z(nm,n)
cjn uninitialized values
      data c3,s2/0.,0./
      ierr=0
      if(n.eq.1) go to 1001
      do 100 i=2,n
      e(i-1)=e(i)
100   continue
      f=0.0d0
      tst1=0.0d0
      e(n)=0.0d0
      do 240 l=1,n
      j=0
      h=abs(d(l))+abs(e(l))
      if(tst1.lt.h) tst1=h
      do 110 m=l,n
      tst2=tst1+abs(e(m))
      if(tst2.eq.tst1) go to 120
110   continue
120   if(m.eq.l) go to 220
130   if(j.eq.30) go to 1000
      j=j+1
      l1=l+1
      l2=l1+1
      g=d(l)
      p=(d(l1)-g)/(2.0d0*e(l))
      r=pythag(p,1.0d0)
      d(l)=e(l)/(p+sign(r,p))
      d(l1)=e(l)*(p+sign(r,p))
      dl1=d(l1)
      h=g-d(l)
      if(l2.gt.n) go to 145
      do 140 i=l2,n
      d(i)=d(i)-h
140   continue
145   f=f+h
      p=d(m)
      c=1.0d0
      c2=c
      el1=e(l1)
      s=0.0d0
      mml=m-l
      do 200 ii=1,mml
      c3=c2
      c2=c
      s2=s
      i=m-ii
      g=c*e(i)
      h=c*p
      r=pythag(p,e(i))
      e(i+1)=s*r
      s=e(i)/r
      c=p/r
      p=c*d(i)-s*g
      d(i+1)=h+s*(c*g+s*d(i))
      do 180 k=1,n
      h=z(k,i+1)
      z(k,i+1)=s*z(k,i)+c*h
      z(k,i)=c*z(k,i)-s*h
180   continue
200   continue
      p=-s*s2*c3*el1*e(l)/dl1
      e(l)=s*p
      d(l)=c*p
      tst2=tst1+abs(e(l))
      if(tst2.gt.tst1) go to 130
220   d(l)=d(l)+f
240   continue
      do 300 ii=2,n
      i=ii-1
      k=i
      p=d(i)
      do 260 j=ii,n
      if(d(j).ge.p) go to 260
      k=j
      p=d(j)
260   continue
      if(k.eq.i) go to 300
      d(k)=d(i)
      d(i)=p
      do 280 j=1,n
      p=z(j,i)
      z(j,i)=z(j,k)
      z(j,k)=p
280   continue
300   continue
      go to 1001
1000  ierr=l
1001  return
      end
"ENDOF tql2.f"
#=======================================================================
echo tqlrat.f
cat >tqlrat.f <<"ENDOF tqlrat.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tqlrat(n,d,e2,ierr)
      implicit none
      integer i,ierr,ii,j,l,l1,m,mml,n
      double precision b,c,d,e2,epslon,f,g,h,p,pythag,r,s,t
      external epslon,pythag
      dimension d(n),e2(n)
cjn uninitialized values
      data b,c/0.,0./
      ierr=0
      if(n.eq.1) go to 1001
      do 100 i=2,n
      e2(i-1)=e2(i)
100   continue
      f=0.0d0
      t=0.0d0
      e2(n)=0.0d0
      do 290 l=1,n
      j=0
      h=abs(d(l))+sqrt(e2(l))
      if(t.gt.h) go to 105
      t=h
      b=epslon(t)
      c=b*b
105   do 110 m=l,n
      if(e2(m).le.c) go to 120
110   continue
120   if(m.eq.l) go to 210
130   if(j.eq.30) go to 1000
      j=j+1
      l1=l+1
      s=sqrt(e2(l))
      g=d(l)
      p=(d(l1)-g)/(2.0d0*s)
      r=pythag(p,1.0d0)
      d(l)=s/(p+sign(r,p))
      h=g-d(l)
      do 140 i=l1,n
      d(i)=d(i)-h
140   continue
      f=f+h
      g=d(m)
      if(g.eq.0.0d0) g=b
      h=g
      s=0.0d0
      mml=m-l
      do 200 ii=1,mml
      i=m-ii
      p=g*h
      r=p+e2(i)
      e2(i+1)=s*r
      s=e2(i)/r
      d(i+1)=h+s*(h+d(i))
      g=d(i)-e2(i)/g
      if(g.eq.0.0d0) g=b
      h=g*p/r
200   continue
      e2(l)=s*g
      d(l)=h
      if(h.eq.0.0d0) go to 210
      if(abs(e2(l)).le.abs(c/h)) go to 210
      e2(l)=h*e2(l)
      if(e2(l).ne.0.0d0) go to 130
210   p=d(l)+f
      if(l.eq.1) go to 250
      do 230 ii=2,l
      i=l+2-ii
      if(p.ge.d(i-1)) go to 270
      d(i)=d(i-1)
230   continue
250   i=1
270   d(i)=p
290   continue
      go to 1001
1000  ierr=l
1001  return
      end
"ENDOF tqlrat.f"
#=======================================================================
echo tred1.f
cat >tred1.f <<"ENDOF tred1.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tred1(nm,n,a,d,e,e2)
      implicit none
      integer i,ii,j,jp1,k,l,n,nm
      double precision a,d,e,e2,f,g,h,scale
      dimension a(nm,n),d(n),e(n),e2(n)
      do 100 i=1,n
      d(i)=a(n,i)
      a(n,i)=a(i,i)
100   continue
      do 300 ii=1,n
      i=n+1-ii
      l=i-1
      h=0.0d0
      scale=0.0d0
      if(l.lt.1) go to 130
      do 120 k=1,l
      scale=scale+abs(d(k))
120   continue
      if(scale.ne.0.0d0) go to 140
      do 125 j=1,l
      d(j)=a(l,j)
      a(l,j)=a(i,j)
      a(i,j)=0.0d0
125   continue
130   e(i)=0.0d0
      e2(i)=0.0d0
      go to 300
140   do 150 k=1,l
      d(k)=d(k)/scale
      h=h+d(k)*d(k)
150   continue
      e2(i)=scale*scale*h
      f=d(l)
      g=-sign(sqrt(h),f)
      e(i)=scale*g
      h=h-f*g
      d(l)=f-g
      if(l.eq.1) go to 285
      do 170 j=1,l
      e(j)=0.0d0
170   continue
      do 240 j=1,l
      f=d(j)
      g=e(j)+a(j,j)*f
      jp1=j+1
      if(l.lt.jp1) go to 220
      do 200 k=jp1,l
      g=g+a(k,j)*d(k)
      e(k)=e(k)+a(k,j)*f
200   continue
220   e(j)=g
240   continue
      f=0.0d0
      do 245 j=1,l
      e(j)=e(j)/h
      f=f+e(j)*d(j)
245   continue
      h=f/(h+h)
      do 250 j=1,l
      e(j)=e(j)-h*d(j)
250   continue
      do 280 j=1,l
      f=d(j)
      g=e(j)
      do 260 k=j,l
      a(k,j)=a(k,j)-f*e(k)-g*d(k)
260   continue
280   continue
285   do 290 j=1,l
      f=d(j)
      d(j)=a(l,j)
      a(l,j)=a(i,j)
      a(i,j)=f*scale
290   continue
300   continue
      return
      end
"ENDOF tred1.f"
#=======================================================================
echo tred2.f
cat >tred2.f <<"ENDOF tred2.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tred2(nm,n,a,d,e,z)
      implicit none
      integer i,ii,j,jp1,k,l,n,nm
      double precision a,d,e,f,g,h,hh,scale,z
      dimension a(nm,n),d(n),e(n),z(nm,n)
      do 100 i=1,n
      do 80 j=i,n
      z(j,i)=a(j,i)
80    continue
      d(i)=a(n,i)
100   continue
      if(n.eq.1) go to 510
      do 300 ii=2,n
      i=n+2-ii
      l=i-1
      h=0.0d0
      scale=0.0d0
      if(l.lt.2) go to 130
      do 120 k=1,l
      scale=scale+abs(d(k))
120   continue
      if(scale.ne.0.0d0) go to 140
130   e(i)=d(l)
      do 135 j=1,l
      d(j)=z(l,j)
      z(i,j)=0.0d0
      z(j,i)=0.0d0
135   continue
      go to 290
140   do 150 k=1,l
      d(k)=d(k)/scale
      h=h+d(k)*d(k)
150   continue
      f=d(l)
      g=-sign(sqrt(h),f)
      e(i)=scale*g
      h=h-f*g
      d(l)=f-g
      do 170 j=1,l
      e(j)=0.0d0
170   continue
      do 240 j=1,l
      f=d(j)
      z(j,i)=f
      g=e(j)+z(j,j)*f
      jp1=j+1
      if(l.lt.jp1) go to 220
      do 200 k=jp1,l
      g=g+z(k,j)*d(k)
      e(k)=e(k)+z(k,j)*f
200   continue
220   e(j)=g
240   continue
      f=0.0d0
      do 245 j=1,l
      e(j)=e(j)/h
      f=f+e(j)*d(j)
245   continue
      hh=f/(h+h)
      do 250 j=1,l
      e(j)=e(j)-hh*d(j)
250   continue
      do 280 j=1,l
      f=d(j)
      g=e(j)
      do 260 k=j,l
      z(k,j)=z(k,j)-f*e(k)-g*d(k)
260   continue
      d(j)=z(l,j)
      z(i,j)=0.0d0
280   continue
290   d(i)=h
300   continue
      do 500 i=2,n
      l=i-1
      z(n,l)=z(l,l)
      z(l,l)=1.0d0
      h=d(i)
      if(h.eq.0.0d0) go to 380
      do 330 k=1,l
      d(k)=z(k,i)/h
330   continue
      do 370 j=1,l
      g=0.0d0
      do 340 k=1,l
      g=g+z(k,i)*z(k,j)
340   continue
      do 360 k=1,l
      z(k,j)=z(k,j)-g*d(k)
360   continue
370   continue
380   do 400 k=1,l
      z(k,i)=0.0d0
400   continue
500   continue
510   do 520 i=1,n
      d(i)=z(n,i)
      z(n,i)=0.0d0
520   continue
      z(n,n)=1.0d0
      e(1)=0.0d0
      return
      end
"ENDOF tred2.f"
#=======================================================================
echo tubes.f
cat >tubes.f <<"ENDOF tubes.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine tubes
      implicit none
      integer N,S,i,iecr,ilec,j,length,o1,signo,start
      double precision dtor,pi,rtod,twopi,w1,w2,x
      character card*80
      dimension x(2)
      common/angkte/ pi,twopi,dtor,rtod
      common/ioprg/ ilec,iecr
      data o1/1/
      write(iecr,'(2a)') ' enter elementary helix shifts',
     . ' (degrees , Angstroms), number of starts , N:'
      read(ilec,*) x,start,N
      write(iecr,'(a)') ' base vector ='
      write(iecr,'(a,2f15.5,a,i5)') ' x1,x2 =',x(1),x(2),
     . ' ; starts =',start
      x(1)=x(1)*dtor/twopi
      open(unit=o1,file='SYM',form='formatted',status='unknown')
       do i=1,80
      card(i:i)=' '
       enddo
      card(65:65)='#'
      S=0
       do j=0,start-1
      w1=(1.d0/start)*j
      card(66:70)='     '
      write(card(1:60),'(6f10.3)') w1*360,0.,0.,0.,0.,0.
      S=S+1
         if(S.lt.10) then
      write(card(66:66),'(i1)') S
         else if(S.lt.100) then
      write(card(66:67),'(i2)') S
         else if(S.lt.1000) then
      write(card(66:68),'(i3)') S
         else
      write(card(66:69),'(i4)') S
         endif
      write(o1,'(a)') card(1:length(card))
        do signo=1,-1,-2
         do i=1,N
      w1=signo*i*x(1)+(1.d0/start)*j
      w2=signo*i*x(2)
      w1=mod(1.d0+mod(w1,1.d0),1.d0)
      card(66:70)='     '
      write(card(1:60),'(6f10.3)') w1*360,0.,0.,0.,0.,w2
      S=S+1
         if(S.lt.10) then
      write(card(66:66),'(i1)') S
         else if(S.lt.100) then
      write(card(66:67),'(i2)') S
         else if(S.lt.1000) then
      write(card(66:68),'(i3)') S
         else
      write(card(66:69),'(i4)') S
         endif
      write(o1,'(a)') card(1:length(card))
         enddo
        enddo
       enddo
      return
      end
"ENDOF tubes.f"
"ENDOF util.for"
#=======================================================================
echo fit.for
cat >fit.for <<"ENDOF fit.for"
# to recover individual items, csh this file
#=======================================================================
echo abra.f
cat >abra.f <<"ENDOF abra.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine abra(lu,ft,ss)
      implicit none
      integer lgth,lu,lungo,n,nlungo
      character ft*1,fu*500,ss*1,st*7,tcar*80
      logical first
      external lungo
      data first/.true./,nlungo/500/
      save fu,lgth
         if(first) then
       do n=1,nlungo
      fu(n:n)=' '
       enddo
      call getenv('UROF',fu)
      lgth=lungo(fu,nlungo)+1
      fu(lgth:lgth)='/'
      first=.false.
         endif
         if(ss.eq.'n') then
      st='new    '
         else if(ss.eq.'o') then
      st='old    '
         else if(ss.eq.'u') then
      st='unknown'
         else if(ss.eq.'s') then
      st='scratch'
         endif
         if(lu.lt.10) then
      write(tcar,'(a,i1,2x)') 'fort.',lu
         else if(lu.lt.100) then
      write(tcar,'(a,i2,1x)') 'fort.',lu
         else
      write(tcar,'(a,i3)') 'fort.',lu
         endif
      fu(lgth+1:lgth+8)=tcar(1:8)
         if(ft.eq.'f') then
      open(unit=lu,file=fu,form='formatted',status=st)
         else if(ft.eq.'u') then
      open(unit=lu,file=fu,form='unformatted',status=st)
         endif
      return
      end
"ENDOF abra.f"
#=======================================================================
echo celda.f
cat >celda.f <<"ENDOF celda.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine celda
      implicit none
      real a,a11,a21,a22,a31,a32,a33,alpha,ast,b,beta,bst,c,ca,cast,cb,
     & cbst,cg,cgst,cst,dtor,gamma,pi,r,rf,rfx,ro,rox,rtod,sa,sast,sb,
     & sbst,sg,sgst,twopi,vol
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,ca,cb,cg,sa,sb,sg,ast,bst,cst,
     & cast,cbst,cgst,sast,sbst,sgst,vol
      common/ortm/ ro(3,3),rf(3,3),rox(9),rfx(9)
      common/star/ a11,a21,a22,a31,a32,a33
      r=alpha*dtor
      ca=cos(r)
      sa=sin(r)
      r=beta*dtor
      cb=cos(r)
      sb=sin(r)
      r=gamma*dtor
      cg=cos(r)
      sg=sin(r)
      vol=a*b*c*sqrt(1+2*ca*cb*cg-ca*ca-cb*cb-cg*cg)
      cast=(cb*cg-ca)/(sb*sg)
      cbst=(cg*ca-cb)/(sg*sa)
      cgst=(ca*cb-cg)/(sa*sb)
      sast=sqrt(1.-cast*cast)
      sbst=sqrt(1.-cbst*cbst)
      sgst=sqrt(1.-cgst*cgst)
      ast=1/(a*sb*sgst)
      bst=1/(b*sg*sast)
      cst=1/(c*sa*sbst)
      a11=ast*sbst*sg
      a21=-ast*sbst*cg
      a22=bst*sast
      a31=ast*cbst
      a32=bst*cast
      a33=cst
      ro(1,1)=a
      ro(1,2)=b*cg
      ro(1,3)=c*cb
      ro(2,2)=b*sg
      ro(2,3)=-c*sb*cast
      ro(3,3)=c*sa*sbst
      rf(1,1)=ast*sbst*sg
      rf(1,2)=-ast*sbst*cg
      rf(1,3)=ast*cbst
      rf(2,2)=bst*sast
      rf(2,3)=bst*cast
      rf(3,3)=cst
      return
      end
"ENDOF celda.f"
#=======================================================================
echo cierre.f
cat >cierre.f <<"ENDOF cierre.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine cierre(lu,ft)
      implicit none
      integer lu
      character ft*1
         if(ft.eq.'d') then
      close(unit=lu,status='delete')
         else
      close(unit=lu)
         endif
      return
      end
"ENDOF cierre.f"
#=======================================================================
echo correl.f
cat >correl.f <<"ENDOF correl.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine correl(nr,hmax,kmax,lmax,ho,ko,lo,fo,ff,ft,ftab)
      implicit none
      integer bod,hmax,ho,iecr,ilec,ir,kmax,ko,lmax,lo,mol,nr,ns,sym
      real a0,alf,b0,bet,c0,corr,gam,ox,oy,oz,rmx,tx,ty,tz
      complex fc,ff,fo,fob,ft,ftab
      logical first
      dimension ff(nr),fo(nr),ft(nr),
     & ftab(-hmax:hmax,-kmax:kmax,-lmax:lmax),ho(nr),ko(nr),lo(nr)
      common/ioprg/ ilec,iecr
      common/rotra/ mol,bod,alf,bet,gam,tx,ty,tz,rmx(9),ox,oy,oz,ns,
     & sym(1000),corr
      save a0
      data first/.true./
         if(first) then
      first=.false.
      a0=0.
       do ir=1,nr
      fob=fo(ir)
      a0=a0+real(conjg(fob)*fob)
       enddo
         endif
      call ncsym
      call fsym(nr,hmax,kmax,lmax,ho,ko,lo,ft,ftab)
      b0=0.
      c0=0.
       do ir=1,nr
      fob=fo(ir)
      fc=ff(ir)+ft(ir)
      b0=b0+real(conjg(fc)*fc)
      c0=c0+real(conjg(fob)*fc)
       enddo
      corr=c0/sqrt(a0*b0)
      write(iecr,'(2i3,7f10.2)') mol,bod,alf,bet,gam,ox,oy,oz,corr*100
cjn   write(iecr,'(2i3,7f10.2)') mol,bod,alf,bet,gam,tx,ty,tz,corr*100
cjn   write(iecr,'(2i3,9f9.5,3f9.2,f8.2)') mol,bod,rmx,ox,oy,oz,corr*100
      call flush(iecr)
      return
      end
"ENDOF correl.f"
#=======================================================================
echo fitcorrel.f
cat >fitcorrel.f <<"ENDOF fitcorrel.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine fitcorrel(mi,mc,ii,cc)
      implicit none
      integer hmax,ii,kmax,lmax,mc,mi,nr
      complex cc
      dimension cc(mc),ii(mi)
      common/dimen/ nr,hmax,kmax,lmax
      call correl(nr,hmax,kmax,lmax,ii(1),ii(1+nr),ii(1+2*nr),cc(1),
     . cc(1+nr),cc(1+2*nr),cc(1+3*nr))
      return
      end
"ENDOF fitcorrel.f"
#=======================================================================
echo fitin.f
cat >fitin.f <<"ENDOF fitin.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      program fitin
      implicit none
      integer iecr,ii,ilec,mc,mi
      complex cc
      parameter(mi=1000000,mc=10000000)
      dimension cc(mc),ii(mi)
      common/ioprg/ ilec,iecr
      ilec=5
      iecr=6
      call fittin(mi,mc,ii,cc)
      stop
      end
"ENDOF fitin.f"
#=======================================================================
echo fittin.f
cat >fittin.f <<"ENDOF fittin.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine fittin(mi,mc,ii,cc)
      implicit none
      integer bod,bodm,bodo,hmax,i,id,iecr,ii,ilec,indc,is,j,kmax,lmax,
     & lungo,maxc,maxi,mc,mi,mol,moln,ms,n,nlungo,nmol,nr,ns,nsm,sim,
     & sym,symm,tbod,udi
      real a,alf,alfm,alpha,b,bet,beta,betm,c,corr,dmax,dmin,dtor,gam,
     & gamm,gamma,ox,oxm,oy,oym,oz,ozm,pi,rbid1,rbid2,rf,rfx,rms,rmx,
     & rmxm,ro,rox,rtod,rx,t,tms,twopi,tx,txm,ty,tym,tz,tzm,xxx
      complex cc
      character card*4000,porte*110
      logical deriv
      external lungo
      dimension cc(mc),ii(mi),rx(9),sim(1000)
      common/angkte/ pi,twopi,dtor,rtod
      common/cell/ a,b,c,alpha,beta,gamma,rbid1(16)
      common/dimen/ nr,hmax,kmax,lmax
      common/interpo/ deriv
      common/ioprg/ ilec,iecr
      common/ncsdat/ rms(9,1000),tms(3,1000),rbid2(12,1000),ms
      common/ortm/ ro(3,3),rf(3,3),rox(3,3),rfx(3,3)
      common/reso/ dmax,dmin
      common/rotra/ mol,bod,alf,bet,gam,tx,ty,tz,rmx(9),ox,oy,oz,ns,
     & sym(1000),corr
      common/rotram/ bodm(100),alfm(100),betm(100),gamm(100),txm(100),
     & tym(100),tzm(100),rmxm(9,100),oxm(100),oym(100),ozm(100),
     & symm(1000,100),nmol
      data nlungo/4000/
      pi=atan2(1.d0,1.d0)*4.d0
      twopi=atan2(1.d0,1.d0)*8.d0
      dtor=atan2(1.d0,1.d0)/45.d0
      rtod=45.d0/atan2(1.d0,1.d0)
      udi=10
      call abra(udi,'u','o')
      rewind(unit=udi)
      read(udi) nr,a,b,c,alpha,beta,gamma
      maxi=3*nr
      if(maxi.gt.mi) STOP ' increase mi'
      call celda
       do i=1,3
        do j=1,3
      rox(i,j)=ro(i,j)
      rfx(i,j)=rf(i,j)
        enddo
       enddo
      id=8
      call abra(id,'f','o')
      rewind(unit=id)
      read(id,*) dmax,dmin
         if(dmax.lt.dmin) then
      t=dmax
      dmax=dmin
      dmin=t
         endif
      call lecfoq(udi,nr,ii(1),cc(1))
      call cierre(udi,'u')
      read(id,'(a)') card
      if(card(1:3).eq.'ncs') card(1:3)='   '
      read(card,*) ms
      if(ms.gt.1000) STOP ' increase ms'
       do i=1,1000
      sim(i)=0
       enddo
       do i=1,ms
      read(id,'(a)') card
      indc=index(card,'#')
      card(indc:indc)=' '
      read(card,*) alf,bet,gam,tx,ty,tz,is
      call rmxe(alf,bet,gam,rx)
      call pro2mx(rms(1,is),rfx,rx)
      tms(1,is)=tx
      tms(2,is)=ty
      tms(3,is)=tz
      sim(is)=1
       enddo
      maxc=0
      bodo=0
       do n=1+nr,2*nr
      cc(n)=(0.,0.)
       enddo
       do n=1,100
        do i=1,1000
      symm(i,n)=0
        enddo
       enddo
cjn lectab y fixmol(+) para todas
      read(id,*) nmol
      do 10 mol=1,nmol
      read(id,'(a)') card
      indc=index(card,'#')
      card(indc:indc)=' '
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      read(card,*) bod,alf,bet,gam,ox,oy,oz,ns,(sym(i),i=1,ns)
      tx=rfx(1,1)*ox+rfx(1,2)*oy+rfx(1,3)*oz
      ty=rfx(2,1)*ox+rfx(2,2)*oy+rfx(2,3)*oz
      tz=rfx(3,1)*ox+rfx(3,2)*oy+rfx(3,3)*oz
      call rmxe(alf,bet,gam,rmx)
c     ox=rox(1,1)*tx+rox(1,2)*ty+rox(1,3)*tz
c     oy=rox(2,1)*tx+rox(2,2)*ty+rox(2,3)*tz
c     oz=rox(3,1)*tx+rox(3,2)*ty+rox(3,3)*tz
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      bodm(mol)=bod
      alfm(mol)=alf
      betm(mol)=bet
      gamm(mol)=gam
      txm(mol)=tx
      tym(mol)=ty
      tzm(mol)=tz
       do i=1,9
      rmxm(i,mol)=rmx(i)
       enddo
      oxm(mol)=ox
      oym(mol)=oy
      ozm(mol)=oz
       do i=1,ns
      if(sim(sym(i)).eq.0) STOP ' symmetry operation not in symlist'
      symm(i,mol)=sym(i)
       enddo
         if(bod.ne.bodo) then
      bodo=bod
      tbod=bod+10
      call abra(tbod,'u','o')
      rewind(unit=tbod)
      read(tbod) (xxx,i=1,7),hmax,kmax,lmax
      if(3*nr+(2*hmax+1)*(2*kmax+1)*(2*lmax+1).gt.maxc)
     . maxc=3*nr+(2*hmax+1)*(2*kmax+1)*(2*lmax+1)
      if(maxc.gt.mc) STOP ' increase mc'
      call lectab(bod,hmax,kmax,lmax,cc(1+3*nr))
      call cierre(tbod,'u')
         endif
      call ncsym
      call fixmol(nr,hmax,kmax,lmax,ii(1),ii(1+nr),ii(1+2*nr),
     . cc(1+nr),cc(1+3*nr),'+')
10    continue
      mol=nmol
      read(id,*) deriv
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
CJN SIMULACION: BEGIN
      moln=mol
      call fitswitch(maxi,maxc,ii,cc,moln)
      n=0
      nsm=0
20    continue
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      read(ilec,'(a)',end=30) porte
      if(lungo(porte,110).eq.0) go to 30
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      indc=index(porte,'#')
         if(indc.ne.0) then
      porte(indc:indc)=' '
      read(porte,*) moln
      write(iecr,'(a,2i5)') ' current molecule   ',mol,moln
      call flush(iecr)
      call fitswitch(maxi,maxc,ii,cc,moln)
      go to 20
         endif
cjn lectura de las variables de posicion: begin
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      read(porte,*) alf,bet,gam,ox,oy,oz
      tx=rfx(1,1)*ox+rfx(1,2)*oy+rfx(1,3)*oz
      ty=rfx(2,1)*ox+rfx(2,2)*oy+rfx(2,3)*oz
      tz=rfx(3,1)*ox+rfx(3,2)*oy+rfx(3,3)*oz
      call rmxe(alf,bet,gam,rmx)
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
cjn lectura de las variables de posicion: end
      call fitcorrel(maxi,maxc,ii,cc)
      nsm=nsm+ns
      n=n+1
      go to 20
30    continue
CJN SIMULACION: END
c %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      return
      end
"ENDOF fittin.f"
#=======================================================================
echo fitswitch.f
cat >fitswitch.f <<"ENDOF fitswitch.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine fitswitch(mi,mc,ii,cc,moln)
      implicit none
      integer bod,bodm,hmax,ibid1,ii,kmax,lmax,mc,mi,mol,moln,nmol,nr,
     & ns,sym
      real corr,rbid1,rbid2
      complex cc
      logical first
      dimension cc(mc),ii(mi)
      common/dimen/ nr,hmax,kmax,lmax
      common/rotra/ mol,bod,rbid1(18),ns,sym(1000),corr
      common/rotram/ bodm(100),rbid2(1800),ibid1(100000),nmol
      data first/.true./
cjn al comienzo moln = mol
cjn switch si inicializacion o cambio de molecula
         if(first.or.(moln.ne.mol.and.moln.gt.0.and.moln.le.nmol)) then
      if(first) first=.false.
      call switch(nr,hmax,kmax,lmax,ii(1),ii(1+nr),ii(1+2*nr),cc(1+nr),
     . cc(1+3*nr),moln)
         endif
      return
      end
"ENDOF fitswitch.f"
#=======================================================================
echo fixmol.f
cat >fixmol.f <<"ENDOF fixmol.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine fixmol(nr,hmax,kmax,lmax,ho,ko,lo,ff,ftab,mas)
      implicit none
      integer bod,h,hh,hmax,ho,ih,ik,il,in,ir,k,kk,kmax,ko,l,ll,lmax,lo,
     & mol,ms,nr,ns,sym
      real corr,dh,dk,dl,dtor,dxn,phi,pi,rbid1,rbid2,rtod,twopi,txn,xh,
     & xk,xl
      complex dfh,dfk,dfl,f,fc,ff,ftab,phase,twopii
      character mas*1
      logical first,plus
      dimension ff(nr),ftab(-hmax:hmax,-kmax:kmax,-lmax:lmax),ho(nr),
     & ko(nr),lo(nr)
      common/angkte/ pi,twopi,dtor,rtod
      common/ncsdat/ rbid1(12,1000),dxn(3,3,1000),txn(3,1000),ms
      common/rotra/ mol,bod,rbid2(18),ns,sym(1000),corr
      save twopii
      data first/.true./
         if(first) then
      first=.false.
      twopii=cmplx(0.,twopi)
         endif
         if(mas.eq.'+') then
      plus=.true.
         else
      plus=.false.
         endif
      do 20 ir=1,nr
      h=ho(ir)
      k=ko(ir)
      l=lo(ir)
      fc=(0.,0.)
      do 10 in=1,ns
      phi=mod(h*txn(1,in)+k*txn(2,in)+l*txn(3,in),1.)
      phase=cexp(twopii*phi)
      xh=h*dxn(1,1,in)+k*dxn(2,1,in)+l*dxn(3,1,in)
      xk=h*dxn(1,2,in)+k*dxn(2,2,in)+l*dxn(3,2,in)
      xl=h*dxn(1,3,in)+k*dxn(2,3,in)+l*dxn(3,3,in)
      hh=nint(xh)
      dh=xh-hh
      ih=1
      if(dh.lt.0.) ih=-1
      kk=nint(xk)
      dk=xk-kk
      ik=1
      if(dk.lt.0.) ik=-1
      ll=nint(xl)
      dl=xl-ll
      il=1
      if(dl.lt.0.) il=-1
      dfh=(ftab(hh+ih,kk,ll)-ftab(hh,kk,ll))/ih
      dfk=(ftab(hh,kk+ik,ll)-ftab(hh,kk,ll))/ik
      dfl=(ftab(hh,kk,ll+il)-ftab(hh,kk,ll))/il
      f=ftab(hh,kk,ll)+dfh*dh+dfk*dk+dfl*dl
      fc=fc+f*phase
10    continue
         if(plus) then
      ff(ir)=ff(ir)+fc
         else
      ff(ir)=ff(ir)-fc
         endif
20    continue
      return
      end
"ENDOF fixmol.f"
#=======================================================================
echo fsym.f
cat >fsym.f <<"ENDOF fsym.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine fsym(nr,hmax,kmax,lmax,ho,ko,lo,ft,ftab)
      implicit none
      integer bod,h,hh,hmax,ho,ih,ik,il,in,ip,ir,k,kk,kmax,ko,l,ll,lmax,
     & lo,mol,ms,n,nphi,nr,ns,sym
      real corr,dh,dk,dl,dtor,dxn,phi,pi,rbid1,rbid2,rtod,twopi,txn,xh,
     & xk,xl
      complex cex,dfh,dfk,dfl,f,fc,ft,ftab,phase,twopii
      logical deriv,first
      parameter(nphi=720)
      dimension cex(-nphi:nphi),ft(nr),
     & ftab(-hmax:hmax,-kmax:kmax,-lmax:lmax),ho(nr),ko(nr),lo(nr)
      common/angkte/ pi,twopi,dtor,rtod
      common/interpo/ deriv
      common/ncsdat/ rbid1(12,1000),dxn(3,3,1000),txn(3,1000),ms
      common/rotra/ mol,bod,rbid2(18),ns,sym(1000),corr
      save cex,twopii
      data first/.true./
         if(first) then
      first=.false.
      twopii=cmplx(0.,twopi)
       do n=-nphi,nphi
      cex(n)=cexp(n*twopii/nphi)
       enddo
         endif
      do 20 ir=1,nr
      h=ho(ir)
      k=ko(ir)
      l=lo(ir)
      fc=(0.,0.)
      do 10 in=1,ns
      phi=mod(h*txn(1,in)+k*txn(2,in)+l*txn(3,in),1.)
      ip=nint(phi*nphi)
      phase=cex(ip)
      xh=h*dxn(1,1,in)+k*dxn(2,1,in)+l*dxn(3,1,in)
      xk=h*dxn(1,2,in)+k*dxn(2,2,in)+l*dxn(3,2,in)
      xl=h*dxn(1,3,in)+k*dxn(2,3,in)+l*dxn(3,3,in)
      hh=nint(xh)
      kk=nint(xk)
      ll=nint(xl)
      f=ftab(hh,kk,ll)
         if(deriv) then
      dh=xh-hh
      ih=1
      if(dh.lt.0.) ih=-1
      dk=xk-kk
      ik=1
      if(dk.lt.0.) ik=-1
      dl=xl-ll
      il=1
      if(dl.lt.0.) il=-1
      dfh=(ftab(hh+ih,kk,ll)-ftab(hh,kk,ll))/ih
      dfk=(ftab(hh,kk+ik,ll)-ftab(hh,kk,ll))/ik
      dfl=(ftab(hh,kk,ll+il)-ftab(hh,kk,ll))/il
      f=f+dfh*dh+dfk*dk+dfl*dl
         endif
      fc=fc+f*phase
10    continue
      ft(ir)=fc
20    continue
      return
      end
"ENDOF fsym.f"
#=======================================================================
echo lecfoq.f
cat >lecfoq.f <<"ENDOF lecfoq.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lecfoq(i1,nr,hklo,fo)
      implicit none
      integer h,hklo,i1,ir,k,l,n,nr,nro
      real a11,a21,a22,a31,a32,a33,dmax,dmin,fmax,fmin,mfo,sfli,sfqu,
     & sfsq,sqh,sqhinf,sqhmax,sqhmin,sqhsup
      complex fo
      dimension fo(nr),hklo(3*nr)
      common/reso/ dmax,dmin
      common/star/ a11,a21,a22,a31,a32,a33
      sqhmin=(1/dmax)**2
      sqhmax=(1/dmin)**2
      sfli=0.
      sfsq=0.
      sfqu=0.
      sqhinf=1.e20
      sqhsup=0.
      fmin=1.e20
      fmax=0.
      read(i1) nro,hklo,fo
      if(nro.ne.nr) STOP ' nro .ne. nr'
      n=0
      do 10 ir=1,nr
      h=hklo(ir)
      k=hklo(ir+nr)
      l=hklo(ir+2*nr)
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.lt.sqhmin.or.sqh.gt.sqhmax) go to 10
      n=n+1
      hklo(n)=h
      hklo(n+nr)=k
      hklo(n+2*nr)=l
      fo(n)=fo(ir)
      mfo=abs(fo(ir))
      sfli=sfli+mfo
      sfsq=sfsq+mfo**2
      sfqu=sfqu+mfo**4
      if(mfo.lt.fmin) fmin=mfo
      if(mfo.gt.fmax) fmax=mfo
      if(sqh.lt.sqhinf) sqhinf=sqh
      if(sqh.gt.sqhsup) sqhsup=sqh
10    continue
       do ir=1,n
      hklo(ir+n)=hklo(ir+nr)
       enddo
       do ir=1,n
      hklo(ir+2*n)=hklo(ir+2*nr)
       enddo
      nr=n
      dmax=sqrt(1/sqhinf)
      dmin=sqrt(1/sqhsup)
      return
      end
"ENDOF lecfoq.f"
#=======================================================================
echo lectab.f
cat >lectab.f <<"ENDOF lectab.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine lectab(bod,hmax,kmax,lmax,ftab)
      implicit none
      integer bod,h,hmax,hsup,i,k,kmax,ksup,l,lmax,lsup,nort,tbod
      real a11,a21,a22,a31,a32,a33,cel,dmax,dmin,dmint,dsq,fuzz,maille,
     & rbid1,sqh,sqhsup
      complex ftab
      dimension ftab(-hmax:hmax,-kmax:kmax,-lmax:lmax),maille(6)
      common/cell/ cel(6),rbid1(16)
      common/reso/ dmax,dmin
      common/star/ a11,a21,a22,a31,a32,a33
      data fuzz/1.0001/
      tbod=bod+10
      rewind(unit=tbod)
       do i=1,6
      maille(i)=cel(i)
       enddo
      read(tbod) cel,nort,hsup,ksup,lsup,sqhsup
      call celda
       do i=1,6
      cel(i)=maille(i)
       enddo
      dsq=0.
      do 30 h=-1,1
      do 20 k=-1,1
      do 10 l=-1,1
      sqh=(a31*h+a32*k+a33*l)**2+(a21*h+a22*k)**2+(a11*h)**2
      if(sqh.gt.dsq) dsq=sqh
10    continue
20    continue
30    continue
      dmint=1/(sqrt(sqhsup)-sqrt(dsq))
      if(dmint/dmin.gt.fuzz) STOP ' resolution mismatch'
      read(tbod) ftab
      return
      end
"ENDOF lectab.f"
#=======================================================================
echo lungo.f
cat >lungo.f <<"ENDOF lungo.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      function lungo(card,nfield)
      implicit none
      integer i,lungo,nfield
      character card*1
      dimension card(nfield)
       do i=nfield,1,-1
      if(card(i).ne.' ') go to 10
       enddo
10    lungo=i
      return
      end
"ENDOF lungo.f"
#=======================================================================
echo ncsym.f
cat >ncsym.f <<"ENDOF ncsym.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine ncsym
      implicit none
      integer bod,i,in,is,mol,ms,ns,sym
      real alf,bet,corr,dxn,gam,ox,oy,oz,rf,rfx,rms,rmx,ro,rox,rxo,tms,
     & tx,txn,ty,tz
      dimension rxo(9)
      common/ncsdat/ rms(3,3,1000),tms(3,1000),dxn(9,1000),txn(3,1000),
     & ms
      common/ortm/ ro(9),rf(9),rox(9),rfx(3,3)
      common/rotra/ mol,bod,alf,bet,gam,tx,ty,tz,rmx(9),ox,oy,oz,ns,
     & sym(1000),corr
      call pro2mx(rxo,rmx,ro)
      do 10 in=1,ns
      is=sym(in)
       do i=1,3
      txn(i,in)=rms(i,1,is)*ox+rms(i,2,is)*oy+rms(i,3,is)*oz+tms(i,is)
       enddo
      call pro2mx(dxn(1,in),rms(1,1,is),rxo)
10    continue
      return
      end
"ENDOF ncsym.f"
#=======================================================================
echo pro2mx.f
cat >pro2mx.f <<"ENDOF pro2mx.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine pro2mx(ro,r2,r1)
      implicit none
      integer i,j,k
      real r1,r2,ro
      double precision add,d1,d2
      dimension d1(3,3),d2(3,3),r1(3,3),r2(3,3),ro(3,3)
       do i=1,3
        do j=1,3
      d1(i,j)=r1(i,j)
      d2(i,j)=r2(i,j)
        enddo
       enddo
       do i=1,3
        do j=1,3
      add=0.d0
         do k=1,3
      add=add+d2(i,k)*d1(k,j)
         enddo
      ro(i,j)=add
        enddo
       enddo
      return
      end
"ENDOF pro2mx.f"
#=======================================================================
echo rmxe.f
cat >rmxe.f <<"ENDOF rmxe.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine rmxe(alpha,beta,gamma,rotx)
      implicit none
      real alf,alpha,bet,beta,cosa,cosb,cosg,dtor,gam,gamma,pi,rotx,
     & rtod,sina,sinb,sing,twopi
      dimension rotx(3,3)
      common/angkte/ pi,twopi,dtor,rtod
      alf=alpha*dtor
      bet=beta*dtor
      gam=gamma*dtor
      cosa=cos(alf)
      cosb=cos(bet)
      cosg=cos(gam)
      sina=sin(alf)
      sinb=sin(bet)
      sing=sin(gam)
      rotx(1,1)= cosa*cosb*cosg-sina*sing
      rotx(1,2)=-cosa*cosb*sing-sina*cosg
      rotx(1,3)= cosa*sinb
      rotx(2,1)= sina*cosb*cosg+cosa*sing
      rotx(2,2)=-sina*cosb*sing+cosa*cosg
      rotx(2,3)= sina*sinb
      rotx(3,1)=     -sinb*cosg
      rotx(3,2)=      sinb*sing
      rotx(3,3)=      cosb
      return
      end
"ENDOF rmxe.f"
#=======================================================================
echo switch.f
cat >switch.f <<"ENDOF switch.f"
c ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      subroutine switch(nr,hmax,kmax,lmax,ho,ko,lo,ff,ftab,moln)
      implicit none
      integer bod,bodm,hmax,ho,i,kmax,ko,lmax,lo,mol,moln,nmol,nr,ns,
     & sym,symm,tbod
      real alf,alfm,bet,betm,corr,gam,gamm,ox,oxm,oy,oym,oz,ozm,rmx,
     & rmxm,tx,txm,ty,tym,tz,tzm,xxx
      complex ff,ftab
      dimension ff(nr),ftab(-hmax:hmax,-kmax:kmax,-lmax:lmax),ho(nr),
     & ko(nr),lo(nr)
      common/rotra/ mol,bod,alf,bet,gam,tx,ty,tz,rmx(9),ox,oy,oz,ns,
     & sym(1000),corr
      common/rotram/ bodm(100),alfm(100),betm(100),gamm(100),txm(100),
     & tym(100),tzm(100),rmxm(9,100),oxm(100),oym(100),ozm(100),
     & symm(1000,100),nmol
cjn al comienzo moln = mol
         if(moln.ne.mol) then
cjn agrega la molecula que se movia (mol) en su ultima posicion
      bodm(mol)=bod
      alfm(mol)=alf
      betm(mol)=bet
      gamm(mol)=gam
      txm(mol)=tx
      tym(mol)=ty
      tzm(mol)=tz
       do i=1,9
      rmxm(i,mol)=rmx(i)
       enddo
      oxm(mol)=ox
      oym(mol)=oy
      ozm(mol)=oz
       do i=1,ns
      symm(i,mol)=sym(i)
       enddo
      call ncsym
      call fixmol(nr,hmax,kmax,lmax,ho,ko,lo,ff,ftab,'+')
cjn se lee ftab solo si se cambia de modelo
            if(bod.ne.bodm(moln)) then
      bod=bodm(moln)
      tbod=bod+10
      call abra(tbod,'u','o')
      rewind(unit=tbod)
      read(tbod) (xxx,i=1,7),hmax,kmax,lmax
      call lectab(bod,hmax,kmax,lmax,ftab)
      call cierre(tbod,'u')
            endif
         endif
      mol=moln
cjn substrae la molecula que se movera (mol) en su posicion inicial
      bod=bodm(mol)
      alf=alfm(mol)
      bet=betm(mol)
      gam=gamm(mol)
      tx=txm(mol)
      ty=tym(mol)
      tz=tzm(mol)
       do i=1,9
      rmx(i)=rmxm(i,mol)
       enddo
      ox=oxm(mol)
      oy=oym(mol)
      oz=ozm(mol)
      ns=0
       do i=1,1000
      sym(i)=symm(i,mol)
      if(sym(i).eq.0) go to 10
      ns=ns+1
       enddo
10    continue
      call ncsym
      call fixmol(nr,hmax,kmax,lmax,ho,ko,lo,ff,ftab,'-')
      return
      end
"ENDOF switch.f"
"ENDOF fit.for"
#=======================================================================
echo uro.scr
cat >uro.scr <<"ENDOF uro.scr"
#=======================================================================
echo addsym
cat >! job <<"ENDOF job"
#!/bin/csh -f
# addsym *************************************
   if($#argv != 3) then
echo "Usage: {addsym} {G0} {G1} {M0}" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
$VEDABIN/addsym.exe <<EOF
${1} ${2} ${3}
EOF
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/addsym
#=======================================================================
echo origen
cat >! job <<"ENDOF job"
#!/bin/csh -f
# origen *************************************
set VEDABIN="$VEDA/$VEDA_BIN"
source $VEDABIN/entorno
ln -s $cwd/d/data.d $UROF/fort.8
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
      endif
      if(-e $cwd/d/xyz$n.d) then
set m=`expr $n + 50`
ln -s $cwd/d/xyz$n.d  $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$VEDABIN/origen.exe
sed -e 's/[ ]*$//' $UROF/fort.9 > $UROF/XYZ
csh -f $UROF/XYZ
rm -rf $UROF
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/origen
#=======================================================================
echo propre
cat >! job <<"ENDOF job"
#!/bin/csh -f
# propre *************************************
   if($#argv != 3) then
echo "Usage: {propre} o/{fiting_out}.s {nbody} {rms}" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
source $VEDABIN/entorno
ln -s $cwd/o/${1}.s $UROF/fort.1
ln -s $cwd/d/data.d $UROF/fort.8
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$VEDABIN/propre.exe <<EOF
${2} ${3}
EOF
rm -rf $UROF
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/propre
#=======================================================================
echo pv2rt
cat >! job <<"ENDOF job"
#!/bin/csh -f
# pv2rt **************************************
   if($#argv != 2) then
echo "Usage: {pv2rt} {o/fiting.s} {output}" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
source $VEDABIN/entorno
ln -s $cwd/d/data.d $UROF/fort.8
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$VEDABIN/pv2rt.exe < ${1} >! ${2}
rm -rf $UROF
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/pv2rt
#=======================================================================
echo rt2pv
cat >! job <<"ENDOF job"
#!/bin/csh -f
# rt2pv **************************************
   if($#argv != 2) then
echo "Usage: {rt2pv} {output} {o/fiting.s}" ; exit
   endif
set VEDABIN="$VEDA/$VEDA_BIN"
source $VEDABIN/entorno
ln -s $cwd/d/data.d $UROF/fort.8
set n="1"
   while ($n <= 100)
      if(-e $cwd/o/tabl$n.s) then
set m=`expr $n + 10`
ln -s $cwd/o/tabl$n.s $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$VEDABIN/rt2pv.exe < ${1} >! ${2}
rm -rf $UROF
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/rt2pv
#=======================================================================
echo entorno
cat >! job <<"ENDOF job"
#!/bin/csh -f
# entorno ************************************
set VEDABIN="$VEDA/$VEDA_BIN"
   if(-e e/stfing.exe) then
setenv UROS $cwd/e
   else
setenv UROS $VEDABIN
   endif
   if(-e e/uro.exe) then
setenv UROX $cwd/e
   else
setenv UROX $VEDABIN
   endif
   if(-e e/fitin.exe) then
setenv UROE $cwd/e
   else
setenv UROE $VEDABIN
   endif
set n="0"
   while (-e $cwd/temp_$n)
set n=`expr $n + 1`
   end
setenv UROF $cwd/temp_$n
mkdir $UROF
"ENDOF job"
chmod 600 job ; mv job $VEDA_BIN/entorno
#=======================================================================
echo wholepath
cat >! job <<"ENDOF job"
#!/bin/csh -f
# wholepath **********************************
set nom=''
set m=1
   while($m <= $#argv)
set name=$cwd'/'$argv[$m]
set n=1
      while($n <= 100)
set name=`echo $name |sed -e 's/\/[A-Za-z0-9_.-]\+\/\.\.//g'`
set n=`expr $n + 1`
      end
set name=`echo $name |sed -e 's/\.\///g' |sed -e 's/.*\/\//\//'`
set nom=`echo ${nom}' '$name`
set m=`expr $m + 1`
   end
echo $nom
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/wholepath
"ENDOF uro.scr"
#=======================================================================
echo fit.scr
cat >fit.scr <<"ENDOF fit.scr"
# to recover individual items, csh this file
#=======================================================================
echo fitin
cat >! job <<"ENDOF job"
#!/bin/csh -f
# fitin **************************************
   if($#argv < 1) then
echo "Usage: {fitin} {fiting-in}" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e ${1}) then
echo "No fiting input with this name = ${1}" ; exit
   endif
   if(! -e symlist) then
echo "NEED symlist FILE" ; exit
   endif
   if(! -e i/reso.i) then
echo "NEED i/reso.i FILE" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# generates symmetry operations to apply to the independent molecules in
# the working cell. transforms symmetry operations into fractional and
# subtracts the origin.
set SYM=SYM
set MAP=d/emap.d
cat i/reso.i >! i/fit.i
echo `head -20 ${MAP} | egrep -e "DIMENSIONS|SPACING|ORIGIN"` >! LisT
cat >! LisT1 <<"EOF"
{ printf "A=%8.3f;B=%8.3f;C=%8.3f;TX=%10.7f;TY=%10.7f;TZ=%10.7f\n",\
 $2*$6,$3*$7,$4*$8,$10/($2*$6),$11/($3*$7),$12/($4*$8) }
"EOF"
awk -f LisT1 LisT |sed -e "s/[ ]*//g" >! LisT2
set line=`cat LisT2`
rm -f LisT LisT1 LisT2
echo -n >! LisT1
set num="0"
   foreach sym (`cat symlist`)
egrep -e "#${sym}"$ $SYM >> LisT1
set num=`expr ${num} + 1`
   end
sed -e "/LINE/s/LINE/${line}/" <<"EOF" |sed -e "/NUMB/s/NUMB/${num}/" >! LisT2
BEGIN { LINE ; printf "ncs %5d\n",NUMB }
{ printf " %8.2f%8.2f%8.2f%10.5f%10.5f%10.5f      %s\n", \
       $1,$2,$3,$4/A-TX,$5/B-TY,$6/C-TZ,$7 }
"EOF"
awk -f LisT2 LisT1 >> i/fit.i
rm -f LisT1 LisT2
cat ${1} | wc -l >> i/fit.i
cat ${1} >> i/fit.i
echo '.true.' >> i/fit.i
echo 'ortho' >> i/fit.i
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/i/fit.i $UROF/fort.8
ln -s $cwd/f/iudi  $UROF/fort.10
set n="1"
   while ($n <= 100)
      if(-e $cwd/f/itabl$n) then
set m=`expr $n + 10`
ln -s $cwd/f/itabl${n} $UROF/fort.$m
      endif
set n=`expr $n + 1`
   end
$UROE/fitin.exe
rm -rf $UROF
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/fitin
#=======================================================================
echo tab2i
cat >! job <<"ENDOF job"
#!/bin/csh -f
# tab2i **************************************
   if($#argv < 1) then
echo "Usage: {tab2i} {#}" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e f/tabl${1}) then
echo "NEED f/tabl${1} FILE" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/f/tabl${1}  $UROF/fort.1
ln -s $cwd/f/itabl${1} $UROF/fort.2
$UROE/tab2i.exe < $cwd/i/reso.i
rm -rf $UROF
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/tab2i
#=======================================================================
echo udi2i
cat >! job <<"ENDOF job"
#!/bin/csh -f
# udi2i **************************************
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if(! -e f/xudi) then
echo "NEED f/xudi FILE" ; exit
   endif
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
source $VEDA/$VEDA_BIN/entorno
ln -s $cwd/f/xudi $UROF/fort.1
ln -s $cwd/f/iudi $UROF/fort.2
$UROE/udi2i.exe < $cwd/i/reso.i
rm -rf $UROF
"ENDOF job"
chmod 700 job ; mv job $VEDA_BIN/udi2i
"ENDOF fit.scr"
#=======================================================================
echo factor.d
cat >factor.d <<"ENDOF factor.d"
 H            1              1
     0.49300200    10.51089954     0.32291201    26.12570000     0.14019100     3.14235997     0.04081000    57.79970169     0.00303800
 H-1          2              1
     0.89766097    53.13679886     0.56561601    15.18700027     0.41581500   186.57600403     0.11697300     3.56709003     0.00238900
He            2              2
     0.87339997     9.10369968     0.63090003     3.35680008     0.31119999    22.92760086     0.17800000     0.98210001     0.00640000
Li            3              3
     1.12820005     3.95460010     0.75080001     1.05239999     0.61750001    85.39050293     0.46529999   168.26100159     0.03770000
Li+1          2              3
     0.69679999     4.62370014     0.78880000     1.95570004     0.34140000     0.63160002     0.15629999    10.09529972     0.01670000
Be            4              4
     1.59189999    43.64270020     1.12779999     1.86230004     0.53909999   103.48300171     0.70289999     0.54200000     0.03850000
Be+2          2              4
     6.26030016     0.00270000     0.88489997     0.83130002     0.79930001     2.27579999     0.16470000     5.11460018    -6.10920000
 B            5              5
     2.05450010    23.21850014     1.33260000     1.02100003     1.09790003    60.34980011     0.70679998     0.14030001    -0.19320001
 C            6              6
     2.30999994    20.84390068     1.01999998    10.20750046     1.58860004     0.56870002     0.86500001    51.65119934     0.21560000
 Cv           6              6
     2.26068997    22.69070053     1.56165004     0.65666503     1.05075002     9.75617981     0.83925903    55.59489822     0.28697699
 N            7              7
    12.21259975     0.00570000     3.13220000     9.89330006     2.01250005    28.99749947     1.16630006     0.58260000   -11.52900028
 O            8              8
     3.04850006    13.27709961     2.28679991     5.70109987     1.54630005     0.32390001     0.86699998    32.90890121     0.25080001
 O-1          9              8
     4.19159985    12.85729980     1.63969004     4.17235994     1.52672994    47.01789856   -20.30699921    -0.01404000    21.94120026
 F            9              9
     3.53920007    10.28250027     2.64120007     4.29440022     1.51699996     0.26150000     1.02429998    26.14760017     0.27759999
 F-1         10              9
     3.63220000     5.27756023     3.51057005    14.73530006     1.26064003     0.44225800     0.94070601    47.34370041     0.65339601
Ne           10             10
     3.95530009     8.40419960     3.11249995     3.42619991     1.45459998     0.23060000     1.12510002    21.71839905     0.35150000
Na           11             11
     4.76259995     3.28500009     3.17359996     8.84220028     1.26740003     0.31360000     1.11280000   129.42399597     0.67600000
Na+1         10             11
     3.25650001     2.66709995     3.93619990     6.11530018     1.39979994     0.20010000     1.00320005    14.03899956     0.40400001
Mg           12             12
     5.42040014     2.82750010     2.17350006    79.26110077     1.22689998     0.38080001     2.30730009     7.19369984     0.85839999
Mg+2         10             12
     3.49880004     2.16759992     3.83780003     4.75419998     1.32840002     0.18500000     0.84969997    10.14109993     0.48530000
Al           13             13
     6.42019987     3.03870010     1.90020001     0.74260002     1.59360003    31.54719925     1.96459997    85.08860016     1.11510003
Al+3         10             13
     4.17447996     1.93815994     3.38759995     4.14553022     1.20296001     0.22875300     0.52813703     8.28524017     0.70678598
Si           14             14
     6.29150009     2.43860006     3.03530002    32.33369827     1.98909998     0.67850000     1.54100001    81.69370270     1.14069998
Siv          14             14
     5.66269016     2.66520000     3.07164001    38.66339874     2.62445998     0.91694599     1.39320004    93.54579926     1.24706995
Si+4         10             14
     4.43917990     1.64166999     3.20344996     3.43757010     1.19453001     0.21490000     0.41653001     6.65364981     0.74629700
 P           15             15
     6.43450022     1.90670002     4.17910004    27.15699959     1.77999997     0.52600002     1.49080002    68.16449738     1.11489999
 S           16             16
     6.90530014     1.46790004     5.20340014    22.21509933     1.43789995     0.25360000     1.58630002    56.17200089     0.86690003
Cl           17             17
    11.46039963     0.01040000     7.19640017     1.16620004     6.25559998    18.51939964     1.64549994    47.77840042    -9.55739975
Cl-1         18             17
    18.29150009     0.00660000     7.20839977     1.17170000     6.53369999    19.54240036     2.33859992    60.44860077   -16.37800026
Ar           18             18
     7.48449993     0.90719998     6.77229977    14.84070015     0.65390003    43.89830017     1.64419997    33.39289856     1.44449997
 K           19             19
     8.21860027    12.79489994     7.43979979     0.77480000     1.05190003   213.18699646     0.86589998    41.68410110     1.42279994
 K+1         18             19
     7.95779991    12.63309956     7.49170017     0.76740003     6.35900021    -0.00200000     1.19149995    31.91279984    -4.99779987
Ca           20             20
     8.62660027    10.44209957     7.38730001     0.65990001     1.58990002    85.74839783     1.02110004   178.43699646     1.37510002
Ca+2         18             20
    15.63479996    -0.00740000     7.95179987     0.60890001     8.43719959    10.31159973     0.85369998    25.99049950   -14.87500000
Sc           21             21
     9.18900013     9.02130032     7.36789989     0.57290000     1.64090002   136.10800171     1.46800005    51.35309982     1.33290005
Sc+3         18             21
    14.40079975     0.29854000     8.02729988     7.96290016     1.65943003    -0.28604001     1.57936001    16.06620026    -6.66669989
Ti           22             22
     9.75949955     7.85080004     7.35580015     0.50000000     1.69910002    35.63380051     1.90209997   116.10500336     1.28069997
Ti+2         20             22
     9.11423016     7.52430010     7.62173986     0.45758501     2.27929997    19.53610039     0.08789900    61.65579987     0.89715499
Ti+3         19             22
    17.73439980     0.22060999     8.73816013     7.04716015     5.25690985    -0.15762000     1.92133999    15.97679996   -14.65200043
Ti+4         18             22
    19.51140022     0.17884700     8.23472977     6.67017984     2.01341009    -0.29262999     1.52079999    12.94639969   -13.27999973
 V           23             23
    10.29710007     6.86569977     7.35109997     0.43849999     2.07030010    26.89380074     2.05710006   102.47799683     1.21990001
 V+2         21             23
    10.10599995     6.88180017     7.35410023     0.44090000     2.28839993    15.19079971     0.02230000   115.12200165     1.22979999
 V+3         19             23
     9.43140984     6.39534998     7.74189997     0.38334900     2.15342999     0.00000000     0.01686500    63.96900177     0.65656501
 V+5         18             23
    15.68869972     0.67900300     8.14208031     5.40135002     2.03081012     9.97278023    -9.57600021     0.94046402     1.71430004
Cr           24             24
    10.64060020     6.10379982     7.35370016     0.39199999     3.32399988    20.26259995     1.49220002    98.73989868     1.18320000
Cr+2         22             24
     9.54034042     5.66077995     7.75089979     0.34426099     3.58274007    13.30749989     0.50910699    32.42240143     0.61689800
Cr+3         21             24
     9.68089962     5.59462976     7.81135988     0.33439299     2.87602997    12.82880020     0.11357500    32.87609863     0.51827502
Mn           25             25
    11.28190041     5.34089994     7.35729980     0.34320000     3.01929998    17.86739922     2.24410009    83.75430298     1.08959997
Mn+2         23             25
    10.80609989     5.27960014     7.36199999     0.34349999     3.52679992    14.34300041     0.21840000    41.32350159     1.08739996
Mn+3         22             25
     9.84521008     4.91797018     7.87194014     0.29439300     3.56531000    10.81709957     0.32361299    24.12809944     0.39397401
Mn+4         21             25
     9.96253014     4.84849977     7.97057009     0.28330299     2.76066995    10.48519993     0.05444700    27.57299995     0.25187701
Fe           26             26
    11.76949978     4.76109982     7.35729980     0.30720001     3.52220011    15.35350037     2.30450010    76.88050079     1.03690004
Fe+2         24             26
    11.04240036     4.65380001     7.37400007     0.30530000     4.13460016    12.05459976     0.43990001    31.28089905     1.00969994
Fe+3         23             26
    11.17640018     4.61469984     7.38630009     0.30050001     3.39479995    11.67290020     0.07240000    38.55659866     0.97070003
Co           27             27
    12.28409958     4.27909994     7.34089994     0.27840000     4.00339985    13.53590012     2.34879994    71.16919708     1.01180005
Co+2         25             27
    11.22959995     4.12309980     7.38829994     0.27260000     4.73929977    10.24429989     0.71079999    25.64660072     0.93239999
Co+3         24             27
    10.33800030     3.90968990     7.88173008     0.23866799     4.76795006     8.35583019     0.72559100    18.34910011     0.28666699
Ni           28             28
    12.83759975     3.87849998     7.29199982     0.25650001     4.44379997    12.17630005     2.38000011    66.34210205     1.03410006
Ni+2         26             28
    11.41660023     3.67659998     7.40049982     0.24490000     5.34420013     8.87300014     0.97729999    22.16259956     0.86140001
Ni+3         25             28
    10.78059959     3.54769993     7.75867987     0.22314000     5.22745991     7.64468002     0.84711403    16.96730042     0.38604400
Cu           29             29
    13.33800030     3.58279991     7.16760015     0.24699999     5.61579990    11.39659977     1.67349994    64.81259918     1.19099998
Cu+1         28             29
    11.94750023     3.36689997     7.35729980     0.22740000     6.24550009     8.66250038     1.55780005    25.84869957     0.88999999
Cu+2         27             29
    11.81680012     3.37484002     7.11181021     0.24407800     5.78135014     7.98759985     1.14523005    19.89699936     1.14431000
Zn           30             30
    14.07429981     3.26550007     7.03179979     0.23330000     5.16249990    10.31630039     2.41000009    58.70970154     1.30410004
Zn+2         28             30
    11.97189999     2.99460006     7.38619995     0.20310000     6.46680021     7.08260012     1.39400005    18.09950066     0.78070003
Ga           31             31
    15.23540020     3.06690001     6.70060015     0.24120000     4.35909986    10.78050041     2.96230006    61.41350174     1.71889997
Ga+3         28             31
    12.69200039     2.81261992     6.69883013     0.22789000     6.06691980     6.36440992     1.00660002    14.41219997     1.53544998
Ge           32             32
    16.08160019     2.85089993     6.37470007     0.25160000     3.70679998    11.44680023     3.68300009    54.76250076     2.13129997
Ge+4         28             32
    12.91720009     2.53717995     6.70002985     0.20585500     6.06791019     5.47912979     0.85904098    11.60299969     1.45571995
As           33             33
    16.67230034     2.63450003     6.07009983     0.26470000     3.43129992    12.94789982     4.27790022    47.79719925     2.53099990
Se           34             34
    17.00060081     2.40980005     5.81960011     0.27260000     3.97309995    15.23719978     4.35430002    43.81629944     2.84089994
Br           35             35
    17.17889977     2.17230010     5.23579979    16.57959938     5.63770008     0.26089999     3.98510003    41.43280029     2.95569992
Br-1         36             35
    17.17180061     2.20589995     6.33379984    19.33449936     5.57539988     0.28709999     3.72720003    58.15349960     3.17759991
Kr           36             36
    17.35549927     1.93840003     6.72860003    16.56229973     5.54930019     0.22610000     3.53749990    39.39720154     2.82500005
Rb           37             37
    17.17840004     1.78880000     9.64350033    17.31509972     5.13990021     0.27480000     1.52919996   164.93400574     3.48729992
Rb+1         36             37
    17.58160019     1.71389997     7.65980005    14.79570007     5.89809990     0.16030000     2.78169990    31.20870018     2.07820010
Sr           38             38
    17.56629944     1.55639994     9.81840038    14.09879971     5.42199993     0.16640000     2.66939998   132.37600708     2.50640011
Sr+2         36             38
    18.08740044     1.49070001     8.13729954    12.69629955     2.56539989    24.56509972   -34.19300079    -0.01380000    41.40250015
 Y           39             39
    17.77599907     1.40289998    10.29459953    12.80060005     5.72629023     0.12559900     3.26588011   104.35399628     1.91213000
 Y+3         36             39
    17.92679977     1.35416996     9.15310001    11.21450043     1.76795006    22.65990067   -33.10800171    -0.01319000    40.26020050
Zr           40             40
    17.87649918     1.27618003    10.94799995    11.91600037     5.41731977     0.11762200     3.65721011    87.66269684     2.06928992
Zr+4         36             40
    18.16679955     1.21480000    10.05620003    10.14830017     1.01118004    21.60540009    -2.64790010    -0.10276000     9.41454029
Nb           41             41
    17.61420059     1.18865001    12.01439953    11.76599979     4.04183006     0.20478500     3.53345990    69.79570007     3.75590992
Nb+3         38             41
    19.88120079     0.01917500    18.06529999     1.13304996    11.01770020    10.16209984     1.94714999    28.33889961   -12.91199970
Nb+5         36             41
    17.91629982     1.12445998    13.34169960     0.02878100    10.79899979     9.28205967     0.33790499    25.72279930    -6.39340019
Mo           42             42
     3.70250010     0.27720001    17.23559952     1.09580004    12.88759995    11.00399971     3.74289989    61.65840149     4.38749981
Mo+3         39             42
    21.16640091     0.01473400    18.20170021     1.03031003    11.74230003     9.53658962     2.30950999    26.63069916   -14.42099953
Mo+5         37             42
    21.01490021     0.01434500    18.09919930     1.02237999    11.46319962     8.78808975     0.74062502    23.34519958   -14.31599998
Mo+6         36             42
    17.88710022     1.03648996    11.17500019     8.48060989     6.57890987     0.05888100     0.00000000     0.00000000     0.34494099
Tc           43             43
    19.13010025     0.86413199    11.09480000     8.14486980     4.64901018    21.57069969     2.71263003    86.84719849     5.40428019
Ru           44             44
    19.26740074     0.80852002    12.91819954     8.43467045     4.86336994    24.79969978     1.56755996    94.29280090     5.37873983
Ru+3         41             44
    18.56380081     0.84732902    13.28849983     8.37164021     9.32602024     0.01766200     3.00963998    22.88699913    -3.18919992
Ru+4         40             44
    18.50029945     0.84458202    13.17870045     8.12534046     4.71303988     0.36495000     2.18534994    20.85040092     1.42357004
Rh           45             45
    19.29570007     0.75153601    14.35009956     8.21757984     4.73425007    25.87490082     1.28918004    98.60620117     5.32800007
Rh+3         42             45
    18.87849998     0.76425201    14.12590027     7.84437990     3.32515001    21.24869919    -6.19890022    -0.01036000    11.86779976
Rh+4         41             45
    18.85449982     0.76082498    13.98060036     7.62436008     2.53464007    19.33169937    -5.65259981    -0.01020000    11.28349972
Pd           46             46
    19.33189964     0.69865501    15.50170040     7.98929024     5.29537010    25.20520020     0.60584402    76.89859772     5.26593018
Pd+2         44             46
    19.17009926     0.69621903    15.20960045     7.55572987     4.32234001    22.50569916     0.00000000     0.00000000     5.29160023
Pd+4         42             46
    19.24930000     0.68383902    14.78999996     7.14833021     2.89288998    17.91440010    -7.94920015     0.00512700    13.01739979
Ag           47             47
    19.28079987     0.64459997    16.68849945     7.47259998     4.80450010    24.66049957     1.04630005    99.81559753     5.17899990
Ag+1         46             47
    19.18120003     0.64617902    15.97189999     7.19122982     5.27475023    21.73259926     0.35753399    66.11470032     5.21572018
Ag+2         45             47
    19.16430092     0.64564300    16.24559975     7.18544006     4.37090015    21.40719986     0.00000000     0.00000000     5.21403980
Cd           48             48
    19.22139931     0.59460002    17.64439964     6.90889978     4.46099997    24.70079994     1.60290003    87.48249817     5.06939983
Cd+2         46             48
    19.15139961     0.59792203    17.25349998     6.80638981     4.47128010    20.25209999     0.00000000     0.00000000     5.11936998
In           49             49
    19.16239929     0.54759997    18.55960083     6.37760019     4.29479980    25.84989929     2.03959990    92.80290222     4.93909979
In+3         46             49
    19.10449982     0.55152202    18.11079979     6.32469988     3.78896999    17.35950089     0.00000000     0.00000000     4.99634981
Sn           50             50
    19.18889999     5.83029985    19.10050011     0.50309998     4.45849991    26.89089966     2.46630001    83.95709991     4.78210020
Sn+2         48             50
    19.10939980     0.50360000    19.05480003     5.83780003     4.56479979    23.37520027     0.48699999    62.20610046     4.78609991
Sn+4         46             50
    18.93330002     5.76399994    19.71310043     0.46550000     3.41820002    14.00489998     0.01930000    -0.75830001     3.91820002
Sb           51             51
    19.64179993     5.30340004    19.04549980     0.46070001     5.03709984    27.90740013     2.68269992    75.28250122     4.59089994
Sb+3         48             51
    18.97550011     0.46719599    18.93300056     5.22126007     5.10789013    19.59020042     0.28875300    55.51129913     4.69625998
Sb+5         46             51
    19.86849976     5.44853020    19.03019905     0.46797299     2.41252995    14.12590027     0.00000000     0.00000000     4.69262981
Te           52             52
    19.96439934     4.81742001    19.01379967     0.42088500     6.14486980    28.52840042     2.52390003    70.84030151     4.35200024
 I           53             53
    20.14719963     4.34700012    18.99489975     0.38139999     7.51380014    27.76600075     2.27349997    66.87760162     4.07119989
 I-1         54             53
    20.23320007     4.35790014    18.99699974     0.38150001     7.80690002    29.52589989     2.88680005    84.93039703     4.07140017
Xe           54             54
    20.29330063     3.92820001    19.02980042     0.34400001     8.97669983    26.46590042     1.99000001    64.26580048     3.71180010
Cs           55             55
    20.38920021     3.56900001    19.10619926     0.31070000    10.66199970    24.38789940     1.49530005   213.90400696     3.33520007
Cs+1         54             55
    20.35239983     3.55200005    19.12779999     0.30860001    10.28209972    23.71279907     0.96149999    59.45650101     3.27909994
Ba           56             56
    20.33609962     3.21600008    19.29700089     0.27559999    10.88799953    20.20730019     2.69589996   167.20199585     2.77309990
Ba+2         54             56
    20.18070030     3.21367002    19.11359978     0.28331000    10.90540028    20.05579948     0.77634001    51.74599838     3.02902007
La           57             57
    20.57799911     2.94816995    19.59900093     0.24447501    11.37269974    18.77260017     3.28718996   133.12399292     2.14678001
La+3         54             57
    20.24889946     2.92070007    19.37630081     0.25069800    11.63230038    17.82110023     0.33604801    54.94530106     2.40860009
Ce           58             58
    21.16710091     2.81219006    19.76950073     0.22683600    11.85130024    17.60829926     3.33049011   127.11299896     1.86264002
Ce+3         55             58
    20.80360031     2.77691007    19.55900002     0.23153999    11.93690014    16.54080009     0.61237597    43.16920090     2.09013009
Ce+4         54             58
    20.32349968     2.65941000    19.81859970     0.21885000    12.12329960    15.79920006     0.14458300    62.23550034     1.59179997
Pr           59             59
    22.04400063     2.77393007    19.66970062     0.22208700    12.38560009    16.76689911     2.82428002   143.64399719     2.05830002
Pr+3         56             59
    21.37269974     2.64520001    19.74909973     0.21429899    12.13290024    15.32299995     0.97517997    36.40650177     1.77131999
Pr+4         55             59
    20.94129944     2.54467010    20.05389977     0.20248100    12.46679974    14.81369972     0.29668900    45.46429825     1.24284995
Nd           60             60
    22.68449974     2.66248012    19.68470001     0.21062800    12.77400017    15.88500023     2.85137010   137.90299988     1.98485994
Nd+3         57             60
    21.96100044     2.52722001    19.93390083     0.19923700    12.11999989    14.17829990     1.51031005    30.87170029     1.47588003
Pm           61             61
    23.34049988     2.56270003    19.60950089     0.20208800    13.12349987    15.10089970     2.87515998   132.72099304     2.02875996
Pm+3         58             61
    22.55270004     2.41739988    20.11079979     0.18576901    12.06709957    13.12749958     2.07491994    27.44910049     1.19499004
Sm           62             62
    24.00419998     2.47273993    19.42580032     0.19645099    13.43959999    14.39960003     2.89603996   128.00700378     2.20963001
Sm+3         58             62
    23.15040016     2.31641006    20.25989914     0.17408100    11.92020035    12.15709972     2.71487999    24.82419968     0.95458603
Eu           63             63
    24.62739944     2.38790011    19.08860016     0.19419999    13.76029968    13.75459957     2.92269993   123.17400360     2.57450008
Eu+2         61             63
    24.00629997     2.27782989    19.95039940     0.17353000    11.80340004    11.60960007     3.87243009    26.51560020     1.36389005
Eu+3         60             63
    23.74970055     2.22257996    20.37450027     0.16394000    11.85089970    11.31099987     3.26502991    22.99659920     0.75934398
Gd           64             64
    25.07089996     2.25341010    19.07979965     0.18195100    13.85179996    12.93309975     3.54544997   101.39800262     2.41960001
Gd+3         61             64
    24.34659958     2.13552999    20.42079926     0.15552500    11.87080002    10.57820034     3.71490002    21.70289993     0.64508897
Tb           65             65
    25.89760017     2.24255991    18.21850014     0.19614300    14.31669998    12.66479969     2.95354009   115.36199951     3.58224010
Tb+3         62             65
    24.95590019     2.05601001    20.32710075     0.14952500    12.24709988    10.04990005     3.77300000    21.27729988     0.69196701
Dy           66             66
    26.50699997     2.18020010    17.63829994     0.20217200    14.55959988    12.18990040     2.96577001   111.87400055     4.29727983
Dy+3         63             66
    25.53949928     1.98039997    20.28610039     0.14338399    11.98120022     9.34972000     4.50073004    19.58099937     0.68968999
Ho           67             67
    26.90489960     2.07050991    17.29400063     0.19794001    14.55830002    11.44069958     3.63837004    92.65660095     4.56795979
Ho+3         64             67
    26.12960052     1.91071999    20.09939957     0.13935800    11.97879982     8.80018044     4.93675995    18.59079933     0.85279500
Er           68             68
    27.65629959     2.07356000    16.42849922     0.22354500    14.97789955    11.36040020     2.98233008   105.70300293     5.92046022
Er+3         65             68
    26.72200012     1.84659004    19.77479935     0.13729000    12.15060043     8.36225033     5.17378998    17.89739990     1.17613006
Tm           69             69
    28.18190002     2.02858996    15.88510036     0.23884900    15.15419960    10.99750042     2.98706007   102.96099854     6.75620985
Tm+3         66             69
    27.30830002     1.78710997    19.33200073     0.13697401    12.33390045     7.96778011     5.38348007    17.29220009     1.63928998
Yb           70             70
    28.66410065     1.98889995    15.43449974     0.25711900    15.30869961    10.66469955     2.98962998   100.41699982     7.56672001
Yb+2         68             70
    28.12089920     1.78503001    17.68169975     0.15997000    13.33349991     8.18303967     5.14657021    20.38999939     3.70983005
Yb+3         67             70
    27.89170074     1.73272002    18.76140022     0.13879000    12.60719967     7.64412022     5.47646999    16.81430054     2.26001000
Lu           71             71
    28.94759941     1.90181994    15.22080040     9.98519039    15.10000038     0.26103300     3.71601009    84.32980347     7.97628021
Lu+3         68             71
    28.46279907     1.68216002    18.12100029     0.14229199    12.84290028     7.33726978     5.59415007    16.35350037     2.97572994
Hf           72             72
    29.14399910     1.83262002    15.17259979     9.59990025    14.75860023     0.27511600     4.30012989    72.02899933     8.58154011
Hf+4         68             72
    28.81310081     1.59135997    18.46010017     0.12890300    12.72850037     6.76232004     5.59926987    14.03660011     2.39699006
Ta           73             73
    29.20240021     1.77332997    15.22929955     9.37045956    14.51350021     0.29597700     4.76492023    63.36439896     9.24353981
Ta+5         68             73
    29.15870094     1.50711000    18.84070015     0.11674100    12.82680035     6.31523991     5.38695002    12.42440033     1.78555000
 W           74             74
    29.08180046     1.72028995    15.43000031     9.22589970    14.43270016     0.32170299     5.11982012    57.05599976     9.88749981
 W+6         68             74
    29.49360085     1.42754996    19.37630081     0.10462100    13.05440044     5.93666983     5.06411982    11.19719982     1.01074004
Re           75             75
    28.76210022     1.67191005    15.71889973     9.09226990    14.55640030     0.35049999     5.44174004    52.08610153    10.47200012
Os           76             76
    28.18939972     1.62902999    16.15500069     8.97947979    14.93050003     0.38266101     5.67588997    48.16469955    11.00049973
Os+4         72             76
    30.41900063     1.37112999    15.26369953     6.84706020    14.74580002     0.16519099     5.06794977    18.00300026     6.49804020
Ir           77             77
    27.30489922     1.59279001    16.72960091     8.86553001    15.61149979     0.41791600     5.83376980    45.00109863    11.47220039
Ir+3         74             77
    30.41559982     1.34323001    15.86200047     7.10908985    13.61450005     0.20463300     5.82007980    20.32539940     8.27902985
Ir+4         73             77
    30.70579910     1.30922997    15.55119991     6.71983004    14.23260021     0.16725200     5.53671980    17.49110031     6.96823978
Pt           78             78
    27.00589943     1.51293004    17.76390076     8.81173992    15.71310043     0.42459300     5.78369999    38.61029816    11.68830013
Pt+2         76             78
    29.84289932     1.32927001    16.72240067     7.38979006    13.21529961     0.26329699     6.35234022    22.94260025     9.85328960
Pt+4         74             78
    30.96120071     1.24812996    15.98289967     6.60833979    13.73480034     0.16864000     5.92034006    16.93919945     7.39533997
Au           79             79
    16.88190079     0.46110001    18.59129906     8.62160015    25.55820084     1.48259997     5.86000013    36.39559937    12.06579971
Au+1         78             79
    28.01090050     1.35320997    17.82040024     7.73950005    14.33590031     0.35675201     6.58077002    26.40430069    11.22990036
Au+3         76             79
    30.68860054     1.21990001    16.90290070     6.82872009    12.78009987     0.21286701     6.52354002    18.65900040     9.09679985
Hg           80             80
    20.68090057     0.54500002    19.04170036     8.44839954    21.65749931     1.57290006     5.96759987    38.32460022    12.60890007
Hg+1         79             80
    25.08530045     1.39506996    18.49729919     7.65105009    16.88829994     0.44337800     6.48216009    28.22620010    12.02050018
Hg+2         78             80
    29.56410027     1.21151996    18.05999947     7.05638981    12.83740044     0.28473800     6.89911985    20.74819946    10.62679958
Tl           81             81
    27.54459953     0.65515000    19.15839958     8.70750999    15.53800011     1.96346998     5.52592993    45.81489944    13.17459965
Tl+1         80             81
    21.39850044     1.47109997    20.47229958     0.51739401    18.74780083     7.43462992     6.82847023    28.84819984    12.52579975
Tl+3         78             81
    30.86949921     1.10080004    18.38409996     6.53851986    11.93280029     0.21907400     7.00574017    17.21139908     9.80270004
Pb           82             82
    31.06170082     0.69019997    13.06369972     2.35759997    18.44199944     8.61800003     5.96960020    47.25790024    13.41180038
Pb+2         80             82
    21.78860092     1.33659995    19.56819916     0.48838300    19.14060020     6.77269983     7.01106977    23.81320000    12.47340012
Pb+4         78             82
    32.12440109     1.00566006    18.80030060     6.10926008    12.01749992     0.14704099     6.96886015    14.71399975     8.08428001
Bi           83             83
    33.36890030     0.70400000    12.95100021     2.92379999    16.58769989     8.79370022     6.46920013    48.00930023    13.57820034
Bi+3         80             83
    21.80529976     1.23559999    19.50259972     6.24148989    19.10530090     0.46999899     7.10295010    20.31850052    12.47109985
Bi+5         78             83
    33.53639984     0.91654003    25.09460068     0.39041999    19.24970055     5.71413994     6.91555023    12.82849979    -6.79939985
Po           84             84
    34.67259979     0.70099902    15.47329998     3.55078006    13.11380005     9.55642033     7.02587986    47.00450134    13.67700005
At           85             85
    35.31629944     0.68586999    19.02109909     3.97458005     9.49886990    11.38239956     7.42517996    45.47150040    13.71080017
Rn           86             86
    35.56309891     0.66310000    21.28160095     4.06909990     8.00370026    14.04220009     7.44329977    44.24729919    13.69050026
Fr           87             87
    35.92990112     0.64645302    23.05470085     4.17618990    12.14389992    23.10519981     2.11252999   150.64500427    13.72469997
Ra           88             88
    35.76300049     0.61634099    22.90640068     3.87135005    12.47389984    19.98870087     3.21096992   142.32499695    13.62110043
Ra+2         86             88
    35.21500015     0.60490900    21.67000008     3.57669997     7.91342020    12.60099983     7.65078020    29.84359932    13.54310036
Ac           89             89
    35.65969849     0.58909202    23.10320091     3.65155005    12.59770012    18.59900093     4.08655024   117.01999664    13.52659988
Ac+3         86             89
    35.17359924     0.57968903    22.11120033     3.41437006     8.19215965    12.91870022     7.05544996    25.94429970    13.46370029
Th           90             90
    35.56449890     0.56335902    23.42189980     3.46203995    12.74730015    17.83090019     4.80703020    99.17220306    13.43140030
Th+4         86             90
    35.10070038     0.55505401    22.44179916     3.24498010     9.78553963    13.46609974     5.29443979    23.95330048    13.37600040
Pa           91             91
    35.88470078     0.54775101    23.29479980     3.41518998    14.18910027    16.92350006     4.17287016   105.25099945    13.42870045
 U           92             92
    36.02280045     0.52929997    23.41279984     3.32529998    14.94909954    16.09269905     4.18800020   100.61299896    13.39659977
 U+3         89             92
    35.57469940     0.52047998    22.52589989     3.12293005    12.21650028    12.71479988     5.37072992    26.33939934    13.30920029
 U+4         88             92
    35.37149811     0.51659799    22.53260040     3.05052996    12.02910042    12.57229996     4.79839993    23.45820045    13.26710033
 U+6         86             92
    34.85089874     0.50707901    22.75839996     2.89030004    14.00990009    13.17669964     1.21457005    25.20170021    13.16650009
Np           93             93
    36.18740082     0.51192898    23.59639931     3.25395989    15.64019966    15.36219978     4.18550014    97.49079895    13.35729980
Np+3         90             93
    35.70740128     0.50232202    22.61300087     3.03806996    12.98980045    12.14490032     5.43227005    25.49279976    13.25440025
Np+4         89             93
    35.51029968     0.49862599    22.57869911     2.96626997    12.77659988    11.94839954     4.92158985    22.75020027    13.21160030
Np+6         87             93
    35.01359940     0.48980999    22.72859955     2.81099010    14.38840008    12.32999992     1.75669003    22.65810013    13.11299992
Pu           94             94
    36.52539825     0.49938399    23.80830002     3.26371002    16.77070045    14.94550037     3.47947001   105.98000336    13.38119984
Pu+3         91             94
    35.84000015     0.48493600    22.71689987     2.96117997    13.58069992    11.53310013     5.66016006    24.39920044    13.19909954
Pu+4         90             94
    35.64929962     0.48142201    22.64599991     2.89019990    13.35949993    11.31599998     5.18831015    21.83009911    13.15550041
Pu+6         88             94
    35.17359924     0.47320399    22.71809959     2.73848009    14.76350021    11.55300045     2.28678012    20.93029976    13.05819988
Am           95             95
    36.67060089     0.48362899    24.09919930     3.20647001    17.34149933    14.31359959     3.49330997   102.27300262    13.35919952
Cm           96             96
    36.64879990     0.46515399    24.40959930     3.08997011    17.39900017    13.43459988     4.21665001    88.48339844    13.28870010
Bk           97             97
    36.78810120     0.45101801    24.77359962     3.04619002    17.89189911    12.89459991     4.23284006    86.00299835    13.27540016
Cf           98             98
    36.91849899     0.43753299    25.19949913     3.00775003    18.33169937    12.40439987     4.24390984    83.78810120    13.26739979
"ENDOF factor.d"
#=======================================================================
echo bundle
cat >bundle <<"ENDOF bundle"
#!/bin/csh -f
# bundle: rassemble fichiers pour distribution
   foreach nom ($argv[*])
echo "#======================================================================="
echo "echo $nom"
set Nom=(\"ENDOF $nom\")
echo "cat >$nom <<"$Nom
cat $nom
echo $Nom
   end
"ENDOF bundle"
